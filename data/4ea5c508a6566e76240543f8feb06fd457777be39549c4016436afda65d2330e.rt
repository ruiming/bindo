{"post":{"title":"Angular2之折腾记","date":"undefined","id":"4ea5c508a6566e76240543f8feb06fd457777be39549c4016436afda65d2330e","tags":["Angular","JavaScript"],"content":"<p>前几天 Angular2 正式发布了，虽然他也在我的学习计划里面，但我并没有把他应用在我最近开展的一个项目中。最近在写一个 Rss 订阅器，基于 Angular1 和 Koa2(总感觉两个有点不搭 =.= )，主要是不想在这个项目花太长时间，再者我还想集我目前掌握的所有技术之大成写一个能拿的出手的项目，所以就没有选择 Angular2 了。至于 Koa2，其实很早就想学了，只是之前一直在忙别的。</p>\n<h2 id=\"angular-resource-\">angular-resource 介绍</h2>\n<p>今天捣鼓 Angular 的 Resource 功能，前端后端都掌握在自己的手上时去用 Angular 的 Resource 特别舒服，大大减少了代码量，特么强大。</p>\n<pre><code class=\"lang-js\">(<span class=\"keyword\">function</span>() {\n    angular\n        .module(&amp;<span class=\"comment\">#39;app&amp;#39;)</span>\n        .factory(&amp;<span class=\"comment\">#39;Post&amp;#39;, $resource =&gt; {</span>\n            <span class=\"keyword\">return</span> <span class=\"variable\">$resource</span>(&amp;<span class=\"comment\">#39;/api/feed/:feed_id/post/:id&amp;#39;, {id: &amp;#39;@_id&amp;#39;}, {</span>\n                update: {method: &amp;<span class=\"comment\">#39;PUT&amp;#39;},</span>\n                get: {method: &amp;<span class=\"comment\">#39;GET&amp;#39;, cache: true}</span>\n            });\n        })\n}());\n</code></pre>\n<p>在上面我定义了一个 <code>Post</code> 资源，一旦创建完成后，他就自动拥有了以下方法。</p>\n<pre><code class=\"lang-js\">{\n    &amp;<span class=\"comment\">#39;get&amp;#39;: {method: &amp;#39;GET&amp;#39;},</span>\n    &amp;<span class=\"comment\">#39;save&amp;#39;: {method: &amp;#39;POST&amp;#39;},</span>\n    &amp;<span class=\"comment\">#39;query&amp;#39;: {method: &amp;#39;GET&amp;#39;, isArray: true},</span>\n    &amp;<span class=\"comment\">#39;remove&amp;#39;: {method: &amp;#39;DELETE&amp;#39;},</span>\n    &amp;<span class=\"comment\">#39;delete&amp;#39;: {method: &amp;#39;DELETE&amp;#39;}</span>\n}\n</code></pre>\n<p>有些 IE 浏览器可能不支持 <code>delete</code>，这时候可以使用 <code>remove</code>。\n我们还可以自定义或者修改里面的方法，比如我上面中就自定义了一个 <code>update</code> 方法以及给 <code>get</code> 方法开启了缓存。</p>\n<p>那怎么使用呢？也很简单，如果对 <code>restfulAPI</code> 比较熟悉应该很容易理解。</p>\n<pre><code class=\"lang-js\"><span class=\"variable\">$stateProvider</span>\n    .state(&amp;<span class=\"comment\">#39;feed.post&amp;#39;, {</span>\n          url: &amp;<span class=\"comment\">#39;/post/:post_id&amp;#39;,</span>\n          templateUrl: &amp;<span class=\"comment\">#39;post/post_tpl.html&amp;#39;,</span>\n          controller: &amp;<span class=\"comment\">#39;PostController as vm&amp;#39;,</span>\n          resolve: {\n              post: <span class=\"keyword\">function</span>(Post, <span class=\"variable\">$stateParams</span>, <span class=\"variable\">$state</span>) {\n                  <span class=\"keyword\">return</span> Post.get({feed_id: <span class=\"variable\">$stateParams</span>.id, id: <span class=\"variable\">$stateParams</span>.post_id}).<span class=\"variable\">$promise</span>;\n              }\n          }\n      })\n</code></pre>\n<p>这里就调用了 <code>get</code> 方法，同时把参数传入，这样就好了。其他方法其实一样的。\n<code>resource</code> 也有很多功能。</p>\n<pre><code class=\"lang-js\"><span class=\"variable\">$resource</span>(url, [paramDefaults], [actions], options);\n</code></pre>\n<p>第二个参数设置默认参数用，比如我们发起了一个 <code>get</code> 请求得到数据，这条数据有一个 <code>_id</code> 属性，我们可以把他绑定为默认的 <code>id</code> 参数，这样在之后执行该资源的其他方法时我们可以不指定 <code>id</code>。\n第三个参数就是自定义方法的地方了，前面我给 <code>get</code> 方法升级了下，是这样的，这个也就是第三个参数了。</p>\n<pre><code class=\"lang-js\"><span class=\"variable\">$resource</span>(&amp;<span class=\"comment\">#39;/api/feed/:feed_id/post/:id&amp;#39;, {id: &amp;#39;@_id&amp;#39;}, {</span>\n    update: {method: &amp;<span class=\"comment\">#39;PUT&amp;#39;},</span>\n    get: {method: &amp;<span class=\"comment\">#39;GET&amp;#39;, cache: true}</span>\n});\n</code></pre>\n<p>格式是这样的：</p>\n<pre><code class=\"lang-js\">{action1: {method:?, params:?, isArray:?, headers:?, ...},\n action2: {method:?, params:?, isArray:?, headers:?, ...},\n ...}\n</code></pre>\n<p>更多说明参考<a href=\"https://docs.angularjs.org/api/ngResource/service/$resource\">官方文档</a>咯。\n第四个参数没看明白，可以自己看下官方文档。</p>\n<h2 id=\"angular-resource-\">angular-resource 缓存问题</h2>\n<p>上一个项目没有用 angular-resource 的时候，我就在 factory 里面缓存 response，下次请求时直接返回该 response。由于用户所操作的和所缓存的都是同一个对象，因此在进行一些对该 response 的修改时比如，用户进行点赞操作，那么我除了发出一个请求之外，我还要将 response 里的是否点赞的值修改过来，这样视图才能反映出来，由于和缓存是同一份东西，因此实现了缓存的同步变化。\n但不知道是不是这种方式容易导致缓存被破坏还是怎么样，我看了下 angular 以及 angular-resource 的部分源码，发现 angular 在处理 http 缓存时对数据进行了 serialize 操作，而且第一次返回给用户的并不是缓存的结果，而是自己 resource 里面的东西，下次访问时才从缓存取出来后 deserialize 后返回。 \n关于这个问题其实老早就有人发出 issue 了，但官方并没有回应，目前比较好的解决方案就是在修改资源时，删除缓存。可以这样操作:</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> <span class=\"variable\">$httpDefaultCache</span> = <span class=\"variable\">$cacheFactory</span>.get(&amp;<span class=\"comment\">#39;$http&amp;#39;);</span>\n<span class=\"variable\">$httpDefaultCache</span>.remove(key)；\n<span class=\"comment\">// The cache key is the request URL including search parameters;</span>\n</code></pre>\n<p>那有没有更好的办法呢，其实我也想过，有想到用缓存数据替代返回到控制器的数据，然而从这个尝试开始就发现了很多很坑的地方。\n我在 httpInjector 里面拦截 response 加入了这么一段代码</p>\n<pre><code class=\"lang-javascript\">setTimeout(() =&gt; {\n     <span class=\"comment\">// 只对 resource 的 cache 进行处理</span>\n     <span class=\"keyword\">if</span>(config.config &amp;&amp; config.config.cache === <span class=\"keyword\">true</span>) {\n         let url = config.config.url;\n         <span class=\"variable\">$cacheFactory</span>.get(&amp;<span class=\"comment\">#39;$http&amp;#39;).get(url)[1] = angular.fromJson($cacheFactory.get(&amp;#39;$http&amp;#39;).get(url)[1]);</span>\n         config.resource.data = <span class=\"variable\">$cacheFactory</span>.get(&amp;<span class=\"comment\">#39;$http&amp;#39;).get(url)[1].data;</span>\n         config.config.data = <span class=\"variable\">$cacheFactory</span>.get(&amp;<span class=\"comment\">#39;$http&amp;#39;).get(url)[1].data;</span>\n         config.data = <span class=\"variable\">$cacheFactory</span>.get(&amp;<span class=\"comment\">#39;$http&amp;#39;).get(url)[1].data;</span>\n         console.log(<span class=\"variable\">$cacheFactory</span>.get(&amp;<span class=\"comment\">#39;$http&amp;#39;).get(url));</span>\n     }\n });\n</code></pre>\n<p>作用就时强制 serialize 缓存的数据，然后讲全部数据都替换成缓存中的数据，由于在这一阶段并没有开始缓存，所以要设置 setTimeout 推迟操作。\n这样做了之后，对第一次加载仍然没有什么影响，但第二次加载时就开始起作用了，更改会同步变化到缓存，其实就是之后用的就直接是缓存的对象，而不再是 deserialize 化后的数据，这一步应该归功于我修改了缓存中数据的存储形式。\n由于第一次返回给控制器的数据并不是从缓存取出来的，而是从 resource 里面取出来的即上面的 <code>config.resource.data</code>，所以我也把他改到缓存中的对象去。为了更好说明问题，我把控制器代码也贴上来。我的目的就是进行 mark 操作后缓存也会自动同步过来。</p>\n<pre><code class=\"lang-javascript\">(<span class=\"keyword\">function</span>() {\n    angular\n        .module(&amp;<span class=\"comment\">#39;app&amp;#39;)</span>\n        .controller(&amp;<span class=\"comment\">#39;PostController&amp;#39;, PostController);</span>\n\n    <span class=\"keyword\">function</span> PostController(<span class=\"variable\">$state</span>, post, Post, <span class=\"variable\">$scope</span>, _, <span class=\"variable\">$rootScope</span>, <span class=\"variable\">$timeout</span>, <span class=\"variable\">$cacheFactory</span>) {\n        <span class=\"keyword\">var</span> vm = <span class=\"keyword\">this</span>;\n        vm.post = post;\n\n        vm.mark = mark;\n\n        vm.currentPost = post.data.result;\n        vm.currentPostDetail = post.data.detail;\n\n        <span class=\"keyword\">function</span> mark() {\n            vm.currentPostDetail.mark = !vm.currentPostDetail.mark;\n            Post.update({feed_id: vm.currentPost.feed_id[<span class=\"number\">0</span>], id: vm.currentPost._id}, {type: &amp;<span class=\"comment\">#39;mark&amp;#39;});</span>\n        }\n    }\n}());\n</code></pre>\n<p>按理说，控制器初始化的时候 <code>post</code> 是一个 resource 对象，我在 <code>setTimeout</code> 中修改了 resource 内部的数据，指向到缓存中被 serialize 化的数据。而 <code>vm.currentPost</code> 和 <code>vm.currentPostDetail</code> 又是分别指向 <code>post.data.result</code> 和 <code>post.data.detail</code>，应该我在 <code>vm</code> 上面的操作可以影响到缓存才对，然而并不能。试试看修改 <code>mark</code> 方法。</p>\n<pre><code class=\"lang-javascript\"><span class=\"keyword\">function</span> mark() {\n    vm.currentPostDetail.mark = !vm.currentPostDetail.mark;\n    post.data.detail.mark = !post.data.detail.mark;\n    Post.update({feed_id: vm.currentPost.feed_id[<span class=\"number\">0</span>], id: vm.currentPost._id}, {type: &amp;<span class=\"comment\">#39;mark&amp;#39;, revert: true});</span>\n}\n</code></pre>\n<p>也就是加了一句话，更改 <code>post</code> 中的数据。结果是工作了！这说明 post 确实此时是指向缓存的。那 <code>vm.currentPostDetail</code> 也是指向 <code>post.data.detail</code> 的，为什么它不工作？\n其实这不是 angular 的锅，console 试试下面就知道了。</p>\n<pre><code class=\"lang-javascript\">pre = {status: <span class=\"number\">200</span>, result: {detail: {a:<span class=\"number\">1</span>}, result: {b:<span class=\"number\">2</span>}}};\nctrl = pre.result.detail;        <span class=\"comment\">// {a:1}</span>\ncache = {status: <span class=\"number\">200</span>, result: {detail: {a:<span class=\"number\">2</span>}, result: {b:<span class=\"number\">3</span>}}};\npre = cache;\nconsole.log(ctrl);                <span class=\"comment\">// {a:1}</span>\n</code></pre>\n<p>应该不止我一个人会认为最后结果应该是 <code>{a: 2}</code> 吧...其实上面还可以再简化成这样</p>\n<pre><code class=\"lang-javascript\">a = {a:<span class=\"number\">1</span>};\nb = a;\na = {a:<span class=\"number\">2</span>};\nconsole.log(b);        <span class=\"comment\">// {a:1}</span>\n</code></pre>\n<p>画一个图的话是这样子的。\n{% asset_img object.png object %}\n这样应该就明了了，所以由于控制器第一次取到的 response 一定是 resource 内部的结果，而 httpInjector 是在返回 response 前进行修改，因此我们无法通过 httpInjector 来达到目的。唯一能做到的方法就是让控制器接受到的结果与缓存指向同一内存，假设 $cacheFactory 缓存 http 的结果没有被序列化，那么将 resource 中的数据加入缓存，同时把这个数据返回给控制器，就实现了控制器数据和缓存数据指向一致的目的，所以最终问题还是在 $cacheFactory 把结果给序列化了再存储。\n为了验证下我们的说法，可以修改下 angular 源码下面的地方:</p>\n<pre><code class=\"lang-javascript\"><span class=\"keyword\">function</span> done(status, response, headersString, statusText) {\n    <span class=\"keyword\">if</span> (cache) {\n        <span class=\"keyword\">if</span> (isSuccess(status)) {\n        cache.put(url, [status, response, parseHeaders(headersString), statusText]);\n        } <span class=\"keyword\">else</span> {\n        <span class=\"comment\">// remove promise from the cache</span>\n        cache.remove(url);\n        }\n    }\n\n    <span class=\"keyword\">function</span> resolveHttpPromise() {\n        resolvePromise(response, status, headersString, statusText);\n    }\n\n    <span class=\"keyword\">if</span> (useApplyAsync) {\n        <span class=\"variable\">$rootScope</span>.<span class=\"variable\">$applyAsync</span>(resolveHttpPromise);\n    } <span class=\"keyword\">else</span> {\n        resolveHttpPromise();\n        <span class=\"keyword\">if</span> (!<span class=\"variable\">$rootScope</span>.$<span class=\"variable\">$phase</span>) <span class=\"variable\">$rootScope</span>.<span class=\"variable\">$apply</span>();\n    }\n}\n</code></pre>\n<p>把这一行</p>\n<pre><code class=\"lang-javascript\">cache.put(url, [status, response, parseHeaders(headersString), statusText]);\n</code></pre>\n<p>改为</p>\n<pre><code class=\"lang-javascript\">cache.put(url, [status, angular.fromJson(response), parseHeaders(headersString), statusText]);\n</code></pre>\n<p>之后就会发现，从第二次开始缓存的数据就会同步变更了，因为存的是对象，所以下次从缓存取的时候就直接用的对象，所以就可以保持数据的同步了。但第一次还是不行，我也没有再深究下去了，源码有点绕，看不太懂。\n另外，过程中曾经有想利用 <code><span class=\"variable\">$stateChangeStart</span></code> 和 <code><span class=\"variable\">$stateChangeSuccess</span></code> 着手，但是发现这两个事件没有效果，查了资料才知道，<code>ui-router</code> 的新版本(1.0)已经有较大的变化，不再支持上面的事件，而是转而通过 <code><span class=\"variable\">$transition</span></code> 来操作。如果你还在用老版本的 <code>ui-router</code>，可以试试看这个新版本的，迁移可以参考<a href=\"https://ui-router.github.io/guide/ng1/migrate-to-1_0#state-change-events\">这里</a>。</p>\n<p>花了好几个小时想尝试解决这个问题都没搞定，现在还是搞不懂为什么 angular 要把数据序列化后缓存，是为了数据的稳定吗？如果可以提供一个 option 来设置不是很好吗？不知道有没有什么解决方案，一直没找着，貌似是因为缓存的数据就不应该被修改，但在一些场景它还是有应用用途的吧。</p>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"editor":{"minHeight":600,"height":null},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"Angular2之折腾记.md","link":"/post/Angular2之折腾记.html"}}