{"posts":[{"title":"存活一个月的个人博客","date":"2016-11-21T19:38:21.000Z","categories":"杂记","tags":["杂记"],"content":"<p>今天打算备案之前的订阅器网站的域名, 捣鼓之余发现好久以前搞的万网虚拟主机还没过期=.=, 虽然里面的东西因为某次事件清空了, 不过意外发现自己备份了几次数据库. 加之当时用的是 wordpress, 于是赶紧恢复数据库并装上 wordpress. </p>\n<p>看完了全部文章, 好水, 原来我以前这么会水0.0</p>\n<p>当时不会写网站, 都是用 Typecho 啊或者 WordPress 的, 两个换来换去的, 主题也换来换去的0.0</p>\n<p>发了个牢骚</p>\n<p>{% asset_img 2015.5.1.png 2015.5.1 %}</p>\n<p>觉得文章太少了就吹吹水</p>\n<!-- more -->\n<p>Gravatar Fixed 头像修复插件</p>\n<p>{% asset_img gravatar.png gravatar %}</p>\n<p>(<em>@ο@</em>) 哇～学习了... 表示订阅器就用了 Gravatar, 但是没用 Gravatar 的  CDN 所以国内头像显示会出问题0.0. </p>\n<p>步入 php</p>\n<p>{% asset_img php.png php %}</p>\n<p>php 是世界上最好的语言(^o^)/~</p>\n<p>额..就不一篇篇列了... 后面还有 VSCode 个人使用总结... 关于 Mac 的一些感想... </p>\n<p>还有...算了...不丢人现眼了...</p>\n<p>正经一点的还有链表类代码, 糖果机代码...发现自己以前写的代码也是很工整滴</p>\n<p>2015年5月19日, 发了篇博客, 购入 DigitalOcean 配置 Shadowsocks. 开始使用 VPS 和 SS... 然后再后就是各种 VPS 上面的流水账0.0. 最后来了一个&quot; 第十二周学习计划 &quot;. 然后就停止更新了 0.0, 存活一个月0.0</p>\n<p>{% asset_img do.png do %}</p>\n<p>自从那以后干嘛去了我也忘了0.0 只知道几乎是2015年暑假的时候才开始捣鼓 PHP 之类的东西.</p>\n<p>这就是一年半前的我0.0</p>\n<p>最后, 附两个忠实宿友0.0</p>\n<p>{% asset_img keke.png keke %}</p>\n<p>想我一年半前的博客都有人留言, 现在写的都无人问津了, ╮(╯▽╰)╭</p>\n<p>其实仔细回想自己后来也用 PHP 写了两三个个人博客. 在使用 Hexo 之前, 还是自己用 Laravel 搭建的个人博客=.=. 不过上面过后的文章全都找不着了0.0, 反正也没啥价值...</p>\n<p>终于写了一篇无关技术的文章 0.0</p>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"存活一个月的个人博客.md","link":"/post/存活一个月的个人博客.html"},{"title":"聊聊 Webpack 使用","date":"2016-11-17T13:24:47.000Z","categories":"Webpack","tags":["Webpack","JavaScript","Vue"],"content":"<p>老早的时候就听说了 Webpack 这个工具, 当时大概的印象就是类似 Gulp 这样的东西, 并且看起来好像挺复杂的. 直到学习 React 的时候才开始接触 Webpack, 才知道 Webpack 更多的是做模块化的工作. 不过当时也是乱配置一通能用就行=.=.</p>\n<p>现在 Vue 标配也是用 Webpack 了. Webpack 其实并没有想象中的那么复杂, 其实最核心的还是 loader 那一块. 这次就主要聊一聊 Webpack. 我用的是 Webpack 最新版本 2.1.0-beta.27.</p>\n<p>{% asset_img what-is-webpack.png what-is-webpack %}</p>\n<h2 id=\"loader\">Loader</h2>\n<p>Loader 是 Webpack 的核心, 它会自动查找项目中的我们指定的文件类型, 然后使用我们指定的 Loader 进行处理. 例如:</p>\n<pre><code class=\"lang-javascript\">module: {\n  rules: [{\n    test:    /\\.vue$/,\n    loader:  &amp;<span class=\"comment\">#39;vue-loader&amp;#39;,</span>\n    options: {\n      loaders: {\n        css: ExtractTextPlugin.extract({\n          loader:         [&amp;<span class=\"comment\">#39;css-loader?minimize&amp;#39;, &amp;#39;postcss-loader&amp;#39;],</span>\n          fallbackLoader: &amp;<span class=\"comment\">#39;vue-style-loader&amp;#39;</span>\n        })\n      }\n    }\n  }, {\n    test:    /\\.js$/,\n    loader:  &amp;<span class=\"comment\">#39;babel-loader&amp;#39;,</span>\n    exclude: /node_modules/\n  }, {\n    test:   /\\.css$/,\n    loader: ExtractTextPlugin.extract({\n      loader: [&amp;<span class=\"comment\">#39;css-loader?minimize&amp;#39;, &amp;#39;postcss-loader&amp;#39;]</span>\n    })\n  }, {\n    test:   /\\.(eot|woff|woff2|ttf)([\\?]?.*)$/,\n    loader: &amp;<span class=\"comment\">#39;file-loader&amp;#39;</span>\n  }, {\n    test:   /\\.(png|jpg|gif|svg|ico)$/,\n    loader: &amp;<span class=\"comment\">#39;url-loader?limit=8192&amp;#39;,</span>\n  }]\n},\n</code></pre>\n<p>对于 Vue 文件, 我们要让 <code>vue-loader</code> 来处理, 这里可以先忽略 <code>ExtractTextPlugin</code> 部分, 它作用是提取 CSS 这个在后面会提. 对于 <code>.js</code> 文件, 我们使用 <code>babel-loader</code> 来处理, 我们可以在项目配置一个 <code>.babelrc</code> 文件来指定我们使用的 presets 和 plugins. </p>\n<!--more-->\n<p>Webpack 我觉得一个不太好的地方就是写法很多, 而且那么多种写法大体是一样的, 但是在一些场景下它们可能又会有区别, 就不能统一一下吗? 例如, 如果我们使用了 Sass, 那常用的两种写法如下:</p>\n<pre><code class=\"lang-javascript\"><span class=\"comment\">// 写法1</span>\n{\n    test:   /\\.scss$/,\n    loader: &amp;<span class=\"comment\">#39;css-loader!sass-loader&amp;#39;</span>\n}\n<span class=\"comment\">// 写法2</span>\n{\n    test:   /\\.scss$/,\n    loader: [\n      &amp;<span class=\"comment\">#39;css-loader&amp;#39;,</span>\n      &amp;<span class=\"comment\">#39;sass-loader&amp;#39;</span>\n    ]\n}\n</code></pre>\n<p>我们可以使用 <code>!</code> 来连接多个 loader, 它们会自右向左执行.</p>\n<p>另外, <code>-loader</code> 可以省略不写, 但在 Webpack2 中推荐写上. 如果不加 <code>-loader</code> 的话在一些场景下它会出错.</p>\n<h2 id=\"devserver\">devServer</h2>\n<p>这个是 webpack 另一个强大的地方了. Webpack-dev-server 是一个小型的 node.js Express 服务器, 通过 websocket 可以实现浏览器的模块热替换. 即前端代码变动的时候无需刷新整个页面, 而只是把变化的部分替换掉. 关于这个热替换, 其实也有好几种配置方法, 这里我只说我用的情况.</p>\n<pre><code class=\"lang-javascript\">devServer: {\n        hot:                <span class=\"keyword\">true</span>,    <span class=\"comment\">// 热替换</span>\n        historyApiFallback: <span class=\"keyword\">true</span>,    <span class=\"comment\">// HTML5 Mode</span>\n        port:               <span class=\"number\">7000</span>,    <span class=\"comment\">// 端口</span>\n        proxy:              {        <span class=\"comment\">// 代理</span>\n            &amp;<span class=\"comment\">#39;/api/*&amp;#39;: {</span>\n                target: &amp;<span class=\"comment\">#39;http://127.0.0.1:3000&amp;#39;</span>\n            },\n            &amp;<span class=\"comment\">#39;/auth/*&amp;#39;: {</span>\n                target: &amp;<span class=\"comment\">#39;http://127.0.0.1:3000&amp;#39;</span>\n            },\n            &amp;<span class=\"comment\">#39;/img/*&amp;#39;: {</span>\n                target: &amp;<span class=\"comment\">#39;http://127.0.0.1:3000&amp;#39;</span>\n            },\n            &amp;<span class=\"comment\">#39;/css/*&amp;#39;: {</span>\n                target: &amp;<span class=\"comment\">#39;http://127.0.0.1:3000&amp;#39;</span>\n            },\n            &amp;<span class=\"comment\">#39;/fonts/*&amp;#39;: {</span>\n                target: &amp;<span class=\"comment\">#39;http://127.0.0.1:3000&amp;#39;</span>\n            },\n            &amp;<span class=\"comment\">#39;/js/*&amp;#39;: {</span>\n                target: &amp;<span class=\"comment\">#39;http://127.0.0.1:3000&amp;#39;</span>\n            },\n            &amp;<span class=\"comment\">#39;/favicon/*&amp;#39;: {</span>\n                target: &amp;<span class=\"comment\">#39;http://127.0.0.1:3000&amp;#39;</span>\n            }\n        },\n    }\n}\n</code></pre>\n<p>这里的 proxy 也是 webpack-dev-server 一个强大的地方之一, 我们可以配置一些代理来避免跨域问题和端口不一致的问题.</p>\n<p>接着运行即可</p>\n<pre><code class=\"lang-bash\">webpack-dev-server --hot --open --inline --progress\n</code></pre>\n<h2 id=\"-\">减少打包体积</h2>\n<p>Webpack 在开发环境打包的体积非常大, 因为其包含了 source-map 等. 我们在生产环境并不需要它, 可以如下配置:</p>\n<pre><code class=\"lang-javascript\">{\n  devtool: isProduction() ? <span class=\"keyword\">false</span> : &amp;<span class=\"comment\">#39;#eval-source-map&amp;#39;</span>\n}\n</code></pre>\n<p>除了这点, 有时候我们还想生产环境使用 CDN, 开发环境使用本地的资源. CDN 可以通过 externals 配置</p>\n<pre><code class=\"lang-javascript\">{\n  externals = {\n    &amp;<span class=\"comment\">#39;vue&amp;#39;:          &amp;#39;Vue&amp;#39;,</span>\n    &amp;<span class=\"comment\">#39;underscore&amp;#39;:   &amp;#39;_&amp;#39;,</span>\n    &amp;<span class=\"comment\">#39;vue-resource&amp;#39;: &amp;#39;VueResource&amp;#39;,</span>\n    &amp;<span class=\"comment\">#39;vue-router&amp;#39;:   &amp;#39;VueRouter&amp;#39;,</span>\n    &amp;<span class=\"comment\">#39;vuex&amp;#39;:         &amp;#39;Vuex&amp;#39;</span>\n  }\n}\n</code></pre>\n<p>同时不要忘记了在 <code>index.html</code> 中把各文件的 CDN 链接导入. 区分两个环境我们可以建立两个配置文件, 或者简单的通过条件语句判断. 这样处理后生产环境和开发环境的 <code>index.html</code> 就有了比较大的区别, 我处理方式是建立了两个 <code>index.html</code> 一个用于开发环境一个用于生产环境, 再者他们刚好也位于不同的位置, 开发环境从根目录加载 <code>index.html</code> , 而生产环境则有后端根据 UA 指向 <code><span class=\"keyword\">public</span></code> 下的 <code>index.html</code></p>\n<p>再有的优化就是进行 JavaScript 代码的压缩混淆, 当然这个也只推荐在生产环境中使用:</p>\n<pre><code class=\"lang-javascript\">plugins.push(\n  <span class=\"comment\">// 生产环境压缩 JavaScript 代码</span>\n  <span class=\"keyword\">new</span> webpack.optimize.UglifyJsPlugin({\n    test:     /(\\.vue|\\.js)$/,\n    compress: {\n      warnings: <span class=\"keyword\">false</span>\n    },\n  })\n)\n</code></pre>\n<p>导入这个插件即可</p>\n<p>另外还有 CSS 的压缩:</p>\n<pre><code class=\"lang-javascript\">{\n    test:   /\\.css$/,\n    loader: ExtractTextPlugin.extract({\n      loader: [&amp;<span class=\"comment\">#39;css-loader?minimize&amp;#39;, &amp;#39;postcss-loader&amp;#39;]</span>\n    })\n}\n</code></pre>\n<p>只要在 <code>css-loader</code> 后面加上 <code>?minimize</code> 就好了.</p>\n<h2 id=\"-css\">提取 CSS</h2>\n<p>就上面那段代码, 用到了 <code>ExtractTextPlugin</code> 这个插件, 它就是用来分离 CSS 代码的, 我们需要安装这个插件, 然后在 Webpack 中导入. 使用方法就上面这样, 但还要做一个配置:</p>\n<pre><code class=\"lang-javascript\">plugins.push(\n  <span class=\"keyword\">new</span> ExtractTextPlugin({\n    filename:  isProduction() ? &amp;<span class=\"comment\">#39;style.[contenthash:4].css&amp;#39; : &amp;#39;style.css&amp;#39;,</span>\n    allChunks: <span class=\"keyword\">true</span>,\n  })\n)\n</code></pre>\n<p>导入这个插件, 并配置文件名. 之后他就会在我们的 output 处输出这个 CSS 文件.</p>\n<p>我这里不仅仅是要处理 CSS 文件, 还要处理 <code>.vue</code> 中的 CSS 样式.</p>\n<pre><code class=\"lang-javascript\">{\n  test:    /\\.vue$/,\n  loader:  &amp;<span class=\"comment\">#39;vue-loader&amp;#39;,</span>\n  options: {\n    loaders: {\n      css: ExtractTextPlugin.extract({\n            loader:         [&amp;<span class=\"comment\">#39;css-loader?minimize&amp;#39;, &amp;#39;postcss-loader&amp;#39;],</span>\n            fallbackLoader: &amp;<span class=\"comment\">#39;vue-style-loader&amp;#39;</span>\n          })\n    }\n  }\n}\n</code></pre>\n<p>注意 Webpack2 最新版本 API 想比 Webpack1 有较大变化. Webpack2 不支持在配置文件中插入其他东西, 如果你想对这个 loader 进行进一步配置, 需要在 options 中配置. 这里对 <code>vue-loader</code> 进行了进一步配置, 加入了 <code>postcss-loader</code> 和 <code>css-loader</code> .</p>\n<p><code>postcss-loader</code> 也是一个比较坑的地方, 在 Webpack2 最新版本已经不支持使用 <code>postcss.config.js</code> 文件的配置, 你需要自己在 Webpack 中配置这个插件.</p>\n<pre><code class=\"lang-javascript\">plugins.push(\n  <span class=\"keyword\">new</span> webpack.LoaderOptionsPlugin({\n    options: {\n      postcss: [\n        <span class=\"keyword\">require</span>(&amp;<span class=\"comment\">#39;postcss-nested&amp;#39;),</span>\n        <span class=\"keyword\">require</span>(&amp;<span class=\"comment\">#39;postcss-cssnext&amp;#39;)</span>\n      ]\n    }})\n)\n</code></pre>\n<p>插入这个插件后后面才可以正常使用 <code>postcss-loader</code></p>\n<p>我们同时处理了 <code>.css</code> 和 <code>.vue</code> 中的 css 并最终生成了一个 CSS 文件. 这里在生产环境会生成 <code>style.[contenthash:4].css</code> , <code>contenthash</code> 是根据文件内容生成的, 在文件名加入其哈希值后, 我们就可以大胆的最样式表进行长期缓存, 因为样式表内容一变化文件名也变了. </p>\n<h2 id=\"-\">文件名嵌入哈希值</h2>\n<p>除了 CSS 处理外, 我们还要对 JavaScript 进行处理, 这个是在 <code>output</code> 中配置的:</p>\n<pre><code class=\"lang-javascript\">{\n      output = {\n        path:       path.resolve(__dirname, &amp;<span class=\"comment\">#39;./public/static/&amp;#39;),</span>\n        publicPath: &amp;<span class=\"comment\">#39;/static/&amp;#39;,</span>\n        filename:   &amp;<span class=\"comment\">#39;build.[chunkhash:4].js&amp;#39;</span>\n    }\n}\n</code></pre>\n<p>注意这里用的是 <code>chunkhash</code> , 我们在 CSS 中用的则是 <code>contenthash</code></p>\n<p>最后我们就会生成如下的文件名:</p>\n<pre><code class=\"lang-javascript\">style.dd51.css\nbuild.84e5.js\n</code></pre>\n<p>但这样做是不够的, 我们不能每次都自己手动修改 <code>index.html</code> , 我们要让 <code>index.html</code> 中的文件哈希值也自动变化.</p>\n<p>这个可以通过自定义插件来做, 我是直接参考了别人写的, 并没有深入去了解</p>\n<pre><code class=\"lang-javascript\">plugins.push(\n        <span class=\"keyword\">function</span> () {\n            <span class=\"keyword\">this</span>.plugin(&amp;<span class=\"comment\">#39;done&amp;#39;, function (statsData) {</span>\n                <span class=\"keyword\">var</span> stats = statsData.toJson()\n                <span class=\"keyword\">if</span> (!stats.errors.length) {\n                    <span class=\"keyword\">var</span> html = fs.readFileSync(&amp;<span class=\"comment\">#39;./public/index.html&amp;#39;, &amp;#39;utf8&amp;#39;)</span>\n                    <span class=\"keyword\">var</span> htmlOutput = html.replace(\n                        /<span class=\"keyword\">static</span>\\/(.+?)&quot;&gt;/g,\n                        <span class=\"keyword\">function</span> (word) {\n                            let filename = word.split(&amp;<span class=\"comment\">#39;/&amp;#39;)[1].split(&amp;#39;.&amp;#39;)[0]</span>\n                            <span class=\"keyword\">for</span> (let i = <span class=\"number\">0</span>; i &lt; stats.assetsByChunkName.main.length; i++) {\n                                <span class=\"keyword\">if</span> (stats.assetsByChunkName.main[i].indexOf(filename) !== -<span class=\"number\">1</span>) {\n                                    <span class=\"keyword\">return</span> &amp;<span class=\"comment\">#39;static/&amp;#39; + stats.assetsByChunkName.main[i] + &amp;#39;&quot;&gt;&amp;#39;</span>\n                                }\n                            }\n                        })\n                    fs.writeFileSync(\n                        &amp;<span class=\"comment\">#39;./public/index.html&amp;#39;,</span>\n                        htmlOutput)\n                }\n            })\n        }\n)\n</code></pre>\n<p>这里的正则和路径都是根据自己项目的情况做出来的.</p>\n<p>大致的意思就是监听插件的 <code>done</code> 事件, 然后传入 <code>statsData</code> 到这个插件的回调函数里, 如果没有出错, 那么获取得到 webpack 生成的文件名即上面说的文件名如 <code>style.dd51.css</code>, 即 <code>stats.assetsByChunkName.main</code> 这个数组. 这个数组保存着 webpack 生成的文件名, 接着我们获取 <code>index.html</code> 并用正则获取所有的 <code>script</code> 和 <code>style</code> , 我这里的处理措施是得到文件名如 <code>style</code> , 然后在 <code>stats.assetsByChunkName</code> 中查找包含这个串的输出文件名, 将这个文件名替换原来的即可.</p>\n<p>到这一步不得不感慨 Webpack 的强大, 上面我说的有点乱, 可以在<a href=\"https://github.com/ruiming/rss/blob/881a34c206b4bc7797c649a0226e7516686ec1c5/webpack.config.js\">这里</a>(最新的配置文件已经发生了改变)查看我的详细 webpack 配置. 这里没有细说每个配置的每个选项, 这些选项有些我自己也还搞不太明白, 最近还要再好好看下里面一些选项的细微区别.</p>\n<p>总结下, 上面的 Webpack 帮我们做了这些事情:</p>\n<ul>\n<li><p>模块化</p>\n<p>一切皆模块, 只要有 loader. 我们可以在我们的 JS 文件中导入 CSS, 图片等资源. Webpack 会自动帮我们做处理. 只要你想的话, 你还可以用 CSS in JS. 如果你单独分离 CSS, 那么最终生成的就是一个 JavaScript 文件.</p>\n</li>\n<li><p>使用 Babel 和 PostCSS</p>\n<p>在 Webpack 中使用 <code>babel-loader</code> 处理 <code>.js</code> 和 <code>.vue</code> 文件, 我们就可以任性的写 ES6 和 ES7 了. 给 <code>.css</code> 和 <code>vue-loader</code> 加入 <code>post-loader</code> 后我们就可以任性的使用 cssnext 等特性了. 原本我是用 <code>sass-loader</code> 的, 但是我主要用的嵌套功能其实 <code>postcss-loader</code> 也可以处理, 并且我挺喜欢 <code>postcss-loader</code> 的丰富插件这个特性. 从此抛开 CSS 预处理器.</p>\n</li>\n<li><p>压缩合并 JS 和 CSS</p>\n<p>不需要使用 Gulp 了. Webpack 对 JS 和 CSS 的压缩合并处理不能再简单了.</p>\n</li>\n<li><p>代理服务器</p>\n<p>反向代理了我们的 API, 避免了端口修改和跨域的问题.</p>\n</li>\n<li><p>文件哈希名</p>\n<p>给 CSS 和 JS 嵌入了哈希值, 并且自动替换 <code>index.html</code> 中的路径文件.</p>\n</li>\n</ul>\n<p>恩, 不愧是前端模块化和自动化利器.</p>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"聊聊-Webpack-使用.md","link":"/post/聊聊-Webpack-使用.html"},{"title":"使用 Koa2 开发小结","date":"2016-11-15T00:00:16.000Z","categories":"Node","tags":["Koa","Node","JavaScript"],"content":"<p>RSS 订阅器项目是我最近花时间比较多的一个项目了. 在这个项目中我使用了大量的新技术, 很多技术都是我第一次使用. 后端是基于 Koa2 和 Mongoose 的 RESTful API.</p>\n<p>在这个项目开展前, 我已经有半年多没接触后端了. 上一次后端还是用 PHP 以及 Laravel 框架开发的 LNMP 架构. 在动工前, 我也没有正式的使用过 Node 以及其部署, 对于 Koa2 的 async await 的异步书写方式也只是久仰大名而已.</p>\n<p>这篇博客主要想说一说自己在使用 Node.js 和 Koa2 开发后端过程中的一些总结和收获.</p>\n<h3 id=\"-\">中间件</h3>\n<p>Koa2 本身是一个非常轻的框架, 我们需要使用大量的中间件去完善它, 例如 <code>koa-bodyparser</code> , <code>koa-etag</code>, <code>koa-router</code>, <code>koa-sslify</code> 等等.</p>\n<p>同时, 肯定免不了自己写中间件, 例如我自己就写了 7 个中间件, 分别是处理缓存, 处理 cookies, 强制 www, 配合前端 HTML5Mode, 错误处理, UA 判断, JWT 和 XSRF 处理.</p>\n<pre><code class=\"lang-javascript\">module.exports = <span class=\"keyword\">function</span> () {\n    <span class=\"keyword\">return</span> async(ctx, next) =&gt; {\n        <span class=\"keyword\">if</span> (/^\\/(mark|square|feed|feeds|post|posts|me|search)/.test(ctx.request.url)) {\n            <span class=\"keyword\">if</span> (ctx.mobile) {\n                await send(ctx, &amp;<span class=\"comment\">#39;./public/index.html&amp;#39;)</span>\n            }\n            <span class=\"keyword\">else</span> {\n                await send(ctx, &amp;<span class=\"comment\">#39;./public/pc.html&amp;#39;)</span>\n            }\n        }\n        await next()\n    }\n}\n</code></pre>\n<p>上述就是配合前端 HTML5Mode 以及根据 UA 指向不同入口文件的中间件.</p>\n<!-- more -->\n<p>Koa2 的错误处理非常友好, 可以通过以下这样一个中间件来统一处理错误, 我们可以在这里捕捉到代码运行的大部分错误, 包括异步过程中的错误, 以及自己在代码中抛出的错误, 然后在这里统一的进行处理.</p>\n<pre><code class=\"lang-javascript\">module.exports = <span class=\"keyword\">function</span> () {\n    <span class=\"keyword\">return</span> async(ctx, next) =&gt; {\n        <span class=\"keyword\">try</span> {\n            await next()\n        } <span class=\"keyword\">catch</span> (err) {\n\n        }\n    }\n}\n</code></pre>\n<p>其实中间件听起来高大上其实并没什么, 你也可以直接写到 Koa 的入口文件, 但是比较好的风格是把他们都提取出来, 然后入口文件导入这些中间件进行 use 即可.</p>\n<h3 id=\"http2\">HTTP2</h3>\n<p>Koa2 使用 HTTP2 也非常简单.</p>\n<pre><code class=\"lang-javascript\">http.createServer(app.callback()).listen(config.PORT)\n\n<span class=\"comment\">// Production Only</span>\n<span class=\"keyword\">if</span> (config.ENV === &amp;<span class=\"comment\">#39;production&amp;#39;) {</span>\n    <span class=\"keyword\">const</span> options = {\n        key:  config.APP.SSL_KEY,\n        cert: config.APP.SSL_CERT,\n        ca:   config.APP.CA\n    }\n    http2.createServer(options, app.callback()).listen(<span class=\"number\">443</span>)\n}\n</code></pre>\n<p>我们可以配置两个配置文件分别作用于生产环境和开发环境, 然后在入口文件根据不同的环境使用即可. </p>\n<p>另外也可以很方便的通过使用 <code>koa-helmet</code> 来配置 HSTS</p>\n<h3 id=\"promise\">Promise</h3>\n<p>虽然, Node 的主流版本都支持 Promise 了, 但是似乎原生的 Promise 仍然比 Bluebird 慢并且更消耗内存. 所以推荐使用 Bluebird 替代原生 Promise. 具体原因可以查看 [<a href=\"http://softwareengineering.stackexchange.com/a/279003\">Why are native ES6 promises slower and more memory-intensive than bluebird?</a></p>\n<p>可以把 mongoose 和全局的 promise 都换成 bluebird.</p>\n<p>与此同时我们还获得了更加丰富的 Promise 方法如 promisify, 不用白不用.</p>\n<pre><code class=\"lang-javascript\">mongoose.Promise = <span class=\"keyword\">require</span>(&amp;<span class=\"comment\">#39;bluebird&amp;#39;)</span>\n<span class=\"keyword\">global</span>.Promise = <span class=\"keyword\">require</span>(&amp;<span class=\"comment\">#39;bluebird&amp;#39;)</span>\n</code></pre>\n<h3 id=\"jwt\">JWT</h3>\n<p>JWT 已经在前面的博客中提到过了, 我认为 JWT 保存 cookie 并设置 httpOnly, 同时传输非 httpOnly 的 XSRF-TOKEN 这种认证方式是比较妥当的. 如果使用了 HTTPS, 还可以同时设置 secure.</p>\n<h3 id=\"npm-scripts\">NPM scripts</h3>\n<p>npm scripts 非常好用, 我们可以自定义很多命令在里面. 例如我在项目中常用的:</p>\n<pre><code class=\"lang-json\">&quot;start&quot;: &quot;pm2 start production.json&quot;,\n&quot;dev&quot;: &quot;pm2 start development.json&quot;,\n&quot;angular&quot;: &quot;pm2 start development.json&quot;,\n&quot;vue&quot;: &quot;webpack-dev-server --hot --open --inline --progress&quot;,\n&quot;angular-dist&quot;: &quot;gulp build&quot;,\n&quot;vue-dist&quot;: &quot;NODE_ENV=production webpack --progress&quot;,\n&quot;build&quot;: &quot;npm run angular-dist &amp; npm run vue-dist&quot;,\n&quot;db&quot;: &quot;mongod --dbpath=&amp;<span class=\"comment\">#39;/root/db&amp;#39; --rest&quot;,</span>\n&quot;generatessl&quot;: &quot;./certbot-auto certonly --webroot -w /root/rss -d enjoyrss.com -d www.enjoyrss.com&quot;,\n&quot;updatessl&quot;: &quot;./certbot-auto renew --quiet&quot;,\n&quot;cron&quot;: &quot;crontab ./utils/cron&quot;\n</code></pre>\n<p>在部署生成环境时运行 <code>npm run build</code> 构建最新版本, 运行 <code>npm run updatessl</code> 更新 SSL 证书, 运行<code>npm start</code> 来启动项目, 运行 <code>npm run db</code> 开启数据库.</p>\n<h3 id=\"babel\">Babel</h3>\n<p>用了 Babel 之后, 就可以随心所欲的书写 ES6 甚至 ES7 了.</p>\n<p>我用的比较多的是 <code>import</code> , <code><span class=\"keyword\">for</span>...of...</code> , <code>async</code> 以及解构赋值, 属性名表达式, 数组扩展符, 对象扩展符等等.</p>\n<p>解构赋值和属性名表达式可以大大减少代码量, 写起来特别爽.</p>\n<pre><code class=\"lang-javascript\">exports.<span class=\"keyword\">list</span> = async (ctx, next) =&gt; {\n    let {\n        order,\n        limit,\n        page,\n        per_page,\n        desc\n    } = ctx.request.query\n\n    let result = await FeedModel.find()\n        .sort({\n            [order]: desc === &amp;<span class=\"comment\">#39;true&amp;#39; ? &amp;#39;1&amp;#39; : &amp;#39;-1&amp;#39;</span>\n        })\n        .skip(+page * +per_page)\n        .limit(+per_page || +limit)\n\n    ctx.body = {\n        success: <span class=\"keyword\">true</span>,\n        data:    result\n    }\n}\n</code></pre>\n<p>数组扩展符和对象扩展符也很方便, 不用再使用 Array.concat 和 Object.assign 方法了.</p>\n<pre><code class=\"lang-javascript\"><span class=\"comment\">// 数组扩展符</span>\n<span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]\n<span class=\"keyword\">var</span> b = [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]\n<span class=\"keyword\">var</span> c = [...a, <span class=\"number\">4</span>, <span class=\"number\">5</span>]    <span class=\"comment\">// [1, 2, 3, 4, 5]</span>\n<span class=\"keyword\">var</span> d = [...a, ...b]    <span class=\"comment\">// [1, 2, 3, 4, 5, 6]</span>\n<span class=\"comment\">// 对象扩展符</span>\n<span class=\"keyword\">var</span> feed = {\n  _id:    <span class=\"number\">123456</span>,\n  title:  &amp;<span class=\"comment\">#39;kkkk&amp;#39;,</span>\n  unread: <span class=\"number\">6</span>\n}\n<span class=\"keyword\">var</span> result = {\n  ...feed,\n  feed_id: <span class=\"number\">111111</span>,\n  unread:  <span class=\"number\">10</span>\n}\n<span class=\"comment\">// result: { _id: 123456, title: &amp;#39;kkkk&amp;#39;, unread: 10, feed_id: 11111 }</span>\n</code></pre>\n<p>Async 异步函数也不是万能的, 它无法处理多个异步函数的同步处理问题. 这时候就要借助 Promise.all 了.</p>\n<pre><code class=\"lang-javascript\">await Promise.all([\n  Promise.resolve().then(async () =&gt; state = await UserPostModel.findOne({\n    user_id,\n    post_id: item\n  })),\n  Promise.resolve().then(async () =&gt; res = await PostModel.findById(item))\n])\n</code></pre>\n<h3 id=\"-\">缓存</h3>\n<p>缓存在 Web 中非常重要</p>\n<pre><code class=\"lang-javascript\">import { SHA256 } from &amp;<span class=\"comment\">#39;crypto-js&amp;#39;</span>\n\nmodule.exports = <span class=\"keyword\">function</span> () {\n    <span class=\"keyword\">return</span> async (ctx, next) =&gt; {\n        <span class=\"keyword\">if</span> (ctx.request.method === &amp;<span class=\"comment\">#39;GET&amp;#39;) {</span>\n            <span class=\"keyword\">if</span> (/js|css|favicon|image/.test(ctx.path)) {\n                ctx.cacheControl = {\n                    maxAge: <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">24</span> * <span class=\"number\">180</span>\n                }\n            }\n        }\n        await next()\n    }\n}\n</code></pre>\n<p>这个中间件给图片和文件设置了长达 180 天的缓存时间, 其实这里永久存储都 OK 了. 因为我的 JS 和 CSS 文件变化的话文件名和路径都变了, 图片是稳定不变的即使变了它的文件名也会变化. 因此我可以大胆的这样使用.</p>\n<p>大部分工作我是交给了 <code>koa-etag</code> 和 <code>koa-cache-control</code> 这两个中间件来处理了. 现在项目我除了后端做好缓存之外, 前端也是进行了 JavaScript 的内存缓存和自动更新从而减少了请求数. 这样就大大减少了服务器的压力以及提升了用户的访问速度和体验.</p>\n<h3 id=\"pm2\">PM2</h3>\n<p>PM2 是一个带有负载均衡功能的应用进程管理器. 我们可以用它来管理我们的 Node 进程, 它的用法也很简单. 使用 PM2 可以充分发挥服务器多核的特性(如果有的话), 并且实现0秒重载以及进程信息监控等. PM2 是比较通用的 Node 部署方式.</p>\n<p>{% asset_img pm2.png pm2.png %}</p>\n<h3 id=\"-\">代码共用</h3>\n<p>由于前后端都是使用 JavaScript 这门语言, 不仅包管理统一, 大量的包如 Underscore 也可以前后端共用, 最方便的是大部分的工具函数也可以前后端一起使用, 例如检测邮箱和密码格式我们在前端做检测的同时, 后端也可以直接调用过来. 例如下面这个文件就可以同时在前端 Vue, Angular 以及后端中同时使用.</p>\n<pre><code class=\"lang-javascript\">(<span class=\"keyword\">function</span> () {\n    <span class=\"keyword\">var</span> help = {\n        <span class=\"comment\">// 检测 URL 是否合法</span>\n        checkUrl(url) {\n            let re = /https?:\\/\\/(www\\.)?[-a-zA-Z0-<span class=\"number\">9</span>@:%._\\+~<span class=\"comment\">#=]{2,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9@:%_\\+.~#?&amp;//=]*)/</span>\n            <span class=\"keyword\">return</span> re.test(url)\n        },\n        <span class=\"comment\">// 检测邮箱是否合法</span>\n        validateEmail(email) {\n            let re = /\\S+@\\S+\\.\\S+/\n            <span class=\"keyword\">return</span> re.test(email)\n        },\n        <span class=\"comment\">// 检验密码是否合法</span>\n        validatePassword(password) {\n            let re = /\\w{<span class=\"number\">6</span>,<span class=\"number\">18</span>}/\n            <span class=\"keyword\">return</span> re.test(password)\n        }\n    }\n\n    <span class=\"comment\">// In angular, the module name is app.tools, and the factory name is tools.</span>\n    <span class=\"keyword\">if</span> (typeof module !== &amp;<span class=\"comment\">#39;undefined&amp;#39; &amp;&amp; module.exports) {</span>\n        module.exports = help\n    } <span class=\"keyword\">else</span> {\n        angular.module(&amp;<span class=\"comment\">#39;app.tools&amp;#39;, []).factory(&amp;#39;tools&amp;#39;, function () {</span>\n            <span class=\"keyword\">return</span> help\n        })\n    }\n}())\n</code></pre>\n<p>其实写 Node 相比起写前端要简单好多好多, 没有什么 Gulp, Webpack, 不用考虑文件体积和大小, 不用考虑模块化组件化之类的问题, 不用考虑客户端浏览器类型和浏览器版本, 不用追求各种极限速度(现在的自动雪碧图处理, 文件懒加载和前端框架的服务端渲染真的是没谁了...).</p>\n<p>在 LNMP 架构中, 我们要使用 Nginx 来帮我们处理静态文件, 配置 PHP-FPM 来处理 PHP 请求. Gzip 和 HTTPS 等等都是在 Nginx 中配置. 其实这些事情 Node 都可以做了. 但并不意味着 Node 可以取代 Nginx, Nginx 不仅是一个 Web 服务器也是一个反向代理服务器. 必要的时候我们还是要使用 Nginx 来做一个反向代理.</p>\n<p>以上.</p>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"使用-Koa2-开发小结.md","link":"/post/使用-Koa2-开发小结.html"},{"title":"使用 ESLint 规范你的代码","date":"2016-11-08T12:57:39.000Z","categories":"JavaScript","tags":["ESlint","JavaScript"],"content":"<p>在一些多人参与的项目开发中, 每个人代码习惯不同, 对于缩进, 有人习惯 TAB, 有人习惯两个空格, 有人习惯四个空格. 对于分号, 有人不加, 有人习惯加, 而习惯加分号的人又会经常漏加分号. 试想一个项目代码如果由各种群魔乱舞的风格组成, 这必然会带来一定的视觉障碍(强迫症的人看了受不了=.=), 并且显得代码质量低下.</p>\n<p>即使是个人, 偶尔也会写出一些不太规范的代码, 比如变量声明了未使用, 比如使用了 <code>==</code> 等等, 更不要说各种代码格式如操作符左右空格, <code><span class=\"keyword\">if</span> ... <span class=\"keyword\">else</span></code> 的格式, 末行换行等等. 特别是像有强迫症的我, 有时候写的过程可能会不小心遗漏或写错, 但发现的时候又会去改过来. 如果能在书写过程中检查出不规范的地方提示岂不是最好?</p>\n<p>ESLint 是一个插件化的 JavaScript 代码检查工具, 可以用于检查常见的 JavaScript 代码错误, 规范 JavaScript 代码的书写, 可以有效控制代码的质量. </p>\n<p>{% asset_img eslint.jpg eslint.jpg %}</p>\n<h2 id=\"eslint-\">ESLint 规则</h2>\n<p>ESLint 使用非常简单, 安装好 ESLint 后, 可以自定义一套规则文件或者使用开源的代码风格规范, 像 Google, Airbnb 都有开源的 JavaScript 代码书写规范. 可以直接使用它们的, 也可以自己配置.</p>\n<p>具体的用法可以参考官方文档, 其实蛮简单的.</p>\n<p><a href=\"http://eslint.cn/docs/rules/\">这里</a>列出了 ESLint 的各种规则, 可以参考下这里的说明.</p>\n<p>以下是我个人配置的规则</p>\n<!-- more -->\n<pre><code class=\"lang-javascript\">{\n    &quot;env&quot;: {\n        &quot;browser&quot;: <span class=\"keyword\">true</span>,\n        &quot;commonjs&quot;: <span class=\"keyword\">true</span>,\n        &quot;es6&quot;: <span class=\"keyword\">true</span>,\n        &quot;node&quot;: <span class=\"keyword\">true</span>\n    },\n    &quot;parser&quot;: &quot;babel-eslint&quot;,\n    &quot;<span class=\"keyword\">extends</span>&quot;: &quot;eslint:recommended&quot;,\n    &quot;plugins&quot;: [\n        &quot;babel&quot;\n    ],\n    &quot;parserOptions&quot;: {\n        &quot;sourceType&quot;: &quot;module&quot;\n    },\n    &quot;globals&quot;: {\n        &quot;angular&quot;: <span class=\"keyword\">true</span>,\n        &quot;d3&quot;: <span class=\"keyword\">true</span>,\n        &quot;ga&quot;: <span class=\"keyword\">true</span>\n    },\n    &quot;rules&quot;: {\n        <span class=\"comment\">// 4空格缩进 auto</span>\n        &quot;indent&quot;: [\n            &quot;error&quot;,\n            <span class=\"number\">4</span>\n        ],\n        <span class=\"comment\">// unix 换行风格 auto</span>\n        &quot;linebreak-style&quot;: [\n            &quot;error&quot;,\n            &quot;unix&quot;\n        ],\n        <span class=\"comment\">// 强制单引号 auto</span>\n        &quot;quotes&quot;: [\n            &quot;error&quot;,\n            &quot;single&quot;\n        ],\n        <span class=\"comment\">// 禁止分号 auto</span>\n        &quot;semi&quot;: [\n            &quot;error&quot;,\n            &quot;never&quot;\n        ],\n        <span class=\"comment\">// 变量定义或参数声明未使用</span>\n        &quot;no-cond-assign&quot;: [\n            &quot;warn&quot;\n        ],\n        <span class=\"comment\">// 强制 !== 和 ===, 和 null 或 undefined 比较例外</span>\n        &quot;eqeqeq&quot;: [\n            &quot;error&quot;,\n            &quot;allow-<span class=\"keyword\">null</span>&quot;\n        ],\n        <span class=\"comment\">// 强制大括号风格 auto</span>\n        &quot;curly&quot;: [\n            &quot;error&quot;,\n            &quot;all&quot;\n        ],\n        <span class=\"comment\">// 强制末尾换行 auto</span>\n        &quot;eol-last&quot;: [\n            &quot;error&quot;\n        ],\n        <span class=\"comment\">// 关键字空格 auto</span>\n        &quot;keyword-spacing&quot;: [\n            &quot;error&quot;,\n            {\n                &quot;before&quot;: <span class=\"keyword\">true</span>,\n                &quot;after&quot;: <span class=\"keyword\">true</span>\n            }\n        ],\n        <span class=\"comment\">// 强制单行代码块中使用空格 auto</span>\n        &quot;block-spacing&quot;: [\n            &quot;error&quot;,\n            &quot;always&quot;\n        ],\n        <span class=\"comment\">// 逗号前面不能由空格, 后面要空格 auto</span>\n        &quot;comma-spacing&quot;: [\n            &quot;error&quot;,\n            {\n                &quot;before&quot;: <span class=\"keyword\">false</span>,\n                &quot;after&quot;: <span class=\"keyword\">true</span> \n            }\n        ],\n        <span class=\"comment\">// 冒号前面不能有空格, 后面必须有空格, 键值需水平对齐 auto</span>\n        &quot;key-spacing&quot;: [\n            &quot;error&quot;,\n            {\n                &quot;beforeColon&quot;: <span class=\"keyword\">false</span>,\n                &quot;afterColon&quot;: <span class=\"keyword\">true</span>,\n                &quot;align&quot;: &quot;value&quot;\n            }\n        ],\n        <span class=\"comment\">// 参数未使用提示</span>\n        &quot;no-unused-vars&quot;: [\n            &quot;warn&quot;,\n            {\n                &quot;<span class=\"keyword\">var</span>&quot;: &quot;all&quot;,\n                &quot;all&quot;: &quot;all&quot;\n            }\n        ],\n        <span class=\"comment\">// 禁用行尾空格 auto</span>\n        &quot;no-trailing-spaces&quot;: [\n            &quot;error&quot;, \n            { \n                &quot;skipBlankLines&quot;: <span class=\"keyword\">true</span> \n            }\n        ],\n        <span class=\"comment\">// 函数左括号左边不能有空格 auto</span>\n        &quot;space-before-<span class=\"keyword\">function</span>-paren&quot;: [\n            &quot;error&quot;,\n            {\n                &quot;anonymous&quot;: &quot;always&quot;, \n                &quot;named&quot;: &quot;never&quot;\n            }\n        ],\n        <span class=\"comment\">// 操作符周围有空格 auto</span>\n        &quot;space-infix-ops&quot;: [\n            &quot;error&quot;, \n            {\n                &quot;int32Hint&quot;: <span class=\"keyword\">false</span>\n            }\n        ],\n        &quot;babel/generator-star-spacing&quot;: <span class=\"number\">1</span>,\n        &quot;babel/<span class=\"keyword\">new</span>-cap&quot;: <span class=\"number\">1</span>,\n        &quot;babel/<span class=\"keyword\">array</span>-bracket-spacing&quot;: <span class=\"number\">1</span>,\n        &quot;babel/object-shorthand&quot;: <span class=\"number\">1</span>,\n        &quot;babel/no-await-in-loop&quot;: <span class=\"number\">1</span>,\n        &quot;babel/flow-object-type&quot;: <span class=\"number\">1</span>,\n        &quot;babel/func-params-comma-dangle&quot;: <span class=\"number\">1</span>,\n        &quot;no-console&quot;: &quot;off&quot;\n    }\n}\n</code></pre>\n<p>建议 parser 换成 babel-eslint, 并加入了 <code>babel</code> 这个插件, 为的是可以解析 ES6 和 ES7 的一些语法. 这里使用的是默认的规则文件 <code>eslint:recommended</code>. 这样对代码的约束比较少, 有更多的灵活性. 默认的规则是禁止代码内出现 <code>console.log</code> 的, 需要用的可以通过 <code>&quot;no-console&quot;: &quot;off&quot;</code> 关闭.</p>\n<p>举几个例子说明下:</p>\n<ul>\n<li><p><code>qutoes</code> 我习惯在 JavaScript 的字符串中使用单引号, 这个也看个人了, 单引号比双引号容易打</p>\n</li>\n<li><p><code>semi</code> JavaScript 中分号是没必要的, 因为经常会漏加分号, 并且好像不用分号看起来更简洁好看些, 所以干脆就都不加了</p>\n</li>\n<li><p><code>no-cond-assign</code> 变量定义或参数声明后未使用, 这是不太规范的, 但我这里使用的 warn 而不是 error</p>\n</li>\n<li><p><code>eqeqeq</code> 强制 <code>!==</code> 和 <code>==</code> , 除了和 <code><span class=\"keyword\">null</span></code> 与 <code>undefined</code> 比较外, 因为 <code><span class=\"keyword\">null</span> == undefined</code>, 对于判断一个变量是否为 null 或 undefined 时 <code>==</code> 比较好用</p>\n</li>\n<li><p><code>curly</code> 强制大括号风格, 即要求控制语句不能省略大括号, 我喜欢统一的大括号, 不喜欢一会写一会不写的样子</p>\n</li>\n<li><p><code>eol-last</code> 强制末尾换行, 习惯了, 但有时候也会忘记或者空了好几行, 加这个约束一下</p>\n</li>\n<li><p><code>keyword-spacing</code> 我设置了关键字前后都要有空格, 按我设置的使用规则后, 就会有以下约束</p>\n<pre><code class=\"lang-javascript\"><span class=\"comment\">// true</span>\n<span class=\"keyword\">if</span> (foo) {\n    <span class=\"comment\">//...</span>\n} <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (bar) {\n    <span class=\"comment\">//...</span>\n} <span class=\"keyword\">else</span> {\n    <span class=\"comment\">//...</span>\n}\n<span class=\"comment\">// false</span>\n<span class=\"keyword\">if</span>(foo) {\n    <span class=\"comment\">//...</span>\n}<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(bar) {\n    <span class=\"comment\">//...</span>\n}<span class=\"keyword\">else</span>{\n    <span class=\"comment\">//...</span>\n}\n</code></pre>\n</li>\n<li><p><code>comma-spacing</code> 逗号前面不能有空格, 逗号后面要接空格</p>\n<pre><code class=\"lang-javascript\"><span class=\"comment\">// true</span>\n<span class=\"keyword\">const</span> a, b, c = <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>\n<span class=\"comment\">// false</span>\n<span class=\"keyword\">const</span> a,b,c = <span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>\n</code></pre>\n</li>\n<li><p><code>key-spacing</code> 冒号前面不能有空格, 后面必须有空格, 键值水平对齐</p>\n<pre><code class=\"lang-javascript\"><span class=\"comment\">// true</span>\n<span class=\"keyword\">const</span> obj = {\n  name: &amp;<span class=\"comment\">#39;kkk&amp;#39;,</span>\n  id:   <span class=\"number\">2014210</span>\n}\n<span class=\"comment\">// false</span>\n<span class=\"keyword\">const</span> obj = {\n  name:&amp;<span class=\"comment\">#39;kkk&amp;#39;,</span>\n  id : &amp;<span class=\"comment\">#39;uuu&amp;#39;</span>\n}\n</code></pre>\n</li>\n</ul>\n<h2 id=\"-vscode\">结合 VSCode</h2>\n<p>VSCode 内置了 ESLint 的支持</p>\n<pre><code class=\"lang-json\"><span class=\"comment\">// Controls whether eslint is enabled for JavaScript files or not.</span>\n&quot;eslint.enable&quot;: <span class=\"keyword\">true</span>,\n\n<span class=\"comment\">// A path added to NODE_PATH when resolving the eslint module.</span>\n&quot;eslint.nodePath&quot;: <span class=\"keyword\">null</span>,\n\n<span class=\"comment\">// Uses the legacy module resolving.</span>\n&quot;eslint._legacyModuleResolve&quot;: <span class=\"keyword\">false</span>,\n\n<span class=\"comment\">// The eslint options object to provide args normally passed to eslint when executed from a command line.</span>\n&quot;eslint.options&quot;: {},\n\n<span class=\"comment\">// Traces the communication between VSCode and the eslint linter service.</span>\n&quot;eslint.trace.server&quot;: &quot;off&quot;,\n\n<span class=\"comment\">// Run the linter on save (onSave) or on type (onType)</span>\n&quot;eslint.run&quot;: &quot;onType&quot;,\n\n<span class=\"comment\">// Turns auto fix on save on or off.</span>\n&quot;eslint.autoFixOnSave&quot;: <span class=\"keyword\">false</span>,\n</code></pre>\n<p>可以开启 ESLint 检查, 同时在项目目录创建配置文件即可, 之后 ESLint 会自动运行进行检查. 你还可以设置保存时自动修复, 我前面那段配置中注释写明 <code>auto</code> 的表示可以自动修复. 怎么样, 是不是很强大.</p>\n<p>不过美中不足的是 VSCode 的 ESLint 貌似还不能检查 HTML 文件中的 JavaScript 代码, 导致我的 vue 文件不能被检查到, 希望后续更新的版本可以解决这个问题吧.</p>\n<p>前段时间使用了一阵子 VIM, VIM 快捷键在熟悉了之后用起来确实方便很多, 并且 VIM 插件也非常强大, 占用内存也低. 以前用 WebStorm 写代码动不动 1G 内存以上...</p>\n<p>现在用的比较多的就是 VSCode 了, VSCode 还自带了 TypeScript 的支持, 不过目前还没有学习 TypeScript 的打算, 感觉 VSCode 就是微软为前端开发而专门准备的, 不负众望真心好用.</p>\n<p>前后端语言统一, 带来了包统一, 比如前后端都可以使用 underscore 等类库, 代码统一, 比如前后端可以共用一段输入检测代码, 工具链统一, 比如前后端都可以使用 ESLint 进行代码风格检查. 真的是非常棒的一种体验.</p>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"使用-ESLint-规范你的代码.md","link":"/post/使用-ESLint-规范你的代码.html"},{"title":"拥抱 vue 和 vuex","date":"2016-11-05T23:18:43.000Z","categories":"Vue","tags":["Vue","Vuex","JavaScript","Koa"],"content":"<p>最近一段时间写了两个玩意, 一个是基于 PEG.js 的 XML Parser, 前面有一条博客说了 PEG.js 这东西, 事后自己也模仿着写出了这个 XML 解析器, 感觉并不难, 写着玩玩而已.</p>\n<p>另外, 最近花时间特别多的另一件事就是写了一个 RSS 订阅器. 一开始写这个订阅器, 心想上一个项目代码不忍直视, 感觉自己需要写一些能拿出手的代码, 加上学校课程刚好要求做一些东西, 以及自己最近迷上了使用 RSS 订阅器这个东西(这么多理由=.=), 于是就自己动工开搞.</p>\n<p>目前订阅器已经基本完工了, RSS 订阅器的网址是 <a href=\"https://www.enjoyrss.com\">www.enjoyrss.com</a>, 项目开源在 <a href=\"https://github.com/ruiming/rss\">Github</a> 上面, 对于对 RSS 有兴趣或者想学习 Vue2, Vuex 或 Angular1 的人可能会有一些帮助. 额对了, 还有就是后端用的是 Koa2, 前后端鉴权专门在上一篇博客提了下, 想了解 Koa2 的人也可以看下.</p>\n<h2 id=\"-\">数据流动问题</h2>\n<p>其实每次做一个新的东西的时候, 我都会尽量尝试去使用各种新的技术和用法. 这样才能学到更多的东西. 在这个 RSS 订阅器中, 一开始我只是把自己认为的各种 Angular 最佳实践在项目中都运用了下, 想写出能够体现自己 Angular 水平的代码, 为此前面还写了一篇博客说一些我认为的哪些算是最佳实践. 但其实, 对 Angular 使用已经相当熟悉的我, 并没有在这一次中收获什么新的知识. 要说有, 大概就是前面那博客提到的一些 Angular 最新版本的一些新特性例如 Component 之类的吧, 然而自己并没有花时间去看.</p>\n<p>在这个项目中, 另外的一点感受就是 Angular 的跨组件通信难题. 确切的说我觉得这个项目并不适合使用 Angular 来写. 例如</p>\n<p>{% asset_img website.png website.png %}</p>\n<p>左边有一个订阅源栏, 它的未读数量要相应右侧的点击文章, 标记全部已读等事件. 它的订阅源列表也要对右侧的订阅和取消订阅事件做出相应. 为了缩减频繁的跨组件通信, 我将下方状态栏直接拆分成三条, 由各自的组件提供其状态栏覆盖原默认只有背景色的状态栏. 但跨组件通信仍然存在, 单单左侧面板就存在着五个事件监听.</p>\n<pre><code class=\"lang-javascript\"><span class=\"variable\">$scope</span>.<span class=\"variable\">$on</span>(&amp;<span class=\"comment\">#39;EXPAND&amp;#39;, () =&gt; vm.expand = !vm.expand)</span>\n<span class=\"variable\">$scope</span>.<span class=\"variable\">$on</span>(&amp;<span class=\"comment\">#39;FOLD&amp;#39;, () =&gt; vm.expand = false)</span>\n<span class=\"variable\">$scope</span>.<span class=\"variable\">$on</span>(&amp;<span class=\"comment\">#39;ADD_FEED&amp;#39;, (event, data) =&gt; {</span>\n  <span class=\"keyword\">if</span> (vm.feeds.<span class=\"keyword\">default</span>) {\n    vm.feeds.<span class=\"keyword\">default</span>.push(data)\n  } <span class=\"keyword\">else</span> {\n    vm.feeds[&amp;<span class=\"comment\">#39;default&amp;#39;] = [data]</span>\n  }\n})\n<span class=\"variable\">$scope</span>.<span class=\"variable\">$on</span>(&amp;<span class=\"comment\">#39;DELETE_FEED&amp;#39;, (event, data) =&gt; {</span>\n  vm.feeds = _.mapObject(vm.feeds, feeds =&gt; feeds = _.filter(feeds, feed =&gt; feed.feed_id !== data.feed_id))\n})\n<span class=\"variable\">$scope</span>.<span class=\"variable\">$on</span>(&amp;<span class=\"comment\">#39;READ_POST&amp;#39;, (event, data) =&gt; {</span>\n  vm.feeds = _.mapObject(vm.feeds, feeds =&gt; _.each(feeds, feed =&gt; feed.feed_id === data ? feed.unread-- : &amp;<span class=\"comment\">#39;&amp;#39;))</span>\n})\n</code></pre>\n<p>我需要监听折叠事件, 这个动作在其他组件被触发. 需要监听添加订阅源和取消订阅源事件, 并修改订阅源列表. 需要监听已读事件, 并对相应订阅源的未读文章数做减1操作...</p>\n<p>在有些应用场景, 存在着需要大量父子组件通信, 兄弟组件通信, 以及没有父子和兄弟关系的组件之间的通信的行为, 这种时候, Angular 虽然也能解决, 但是不得不说 Angular 这种频繁的跨组件通信很容易产生问题, 特别是当一个组件可以被多个组件修改的时候.</p>\n<p>Angular 是双向数据绑定, 现在也有一种叫单向数据流的思想很火.</p>\n<p>{% asset_img flow.png flow.png %}</p>\n<p>当多个视图依赖同一份状态, 一个状态可能受到多个视图的动作改变的时候, 数据流动就会开始变得混乱起来, 而在这个单向数据流里面, <code>state</code> 是我们的数据, <code>view</code> 是我们的视图, <code>actions</code> 是触发数据更改的可能方式. 试想, 如果我们把整个应用的数据都提取出来存放在一棵树里面, 组件的数据从该树获得, 而这个组件想要修改数据时, 就得通过另外一个东西即 <code>actions</code> 来触发 <code>state</code> 的更改, 而 <code>state</code> 的更改又自动同步的影响组件的数据. 这样的话, 上面我们说的那些问题会变得非常容易解决起来, 如果你还理解不了的话, 可以看下我后面怎么说的.</p>\n<h2 id=\"angular-\">Angular 的应用场景</h2>\n<p>既然有 Angular 做不太来的事, 那么 Angular 到底适合用来做什么, 不适合做什么呢? 关于这点, 由于我没有接触真正的项目开发, 我只能谈谈自己的一些个人看法</p>\n<h3 id=\"angular-\">Angular 的适用场景</h3>\n<p>首先, 结论是 Angular 最适合用来做 CRUD 类型的针对桌面浏览器端的单页面应用(SPA)</p>\n<h4 id=\"crud\">CRUD</h4>\n<p>CRUD 即 Create, Read, Update, Delete. CRUD 类型, 即应用涉及的数据查询更改较为频繁的应用. 得益于双向绑定机制, 我们不需要做任何处理就可以实现 View 和 ViewModel 的同步, 我们只要在 View 层使用 <code>ngModel</code> 绑定变量, 就可以在控制器里直接使用它而无需担心它的值是否是我们需要的最新的值. 在 CRUD 应用中我们使用 Angular 这一类 MVVM 框架开发就会非常舒畅. 如果你不能感受到, 那么你可以试试用 React 去写一个表单的管理, 你需要监听每个 input 上面的 onChange 事件, 然后通过 setState 来修改, 并最终在该组件中更新修改. 相比起来, <code>ngModel</code> 简单得不能再简单了. 另外, 我们可以直接在 HTML 中使用诸如 <code>ng-show</code>, <code>ng-repeat</code> 等一类指令, 简单粗暴. 数据的变化和显示都变得非常简单.</p>\n<h4 id=\"-\">桌面浏览器端</h4>\n<p>之所以要特别提着一点, 是因为 Angular 体积不小. 这个 RSS 订阅器我桌面浏览器端用 Angular1 开发, 移动端用 Vue2 开发, 都做了打包压缩操作, 开启了 Gzip, 最后情况是 Angular 需要加载的 JS 以及各种辅助类库加起来在 250KB 左右. </p>\n<p>{% asset_img Angular.png Angular.png %}</p>\n<p>而 Vue 只要 100KB 左右(图中的 build.js 文件合并了CSS文件), 不到 Angular 一半的大小.</p>\n<p>{% asset_img vue.png vue.png %}</p>\n<p>当然, Angular 体积大是有原因的, 它本身就是一套大而全的框架, 拿体积和 Vue 说事是不太合适的. Vue 非常轻, 专注于 View 这一层, 而 Angular 自带了路由, 内置了 HTTP 的处理模块, 内置了 promise, 还集成了一个简化版的 jq... 如果你刚好 Angular 这些东西你都要用到, 那么 Angular 也是一个不错的选择了, 但如果你只是用到它的一部分或一点点功能并且你追求文件大小, 那么你可能要考虑一下.</p>\n<h4 id=\"spa\">SPA</h4>\n<p>这点没什么好说的, Angular 就是为这个而生的. Angular1 目前在全球中还是有很多的市场, 并且由于 Angular1 已经相当成熟稳定, 社区支持活跃, 而且是 Google 在维护, 估计未来几年仍然会由较大规模的应用, 目前国内有饿了么移动端, 微信网页版以及七牛, Coding 等在使用,</p>\n<p>感觉说了一通废话, 还是看看 Google 怎么说的吧.</p>\n<p>Google 在 AngularJS 下批注的是 &quot;HTML enhanced for web apps!&quot;</p>\n<p>{% asset_img AngularJS.png AngularJS.png %}</p>\n<p>下方有说明 Why AngularJS?</p>\n<blockquote>\n<p>HTML is great for declaring static documents, but it falters when we try to use it for declaring dynamic views in web-applications. AngularJS lets you extend HTML vocabulary for your application. The resulting environment is extraordinarily expressive, readable, and quick to develop.</p>\n</blockquote>\n<p>其实感觉还不如我说的明白 =.=</p>\n<h3 id=\"angular-\">Angular 的不适用场景</h3>\n<p>个人认为, Angular 在下面几点场景中不合适</p>\n<ul>\n<li><p>移动端</p>\n<p>其实 Angular 开发起移动端的 Webapp 很合适, 就是 Angular 的体积不太合适... 过去的可能要考虑迁移的成本以及必要性, 新的可能需要考虑下更合适的选项比如 Vue. 感觉在未来的移动端 Webapp 上面, Angular 的市场会逐渐降低</p>\n</li>\n<li><p>跨组件通信频繁</p>\n<p>当你写的 Angular 应用中涉及较多的跨组件通信的时候, 你就应该考虑这个用 Angular 是不是真的合适了. 当然其实这个事情应该在最开始的时候就该考虑清楚了. 跨组件通信的问题在 Flux 中并不存在, Flux 能够轻松应对这种问题</p>\n</li>\n</ul>\n<h3 id=\"-vue-js\">谈谈 Vue.js</h3>\n<p>订阅器移动端我用 Vue.js 来做. 接触了 Angular, 学起 Vue 也特别轻松, 三两下就搞定了 Vue 和 Vue-resource. Vue 和 Angular 的相似度比我想象的还要高, 像 vue-resource 这个和 ngresource 用起来没啥区别.</p>\n<pre><code class=\"lang-javascript\"><span class=\"comment\">// ng-resource</span>\n(<span class=\"keyword\">function</span> () {\n    angular\n        .module(&amp;<span class=\"comment\">#39;app&amp;#39;)</span>\n        .factory(&amp;<span class=\"comment\">#39;User&amp;#39;, $resource =&gt; {</span>\n            <span class=\"keyword\">return</span> <span class=\"variable\">$resource</span>(&amp;<span class=\"comment\">#39;/api/user&amp;#39;, {}, {</span>\n                update: {\n                    method: &amp;<span class=\"comment\">#39;PUT&amp;#39;</span>\n                },\n                logout: {\n                    method: &amp;<span class=\"comment\">#39;POST&amp;#39;,</span>\n                    url:    &amp;<span class=\"comment\">#39;/auth/logout&amp;#39;</span>\n                }\n            })\n        })\n}())\n\n\n<span class=\"comment\">// vue-resource</span>\n<span class=\"keyword\">const</span> User = Vue.resource(&amp;<span class=\"comment\">#39;/api/user&amp;#39;, {}, {</span>\n    update: {\n        method: &amp;<span class=\"comment\">#39;PUT&amp;#39;</span>\n    },\n    logout: {\n        method: &amp;<span class=\"comment\">#39;POST&amp;#39;,</span>\n        url:    &amp;<span class=\"comment\">#39;/auth/logout&amp;#39;</span>\n    }\n})\n\nexport User\n</code></pre>\n<p>(⊙o⊙)… 我直接复制粘贴过去都 OK 了...</p>\n<p>另外, 像 <code>v-show</code> 和 <code>ng-show</code> ,<code>v-<span class=\"keyword\">for</span></code> 和 <code>ng-<span class=\"keyword\">for</span></code> 之类的就更不用多说了.</p>\n<p>但是, 不得不说一点, Vue 做的更好.</p>\n<p>例如, Vue 可以把 <code>v-<span class=\"keyword\">for</span></code> 提出来</p>\n<pre><code class=\"lang-js\">&lt;ul&gt;\n  &lt;template v-<span class=\"keyword\">for</span>=&quot;item in items&quot;&gt;\n    &lt;li&gt;{{ item.msg }}&lt;/li&gt;\n    &lt;li <span class=\"keyword\">class</span>=&quot;divider&quot;&gt;&lt;/li&gt;\n  &lt;/template&gt;\n&lt;/ul&gt;\n</code></pre>\n<p>例如, Vue 可以使用 <code>v-<span class=\"keyword\">else</span></code> </p>\n<pre><code class=\"lang-js\">&lt;div v-<span class=\"keyword\">if</span>=&quot;Math.random() &gt; <span class=\"number\">0.5</span>&quot;&gt;\n  Sorry\n&lt;/div&gt;\n&lt;div v-<span class=\"keyword\">else</span>&gt;\n  Not sorry\n&lt;/div&gt;\n</code></pre>\n<p>虽然 Angular 也可以做这些事, 但是我说了, Vue 做的更好.</p>\n<p>当然了, Vue 不完全是在 Angular 上面重造轮子, Vue2 引入了虚拟 DOM, 又轻又快, 虽然 Vue 可以像 Angular 一样写 MVVM 应用. 但我个人更喜欢 Vuex 即 Flux 的写法, 这个后面我会说.</p>\n<p>在使用 Vue 的过程中, 有几点感受特别深.</p>\n<p>例如, 在 Vue 中, 当我在 <code>/post/123</code> 中跳到 <code>/post/456</code> 时, 我发现虽然路径变化了, 但是页面根本没重新渲染. 这对于从 Angular 过来或者说第一次接触 Vue 的人来说应该感觉一脸懵逼.</p>\n<p>当然, 很快就查找到了答案, Vue 要求我们手动去更新数据. 至于为什么这么做, 是因为 Vue 可以在我们获取新数据后在原 DOM 上面做最小的修改, 这种修改的成本自然会比整个页面的销毁和重绘要节能和迅速的多. Vue 配合虚拟 DOM 技术可以比对找出最小的修改, 使得 DOM 的修改成本降到最低, 这大概就是 React 和 Vue 在视图上面更新之高效的秘诀了.</p>\n<p>不过可能有人会问了, 这样不会很麻烦吗, 要手动监听路由变化然后重新获取数据. 感觉也还好其实, 例如下面这个例子, 这个例子在后面会进行分析.</p>\n<pre><code class=\"lang-js\">export <span class=\"keyword\">default</span> {\n    computed: mapGetters({\n        post: &amp;<span class=\"comment\">#39;post&amp;#39;</span>\n    }),\n\n    async beforeRouteEnter (to, from, next) {\n        await store.dispatch(&amp;<span class=\"comment\">#39;getPost&amp;#39;, to.params.id)</span>\n        await store.dispatch(&amp;<span class=\"comment\">#39;read&amp;#39;)</span>\n        next()\n    },\n\n    watch: {\n        async &amp;<span class=\"comment\">#39;$route&amp;#39; (to, from) {</span>\n            await store.dispatch(&amp;<span class=\"comment\">#39;getPost&amp;#39;, to.params.id)</span>\n            await store.dispatch(&amp;<span class=\"comment\">#39;read&amp;#39;)</span>\n        }\n    },\n\n    components: {\n        headbar, postOption\n    }\n}\n</code></pre>\n<p>可以看到 watch 的部分和 beforeRoute 的部分重复了, Vue 给的说法好像是封装为一个函数来执行, 我感觉还好, 就这样子算了...</p>\n<p>上面都是 Vuex 的写法, 其实最开始我还是按 MVVM 那一套写法写的, 写完了之后才开始改到 Vuex 上面去.</p>\n<p>另外, Vue 的动画和过渡效果虽然和 Angular 也是很像, 但比 Angular 强大很多. 再者 Vue 支持服务端渲染, 服务端渲染好不好用我不知道, 但确实解决了一些问题.</p>\n<p>另外, 还有很多很不错的一些技巧啊, 比如 slot 这个超实用感觉. 不过我只是简单的用了下而已.</p>\n<p>例如我定义了这样一个组件</p>\n<pre><code>&lt;template&gt;\n    &lt;div id=&quot;head&quot; v-bind:<span class=\"keyword\">class</span>=&quot;{expand2: expand}&quot;&gt;\n    &lt;header&gt;\n        &lt;span <span class=\"keyword\">class</span>=&quot;icon-paragraph-left&quot; v-on:click=&quot;move()&quot; &gt;&lt;/span&gt;\n        &lt;h2&gt;&lt;slot&gt;主页&lt;/slot&gt;&lt;/h2&gt;\n    &lt;/header&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport { mapGetters, mapActions } from &amp;<span class=\"comment\">#39;vuex&amp;#39;</span>\nexport <span class=\"keyword\">default</span> {\n    computed: mapGetters({\n        expand: &amp;<span class=\"comment\">#39;expand&amp;#39;,</span>\n        user: &amp;<span class=\"comment\">#39;user&amp;#39;</span>\n    }),\n\n    methods: {\n        move: <span class=\"keyword\">function</span>() {\n            <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.expand) {\n                <span class=\"keyword\">this</span>.<span class=\"variable\">$store</span>.commit(&amp;<span class=\"comment\">#39;COLLAPSE&amp;#39;)</span>\n            } <span class=\"keyword\">else</span> {\n                <span class=\"keyword\">this</span>.<span class=\"variable\">$store</span>.commit(&amp;<span class=\"comment\">#39;EXPAND&amp;#39;)</span>\n            }\n        }\n    }\n}\n&lt;/script&gt;\n\n&lt;style lang=&quot;sass&quot;&gt;\n\n&lt;/style&gt;\n</code></pre><p>这里省去 CSS 样式, 反正放出来也没用, 做好这样一个组件之后, 下面这样用的结果</p>\n<pre><code class=\"lang-html\">&lt;!-- src --&gt;\n&lt;headbar&gt;文章&lt;/headbar&gt;\n&lt;!-- dist --&gt;\n&lt;header&gt;\n  &lt;span <span class=\"keyword\">class</span>=&quot;icon-paragraph-left&quot;&gt;&lt;/span&gt;\n  &lt;h2&gt;文章&lt;/h2&gt;\n&lt;/header&gt;\n</code></pre>\n<p>如果 <code>headbar</code> 里面不加任何东西, 那就会使用默认的值主页. slot 可以使用多个, 可以编号. 具体的用法可以查看官方文档, 貌似 Angular 也有类似的东西, 没了解过...</p>\n<p>上面的例子中你可能注意到了, 我把 CSS, HTML, JavaScript 都写到了一起去了, 这就是 Vue 的 vue 单文件写法. 比起 Angular 里面我要建立一个文件夹, 文件夹里面放模板, 控制器, 样式表的做法, 我更喜欢 Vue 的做法, 特别好用, 当然了 vue 文件的编译依赖于 webpack. 我们还可以在 vue 文件中使用 pug 来书写 html, 使用 ts 来书写 vue, 使用 sass 来书写 css, 好用到爆.</p>\n<p>估计再也回不去 Angular 了...</p>\n<h3 id=\"-vuex\">谈谈 Vuex</h3>\n<p>我要单独把 Vuex 拿出来说一说, 因为它真的太好用了.</p>\n<p>首先, 什么是 Vuex?</p>\n<blockquote>\n<p>Vuex 是一个专门为 Vue.js 应用设计的 <strong>状态管理模型 + 库</strong>。它为应用内的所有组件提供集中式存储服务，其中的规则确保状态只能按预期方式变更。它可以与 Vue 官方<a href=\"https://github.com/vuejs/vue-devtools\">开发工具扩展(devtools extension)</a> 集成，提供高级特征，比如 零配置时空旅行般（基于时间轴）调试，以及状态快照 导出/导入。</p>\n</blockquote>\n<p>可以看看<a href=\"https://vuex.vuejs.org/en/intro.html\">官方文档</a>的说明</p>\n<p>Vuex 和 Flux 类似, 大概可以用下面这个图来表示</p>\n<p>{% asset_img vuex.png vuex.png %}</p>\n<p>一次完整的 vuex 数据流动大概如下:</p>\n<ul>\n<li><p>vue 组件通过 dispatch 一个 actions 或者直接 commit 一次 mutations 来间接修改 state. </p>\n<p>通常我们在进入一个页面的时候, 需要获取一些请求资源, 我们可以通过 beforeRouteEnter 钩子在路由进入前获取数据, 例如(省去了部分代码):</p>\n<pre><code class=\"lang-javascript\"><span class=\"comment\">// post.vue</span>\nasync beforeRouteEnter (to, from, next) {\n  await store.dispatch(&amp;<span class=\"comment\">#39;getPost&amp;#39;, to.params.id)</span>\n  await store.dispatch(&amp;<span class=\"comment\">#39;read&amp;#39;)</span>\n  next()\n}\n</code></pre>\n<p>在路由进入前, 触发了一个 <code>getPost</code> 事件.</p>\n</li>\n<li><p>actions 处理数据逻辑</p>\n<p>专门定义一个文件负责处理 actions, 在 Vue 中, actions 是用来处理异步的, 例如这个 getPost 事件:</p>\n<pre><code class=\"lang-javascript\"><span class=\"comment\">// actions.js</span>\nexport <span class=\"keyword\">const</span> getPost = ({ commit }, id) =&gt; {\n    <span class=\"keyword\">return</span> Post.get({\n        id\n    }).then(res =&gt; {\n        commit(types.RECEIVE_POST, res.data.data)\n    })\n}\n</code></pre>\n<p>获取到数据后, commit 一次修改, 这里使用了常量名, 其实对应的就是 <code>RECEIVE_POST</code> 这个字符串, 我们新建一个类型文件专门处理 mutations 的常量名和字符串的映射. 这主要是为了书写方便和重构方便吧我猜, 其实在 Redux 我们也是类似的处理.</p>\n<pre><code class=\"lang-javascript\"><span class=\"comment\">// mutation-types.js</span>\nexport <span class=\"keyword\">const</span> RECEIVE_POST = &amp;<span class=\"comment\">#39;RECEIVE_POST&amp;#39;</span>\n</code></pre>\n</li>\n<li><p>module 接收 mutation 并处理</p>\n<p>module 是为了更合理的划分 store, 这点和 redux 一样. 其用法和 redux 也是很相像的</p>\n<pre><code class=\"lang-js\"><span class=\"comment\">// post.js</span>\nimport * <span class=\"keyword\">as</span> types from &amp;<span class=\"comment\">#39;../mutation-types&amp;#39;</span>\n\n<span class=\"keyword\">const</span> state = {\n    post: {}\n}\n\n<span class=\"keyword\">const</span> mutations = {\n    <span class=\"comment\">// 获取文章信息</span>\n    [types.RECEIVE_POST](state, post) {\n        state.post = post\n    }\n}\n\nexport <span class=\"keyword\">default</span> {\n    state,\n    mutations\n}\n</code></pre>\n<p>自此, 我们就完成了一次更新 state 操作.</p>\n</li>\n<li><p>通过 getters 获取数据</p>\n<p>那数据更新是更新了, 怎么用呢, 这时候就要依靠 getters 了.</p>\n<pre><code class=\"lang-js\"><span class=\"comment\">// getters.js</span>\nexport <span class=\"keyword\">const</span> post = state =&gt; state.post.post\n</code></pre>\n<p>就一句话就可以了, 但这只是简单的获取数据而已, 你也可以在里面对数据进行一些处理, 比如过滤, 排序之类的, 但要注意, 不能修改原 state 上面的数据. 这点和 redux 又是一致的.</p>\n</li>\n</ul>\n<p>最后完整的一个组件的 JS 部分就是这样:</p>\n<pre><code class=\"lang-js\">import { Post } from &amp;<span class=\"comment\">#39;../resource/resource.js&amp;#39;</span>\nimport headbar from &amp;<span class=\"comment\">#39;../components/headbar.vue&amp;#39;</span>\nimport postOption from &amp;<span class=\"comment\">#39;../components/post-option.vue&amp;#39;</span>\nimport store from &amp;<span class=\"comment\">#39;../store&amp;#39;</span>\nimport { mapGetters, mapActions } from &amp;<span class=\"comment\">#39;vuex&amp;#39;</span>\nexport <span class=\"keyword\">default</span> {\n    computed: mapGetters({\n        post: &amp;<span class=\"comment\">#39;post&amp;#39;</span>\n    }),\n\n    async beforeRouteEnter (to, from, next) {\n        await store.dispatch(&amp;<span class=\"comment\">#39;getPost&amp;#39;, to.params.id)</span>\n        await store.dispatch(&amp;<span class=\"comment\">#39;read&amp;#39;)</span>\n        next()\n    },\n\n    watch: {\n        async &amp;<span class=\"comment\">#39;$route&amp;#39; (to, from) {</span>\n            await store.dispatch(&amp;<span class=\"comment\">#39;getPost&amp;#39;, to.params.id)</span>\n            await store.dispatch(&amp;<span class=\"comment\">#39;read&amp;#39;)</span>\n        }\n    },\n\n    components: {\n        headbar, postOption\n    }\n}\n</code></pre>\n<p>通过 mapGetters 和 mapActions 我们可以很方便的绑定 acitons 和 getters.</p>\n<p>上面还有个地方没说的就是 read 这个事件, 它还有一个和 getPost 事件很大区别的地方, 在于它会触发多个 state 的修改.</p>\n<p>结合 vuex, 我已经轻松的实现了最近未读文章, 订阅源列表, 收藏文章, 广场热门订阅源的缓存自动更新从而实现了这四个页面只要一次请求. 可以访问<a href=\"https://www.enjoyrss.png\">网站</a>体验下.</p>\n<p>{% asset_img enjoyrss.png enjoyrss.png %}</p>\n<p>就未读而言, 首屏这里就由未读信息的显示了, 当我们进入一篇文章时, 触发了 read 这个 actions, 这个 action 只是做一个异步的 http 请求操作, 然后触发一个 mutation. 关键的地方是我们需要在 posts.js 这个文件中也监听这个 mutation , 然后对其 state 进行操作. 注意这里说的是 posts.js 而不是 post.js.</p>\n<p>再换个例子, 取消订阅, 当用户在一个订阅源处点击取消订阅时, 由 action 发出的 mutation, 我们需要最近未读那里移除这个订阅源, 需要订阅源列表也移除这个订阅源, 需要广场那里热门订阅源的这个订阅源的订阅人数减一. 并且要注意的是, 这些对象是分开的. 在 vuex 中, 我们只要注意 payload 即 muitations 的传递数据以及在对应需要修改的 module 中监听 mutation 就好了. 这是非常自然的事情. 换做 Angular, 各种 on 和 emit 以及 broadcast 的能忍? 并且 vuex 提供了状态管理, 但是 angular 没有, 我们要自己缓存数据, 然后要去修改缓存, 这些在 angular 里面写起来特别不优雅.</p>\n<p>本来还想对比以下 vuex 和 redux, 但由于篇幅有限, 加之我经验还不足, 且 redux 已经忘得差不多且没有重拾欲望, 想要了解下 redux 可以看看我这篇<a href=\"https://ruiming.github.io/2016/08/01/%E8%B0%88%E8%B0%88React%E5%92%8CRedux/\">博客</a>. vuex 也是 flux 的实现, 而且也是和 redux 一样采用单一的一棵状态管理, 因此两者自然由很多相似之处.</p>\n<h3 id=\"-\">最后</h3>\n<p>昨晚班游轰趴, 才睡了三个多钟, 中午补了四个小时觉, 写了这么多我感觉已经快撑不下去了, 其实我个人一直都认为要多做少说, 我不喜欢和人争论技术, 因为我觉得自己很菜很容易说错话, 虽然意识到错误了我可以去学习这是一种提升, 但那也只是在对方意识到你错的时候, 不然就很容易误导别人了, 博客也一样, 我写博客更多就是为了记录一下, 可能也存在很多错误的地方.</p>\n<p>用了 Vue 之后, 感觉再也不会去用 Angular 了, 至于 Angular2, 额, 还是再看吧 =.=</p>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"拥抱-vue 和 vuex.md","link":"/post/拥抱-vue 和 vuex.html"},{"title":"关于前后端分离鉴权的思考","date":"2016-10-14T19:29:05.000Z","categories":"安全","tags":["JWT","JavaScript","Koa","Angular"],"content":"<p>前后端分离项目的 Token 存储问题由来已久，有的人存 Cookie 有的人存 LocalStorage 或 SessionStorage，最近刚把 RSS 订阅器项目的鉴权问题做好，感觉算是目前比较稳妥安全的方案了，分享一下经验。</p>\n<p>前端用的是 Angular，后端用的是 Koa，登录注册界面由 Koa 负责，由 Koa 根据用户是否登录来决定首页跳转。我不会一开始就讲我的做法，而是循序渐进的从传统的存储方式逐渐过渡到我的做法当中来。</p>\n<h2 id=\"-token\">如何安全的传输用户 token</h2>\n<p>这是最传统也是最简单的方式了，前端登录，后端根据用户信息生成一个 token，并保存这个 token 和对应的用户 id，接着把 token 传给用户，存入浏览器 cookie，之后浏览器请求带上这个 cookie，后端根据这个 cookie 来标识用户。</p>\n<p>{% asset_img flow-cookie-session.jpg flow-cookie-session %}</p>\n<p>但这样做问题就很多，如果我们的页面出现了 XSS 漏洞，由于 cookie 可以被 JavaScript 读取，XSS 漏洞会导致用户 token 泄露，而作为后端识别用户的标识，cookie 的泄露意味着用户信息不再安全。</p>\n<p>尽管我们通过转义输出内容，使用 CDN 等可以尽量避免 XSS 注入，但谁也不能保证在大型的项目中不会出现这个问题。另外，后端每次都需要根据 token 查出用户 id，这就增加了数据库的查询和存储开销。</p>\n<p>在设置 cookie 的时候，其实你还可以设置 httpOnly 以及 secure 项。设置 httpOnly 后 cookie 将不能被 JS 读取，浏览器会自动的把它加在请求的 header 当中，设置 secure 的话，cookie 就只允许通过 HTTPS 传输。</p>\n<p>secure 选项可以过滤掉一些使用 HTTP 协议的 XSS 注入，但并不能完全阻止。</p>\n<p>httpOnly 选项使得 JS 不能读取到 cookie，那么 XSS 注入的问题也基本不用担心了。但设置 httpOnly 就带来了另一个问题，就是很容易的被 XSRF，即跨站请求伪造。当你浏览器开着这个页面的时候，另一个页面可以很容易的跨站请求这个页面的内容。因为 cookie 默认被发了出去。</p>\n<p>{% asset_img CSRF.jpg CSRF %}</p>\n<p>看起来我们不能兼顾。确实，光依靠这一个 token 我们没办法兼顾这两点。既然一个不够，那就两个。于是有了 XSRF-TOKEN，它和作为用户令牌的 token 类似，也是服务器生成的一个散列值。我们把 token 通过 httpOnly 发回去，把 XSRF-TOKEN 直接发回去。我们可以无视 httpOnly 的 cookie 因为我们没法操纵它，但对于这个 XSRF-TOKEN，我们就可以在我们网站的每个请求中都加入到 header 里面去。而服务端就需要检查这个 header 的 XSRF-TOKEN 是否真实有效。</p>\n<!-- more -->\n<p>由于 XSRF-TOKEN 以非 httpOnly 的形式存储在 cookie 中，正常情况下只有我们自己的网站可以获取到该 XSRF-TOKEN。这样 XSRF 攻击就变得不太可能了。另外由于用户 token 是通过 httpOnly 形式存储，JS 不可获取，这样也保证了用户 token 的安全。XSS 注入最多只能获取到 XSRF-TOKEN。</p>\n<p>但还是有一种可能，XSS 注入取得 XSRF-TOKEN 后在当前页面发送请求出去。本文并不打算讨论 XSRF 和 XSS，明白这两个真正危害的地方就可以知道，这种 XSS 注入取得 XSRF-TOKEN 后发送请求其实并没有带来什么危害。不过呢，还是要看具体情况吧，如果我们的网站有一个投票 XXX 的接口，这个接口的链接被用在 XSS 注入中，那么当所有人打开这个页面的时候，都会自动的朝 XXX 投了一票。</p>\n<p>不同于 XSRF， XSRF 可以从其他网站执行该段脚本，而这里只能注入到我们的网站中来执行。因为我们的 JS 也是这样子做的，取出 XSRF-TOKEN 放入请求头部然后发送请求出去，所以这就无法避免了。事实上，由于我们的前端代码都是公开的，无论 JS 层面绕多少个弯，XSS 注入还是可以照着做过来。但好在这种方式其实造成的影响相当有限，并不会比我们常说的 XSS 注入和 XSRF 攻击的危害大，要知道 XSS 注入危害的 cookie 的泄露，但其实这里并没有 cookie 的泄露。</p>\n<p>我们再讨论另一个问题，前面也说了，服务器要经常去查询这个 token 对应的是哪一个用户。其实可不可以不要服务器去查询呢？如果我们生成 token 遵循一定的规律，比如我们使用对称加密算法来加密用户 id 形成 token，那么服务端以后其实只要解密该 token 就可以知道用户的 id 是什么了。不过呢，我只是举个例子而已，要是真这么做，只要你的对称加密算法泄露了，所有用户信息都不再安全了。恩，那用非对称加密算法来做呢，由公钥加密生成 token，私钥来解密 token，这样做就安全多了。其实现在有个规范就是这样做的，就是我们接下来要介绍的 JWT。</p>\n<h2 id=\"json-web-token\">Json Web Token</h2>\n<p>接下来我们就简单介绍 JWT 这个东西，全称叫 Json Web Token。</p>\n<h3 id=\"jwt-\">JWT 简介</h3>\n<p>JWT 是一个开放标准(<a href=\"https://tools.ietf.org/html/rfc7519\">RFC 7519</a>)，它定义了一种用于简洁，自包含的用于通信双方之间以 JSON 对象的形式安全传递信息的方法。JWT 可以使用 HMAC 算法或者是 RSA 的公钥密钥对进行签名。它具备两个特点：</p>\n<ul>\n<li><p>简洁(Compact) </p>\n<p>可以通过URL, POST 参数或者在 HTTP header 发送，因为数据量小，传输速度快</p>\n</li>\n<li><p>自包含(Self-contained)</p>\n<p>负载中包含了所有用户所需要的信息，避免了多次查询数据库</p>\n</li>\n</ul>\n<h3 id=\"jwt-\">JWT 组成</h3>\n<p>JWT 由 Header, Payload, Signature 三部分组成，即头部，负载，签名，长这样：</p>\n<p>{% asset_img jwt.jpeg jwt %}</p>\n<ul>\n<li><p>Header 头部</p>\n<p>头部包含了两部分，token 类型和采用的加密算法</p>\n<pre><code class=\"lang-json\">{\n  &quot;alg&quot;: &quot;HS256&quot;,\n  &quot;typ&quot;: &quot;JWT&quot;\n}\n</code></pre>\n<p>它会使用 Base64Url 编码组成 JWT 结构的第一部分</p>\n</li>\n<li><p>Payload</p>\n<p>这部分就是我们存放信息的地方了，你可以把用户 ID 等信息放在这里，JWT 规范里面对这部分有进行了比较详细的介绍，常用的由 iss（签发者），exp（过期时间），sub（面向的用户），aud（接收方），iat（签发时间）。这些我们应该规范的使用，因为他们可能是在校验中使用到了（猜测，表示我一个也没用到 =.= ）</p>\n<p>例如：</p>\n<pre><code class=\"lang-json\">{\n  &quot;sub&quot;: &quot;<span class=\"number\">1234567890</span>&quot;,\n  &quot;name&quot;: &quot;John Doe&quot;,\n  &quot;admin&quot;: <span class=\"keyword\">true</span>\n}\n</code></pre>\n<p>同样的，它会使用 Base64Url 编码组成 JWT 结构的第二部分</p>\n</li>\n<li><p>Signature</p>\n<p>前面两部分都是使用 Base64Url 进行编码的，即客户端可以解开知道里面的信息。Signature 需要使用编码后的 header 和 payload 以及我们提供的一个密钥，然后使用 header 中指定的签名算法进行签名。签名的作用是保证 JWT 没有被篡改过。</p>\n</li>\n</ul>\n<p>三个部分通过 <code>.</code> 连接在一起就是我们的 JWT 了，它可能长这个样子：</p>\n<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjU3ZmVmMTY0ZTU0YWY2NGZmYzUzZGJkNSIsInhzcmYiOiI0ZWE1YzUwOGE2NTY2ZTc2MjQwNTQzZjhmZWIwNmZkNDU3Nzc3YmUzOTU0OWM0MDE2NDM2YWZkYTY1ZDIzMzBlIiwiaWF0IjoxNDc2NDI3OTMzfQ.PA3QjeyZSUh7H0GfE0vJaKW4LjKJuC3dVLQiY4hii8s\n</code></pre><p>长度貌似和你的加密算法和私钥有关系。其实到这一步可能就有人会想了，HTTP 请求总会带上 token，这样这个 token 传来传去占用不必要的带宽啊。如果你这么想了，那你可以去了解下 HTTP2，HTTP2 对头部进行了压缩，相信也解决了这个问题。</p>\n<h3 id=\"jwt-\">JWT 使用</h3>\n<p>JWT 生成了，怎么使用就看你了，不过还是有一点要求的。当访问需要 JWT 验证的 API 时，需要把该 JWT 放入头部的 Authorization 中</p>\n<pre><code>Authorization: Bearer &lt;token&gt;\n</code></pre><p>注意 <code>Bearer</code> 是必须的，中间有一个空格，后面跟着 JWT，这样服务端就可以从 Authorization 取出来用了。当然了，你也可以完全爱怎么来就怎么来。但是按照规范你可以省很多事情。</p>\n<p>简单的 JWT 流程是这样的，不带 XSRF 的，没有找到带 XSRF 的图 =.=</p>\n<p>{% asset_img tokens-new.png tokens-new %}</p>\n<h2 id=\"jwt-\">JWT 实践</h2>\n<p>刚才前面也说了，前端用的是 Angular，后端用的是 Koa，登录注册界面由 Koa 负责，由 Koa 根据用户是否登录来决定首页跳转。首先要强调下，下面说的不是唯一的方式，也不是最好的方式，而只是我自己这么用了并且我认为挺稳妥的。我在 Koa 中使用了两个模块，<a href=\"https://github.com/auth0/node-jsonwebtoken\">jsonwebtoken</a> 和 <a href=\"https://github.com/koajs/jwt/tree/koa-v2\">koa-jwt</a>。我以登录为例简单说下整个流程。</p>\n<h3 id=\"-jwt\">登录，生成 JWT</h3>\n<p>在说登录的处理之前，我想先强调这个登录页面还是后端(ejs)来渲染的，而不是前端来渲染。这个其实也会影响到我们存储 token 的考虑。</p>\n<pre><code class=\"lang-js\">router.get([&amp;<span class=\"comment\">#39;/&amp;#39;, &amp;#39;/login&amp;#39;], async (ctx, next) =&gt; {</span>\n    <span class=\"keyword\">if</span>(ctx.cookies.get(&amp;<span class=\"comment\">#39;jwt&amp;#39;)) {</span>\n        let token = jwt.decode(ctx.cookies.get(&amp;<span class=\"comment\">#39;jwt&amp;#39;));</span>\n        <span class=\"keyword\">if</span>(token.id) {\n            let result = await UserModel.findById(token.id);\n            <span class=\"keyword\">if</span>(result &amp;&amp; result._id) await send(ctx, &amp;<span class=\"comment\">#39;./public/index.html&amp;#39;);</span>\n        } <span class=\"keyword\">else</span> {\n            ctx.cookies.set(&amp;<span class=\"comment\">#39;jwt&amp;#39;, null, {overwrite: true, expires: new Date()});</span>\n            ctx.render(&amp;<span class=\"comment\">#39;login.ejs&amp;#39;, {err: &amp;#39;JWT 验证失败&amp;#39;});</span>\n        }\n    } <span class=\"keyword\">else</span> {\n        await ctx.render(&amp;<span class=\"comment\">#39;login.ejs&amp;#39;);  </span>\n    }\n});\n</code></pre>\n<p>当用户访问网站主页或者登录页面的时候，首先要先判断下是否已经有效登录了，如果是，那么跳转到 Angular 中去，否则跳转到登录页面。因为我想法是做一个主页，这个主页不需要加载太多类库，只是简单的展示页面和登录注册页面，用户登录或注册成功后在跳转到 Angular 的入口文件去。</p>\n<p>接下来就是真正的登录接口了</p>\n<pre><code class=\"lang-js\">exports.login = async (ctx, next) =&gt; {\n    let result = await UserModel.findOne({\n        email: ctx.request.body.email, \n        password: SHA256(ctx.request.body.password).toString()});\n    let xsrf = SHA256(_.random(<span class=\"number\">999999999</span>)).toString();\n    <span class=\"keyword\">if</span>(result &amp;&amp; result._id) {\n        let token = jwt.sign({id: result._id, xsrf: xsrf}, config.app.secretKey);\n        ctx.cookies.set(&quot;XSRF-TOKEN&quot;, xsrf, {httpOnly: <span class=\"keyword\">false</span>, overwrite: <span class=\"keyword\">true</span>, expires: <span class=\"keyword\">new</span> Date(<span class=\"keyword\">new</span> Date().getTime() + <span class=\"number\">5184000000</span>)});\n        ctx.cookies.set(&quot;jwt&quot;, token, {httpOnly: <span class=\"keyword\">true</span>, overwrite: <span class=\"keyword\">true</span>, expires: <span class=\"keyword\">new</span> Date(<span class=\"keyword\">new</span> Date().getTime() + <span class=\"number\">5184000000</span>)});\n        await ctx.redirect(&amp;<span class=\"comment\">#39;/&amp;#39;);</span>\n    } <span class=\"keyword\">else</span> {\n        let exist = await UserModel.findOne({email: ctx.request.body.email});\n        <span class=\"keyword\">if</span>(exist &amp;&amp; exist._id)  ctx.<span class=\"keyword\">throw</span>(<span class=\"number\">401</span>, &amp;<span class=\"comment\">#39;密码错误&amp;#39;);</span>\n        <span class=\"keyword\">else</span> ctx.<span class=\"keyword\">throw</span>(<span class=\"number\">401</span>, &amp;<span class=\"comment\">#39;邮箱未注册&amp;#39;);</span>\n    }\n}\n</code></pre>\n<p>恩，熟悉 Node 的应该看懂没啥问题。这里有个变量 <code>xsrf</code> ，作用前面我们已经说了，还有变量 <code>token</code> 就是 JWT 了。然后我们把他设置到 cookie 中，注意 <code>xsrf</code> 不能设置 <code>httpOnly</code> 而 <code>token</code> 需要设置为 <code>httpOnly</code>，不要忘了把 <code>xsrf</code> 也放入 JWT 的 payload 部分中去，这里 payload 存储了用户 id 和当前的 <code>xsrf</code>。</p>\n<h3 id=\"-xsrf\">请求带上 XSRF</h3>\n<p>我们需要在以后的每个请求都带上 XSRF-TOKEN，具体操作就是把 cookie 中的 XSRF-TOKEN 取出来，放入请求的 X-XSRF-TOKEN 头部中，然后发送出去就好了。如果你用的是 Angular，其实你什么都不需要做了，因为这一步 Angular 已经帮你做好了，前提是你的 xsrf 必须放到 cookie 中的 XSRF-TOKEN 这个里面。如果你用的不是 Angular，那你就自己查下怎么做吧，这一步并不难做到。</p>\n<h3 id=\"-header-xsrf\">设置 header 和校验 XSRF</h3>\n<p>前面说了，我们需要把 JWT 放到请求的 <code>Authorization</code> 头部中，但是由于我们对 JWT 设置了 <code>httpOnly</code> ，所以这个操作几乎就不太可能了。但别忘了我们可以在服务端做这一步，与此同时我们也可以把校验 <code>XSRF</code> 也做了，这里先不需要校验 JWT。</p>\n<p>如果熟悉 Koa 的话就清楚 Koa 的中间件思路。我们在较顶层的位置写入：</p>\n<pre><code class=\"lang-js\"><span class=\"comment\">// XSRF 检测，处理客户端未授权问题</span>\napp.<span class=\"keyword\">use</span>(async (ctx, next) =&gt; {\n    let token = ctx.cookies.get(&amp;<span class=\"comment\">#39;jwt&amp;#39;), xsrf = ctx.request.headers[&amp;#39;x-xsrf-token&amp;#39;];</span>\n    ctx.request.header.authorization = &amp;<span class=\"comment\">#39;Bearer &amp;#39; + token;</span>\n    <span class=\"comment\">// 当 JWT 存在且访问 API 时，检测 XSRF </span>\n    <span class=\"keyword\">if</span>(token !== void <span class=\"number\">0</span> &amp;&amp; /^\\/api\\<span class=\"comment\">//.test(ctx.url)) {;</span>\n        let verify = Promise.promisify(jwt.verify);\n        await verify(token, config.app.secretKey).then(async (data) =&gt; {\n            <span class=\"keyword\">if</span>(xsrf !== data.xsrf) {\n                ctx.cookies.set(&quot;XSRF-TOKEN&quot;, <span class=\"keyword\">null</span>, {overwrite: <span class=\"keyword\">true</span>, expires: <span class=\"keyword\">new</span> Date()});\n                ctx.cookies.set(&quot;jwt&quot;, <span class=\"keyword\">null</span>, {overwrite: <span class=\"keyword\">true</span>, expires: <span class=\"keyword\">new</span> Date()});\n                ctx.status = <span class=\"number\">401</span>;\n                ctx.body =  { success: <span class=\"keyword\">false</span>, message: &amp;<span class=\"comment\">#39;用户验证失败&amp;#39;};</span>\n            } <span class=\"keyword\">else</span> {\n                await next();\n            }\n        }, err =&gt; {\n            ctx.cookies.set(&quot;XSRF-TOKEN&quot;, <span class=\"keyword\">null</span>, {overwrite: <span class=\"keyword\">true</span>, expires: <span class=\"keyword\">new</span> Date()});\n            ctx.cookies.set(&quot;jwt&quot;, <span class=\"keyword\">null</span>, {overwrite: <span class=\"keyword\">true</span>, expires: <span class=\"keyword\">new</span> Date()})\n            ctx.status = <span class=\"number\">401</span>;\n            ctx.body = { success: <span class=\"keyword\">false</span>, message: &amp;<span class=\"comment\">#39;用户验证失败&amp;#39;};</span>\n        });\n    } <span class=\"keyword\">else</span> {\n        await next();\n    }\n</code></pre>\n<p>最前面几行就是设置 header，可以看到非常简单。if 语句进来就是检验 <code>XSRF</code> 了，我的逻辑是只有用户请求 API 的时候并且 JWT 存在的时候才做检测。我们后面有对 JWT 的检测所以这里不需要做，如果 JWT 不存在或者方位的不是 API 直接 next 就好了。</p>\n<p>这里调用了 <code>jwt.verify</code> 方法取出了 payload 的内容，这个方法是 <code>jsonwebtoken</code> 这个模块提供的。</p>\n<h3 id=\"-jwt\">检验 JWT</h3>\n<p>有一点需要注意的是，有些资源我们允许用户无需登录就进行访问。例如我们前面的登录注册界面，还要像静态资源等等。使用 <code>koa-jwt</code> 可以很方便的做这件事情。</p>\n<pre><code class=\"lang-js\">app.<span class=\"keyword\">use</span>(handel.routes())\n   .<span class=\"keyword\">use</span>(handel.allowedMethods());\n\napp.<span class=\"keyword\">use</span>(jwt({ secret: config.app.secretKey, algorithm: &amp;<span class=\"comment\">#39;RS256&amp;#39; }).unless({ path: [/^\\/css|js|img|fonts/] }));</span>\n\napp.<span class=\"keyword\">use</span>(api.routes())\n   .<span class=\"keyword\">use</span>(api.allowedMethods());\n</code></pre>\n<p><code>handel</code> 这个路由是我的登录注册页面和接口这些，而 <code>api</code> 就是 Angular 中需要用到的一系列接口。中间我们加入了一句话。这里的 <code>jwt</code> 是 <code>koa-jwt</code> 模块。</p>\n<p>这些顺序不能乱，koa 中间件的加载是按自顶向下的顺序的，所以我们 <code>handel</code> 这里并不要 jwt 检测，而后面则需要。而我们前面说的 xsrf 检测和 header 处理自然是要放在更前的位置了。这里的 <code>path</code> 你可以根据需要修改。具体的用法参考文档就好了。</p>\n<p>整个流程就完了，这个就实现了我们前面探讨的成果。既保护了 token 的安全，又防止了 XSRF 攻击。当然了我不敢说绝对安全，根本就没有绝对安全的东西。但目前这样的鉴权系统应该算马马虎虎了。</p>\n<p>如果你的登录注册也是放在前端（比如由 Angular 来做），那你也可以像我上面说的这么做，或者可以把 jwt 作为登录请求的 response 返回，不过我不觉得这是一种安全的方式，关于其他的存储方式参考我后面给的链接吧，我就不多介绍了。</p>\n<h2 id=\"-\">总结</h2>\n<p>其实关于 JWT 存放到哪里一直由很多讨论，有人说存放到本地存储，有人说存 cookie。但我觉得上面我说的这种方式是挺稳妥的，如果你有什么意见和看法欢迎提出。参考资料也附出了比较热门的关于 jwt 存储位置的讨论文章，可以看下。</p>\n<hr>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://jwt.io/introduction/\">jwt.io</a></li>\n<li><a href=\"https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage\">Where to Store your JWTs – Cookies vs HTML5 Web Storage</a></li>\n<li><a href=\"http://stackoverflow.com/questions/27067251/where-to-store-jwt-in-browser-how-to-protect-against-csrf\">Where to store JWT in browser? How to protect against CSRF?</a></li>\n</ul>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"关于前后端分离鉴权的思考.md","link":"/post/关于前后端分离鉴权的思考.html"},{"title":"编译原理与PEG.js","date":"2016-10-07T16:54:32.000Z","categories":"PEG","tags":["Compiler","PEG.js","JavaScript"],"content":"<h1 id=\"-\">编译原理</h1>\n<p>这学期开始上编译原理这门课，比较纳闷的一点是老师要求用 Java。作为一个想学好编译原理的 Java 黑，自然要寻找另一门可以进行实践的语言，编译在 JavaScript 中应用非常广泛，几乎所有主流的语言都可以编译到 JavaScript，Babel 编译 ES6 到 ES5，以及 CofferScript, TypeScript, JSX 等等编译为 JavaScript。另外，JavaScript 作为一门函数第一公民的语言，我想用来做编译也是特别方便的。一开始看了 Jison，感觉还是挺简单的，不过现在貌似流行 PEG.js，老实说我并不知道他们区别，我还只是一个初学者，或者初学者也算不上，因为最近一个月根本没好好听课 =.=</p>\n<h1 id=\"-\">解析表达式</h1>\n<p>在了解 PEG.js 之前有必要先了解下 <a href=\"https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%9E%90%E8%A1%A8%E8%BE%BE%E6%96%87%E6%B3%95\">PEG</a>（解析表达文法），以及它与 CFG（上下文无关文法）的区别。以下摘选<a href=\"https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%9E%90%E8%A1%A8%E8%BE%BE%E6%96%87%E6%B3%95\">维基百科</a>上面关于解析表达式的解释</p>\n<!--more-->\n<blockquote>\n<p>解析表达文法里面的每一个非终结符本质上表示递归下降解析器里面的一个解析<a href=\"https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0\">函数</a>，其对应的解析表达式展示了这个函数包含的代码内容。概念上，每一个解析函数接受一个输入字符串作为参数，返回以下其中一个结果:</p>\n<ul>\n<li>成功，函数可能向前移动或者“消耗”一个或多个输入字符串的字符</li>\n<li>失败，不消耗任何字符</li>\n</ul>\n<p>一个<strong>非终结符</strong>有可能成功但是不消耗任何输入字符，这也是一种不同于失败的结果。</p>\n<p>只由一个<strong>终结符</strong>组成的原子解析表达式：成功，如果输入字符串的第一个字符就是定义中的终结符，这种情况下消耗这个输入字符；否之失败。由空字符串组成的原子解析表达式总是成功并且不消耗任何输入。只由一个非终结符A组成的原子解析表达式表示对非终结符A的解析函数的<a href=\"https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92\">递归</a>调用。</p>\n<p><strong>序列</strong>操作符 <em>e</em>1<em>e</em>2 首先调用 <em>e</em>1， 如果 <em>e</em>1成功， 接着对 <em>e</em>1 消耗剩下的输入字符串调用 <em>e</em>2， 最后返回结果。如果 <em>e</em>1 或者 <em>e</em>2 失败，那么序列表达式 <em>e</em>1<em>e</em>2 失败。</p>\n<p><strong>选择</strong>操作符 <em>e</em>1 / <em>e</em>2 首先调用 <em>e</em>1， 如果 <em>e</em>1成功， 立刻返回结果。否则如果 <em>e</em>1 失败，选择操作符<a href=\"https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF\">回溯</a>到输入字符串匹配 <em>e</em>1 的原始位置，调用 <em>e</em>2， 最后返回 <em>e</em>2 结果。</p>\n<p><strong>零个或多个</strong>，<strong>一个或多个</strong>，和<strong>可选</strong>操作符分别消耗零个或多个，一个或多个，或者零个或一个连续重复的子表达式e。与上下文无关文法和正则表达式不同的 是，尽管如此，在PEG里这些操作符总是执行贪婪的行为，那就是消耗尽可能多的输入，而且绝对不回溯。（正则表达式一开始执行贪婪匹配，但是如果整个正则表达式失败后，会回退并尝试短一些的匹配。）例如，解析表达式a<em>总是尽可能多的消耗输入字符串中连续出现的a，解析表达式(a</em> a)则必然会失败因为前半部分a*绝对不会留下一丁点a给后半部分去匹配。</p>\n<p>最后，肯定断言和否定断言实现了句法断言。&amp;e 表达式调用子表达式e，如果e成功，则返回成功；否则返回失败。无论结果如何都不消耗任何字符。反之，当e失败时！e 表达式成功，e成功时！e 表达式失败， 同样无论结果如何都不消耗任何字符。因为向前判断的子表达式e 可以任意的复杂，所以断言表达式提供了强大的句法向前判断和去除二义性的能力。</p>\n</blockquote>\n<h1 id=\"peg-js\">PEG.js</h1>\n<p>PEG.js 是一个基于 JavaScript 的简单的解析器生成器，它用来生成一个快速且具备完善错误报告的解析器。你可以用它来处理复杂的数据或计算机语言，已经轻松的构造变换器，解释器，编译器以及其他的工具。</p>\n<h2 id=\"-\">特性</h2>\n<ul>\n<li>简单和具有表现力的语法符号</li>\n<li>集成了词法分析( lexcial )和语义分析( syntactical )</li>\n<li>具备优良的错误报告</li>\n<li>基于解析表达式语法的形式，比传统的 LL(k) 和 LR(k) 解析器更强大</li>\n<li>可以用于浏览器，命令行，或者通过 JavaScript 的 API</li>\n</ul>\n<h2 id=\"-\">开始</h2>\n<p><a href=\"http://pegjs.org/online\">在线版本</a> 是生成一个解析器最简单的方式，只要输入你定义的语法，尝试解析少量的输入，下载生成的解析后的代码。</p>\n<h2 id=\"-\">安装</h2>\n<h3 id=\"node-js\">Node.js</h3>\n<p>如果要使用 <code>pegj</code> 命令，全局安装 PEG.js</p>\n<pre><code class=\"lang-bash\">npm install -g pegjs\n</code></pre>\n<p>如果要使用 JavaScript 的 API，本地安装 PEG.js</p>\n<pre><code class=\"lang-bash\">npm install pegjs\n</code></pre>\n<p>如果你两者都需要，那么两种方式都安装即可</p>\n<h3 id=\"-\">浏览器</h3>\n<p><a href=\"http://pegjs.org/#download\">下载</a> PEG.js 库(普通或者压缩的版本) 或者通过 Bower 安装</p>\n<pre><code class=\"lang-bash\">bower install pegjs\n</code></pre>\n<h2 id=\"-\">生成一个解析器</h2>\n<p>PEG.js 根据一个你希望解析的输入的语法以及你指定的返回结果(对匹配的进行语义分析)生成解析器。最后生成解析器本质上只是一个带有一些简单 API 的 JavaScript 对象。</p>\n<h3 id=\"-\">命令行</h3>\n<p>想要根据你的语法生成一个解析器，使用 <code>pegjs</code> 命令：</p>\n<pre><code class=\"lang-bash\">pegjs arithmetics.pegjs\n</code></pre>\n<p>这将会把解析器代码写入一个以 &#39;.js&#39; 为扩展名的相同文件名文件中， 你也可以自己指定输出：</p>\n<pre><code>pegjs -o arithmetics-parser.js arithmetics.pegjs\n</code></pre><p>如果你省略了输入和输出文件，那么将会使用标准的输入输出</p>\n<p>默认下，解析器的生成采用了 Node.js 的模块格式，你可以使用 <code>--format</code> 选项来覆盖。</p>\n<p>你可以调整一下几个选项：</p>\n<ul>\n<li><code>--allowed-start-rules</code> -- 逗号相隔的会被用来解析的规则（默认为第一个规则）</li>\n<li><code>--cache</code> -- 让解析器缓存结果，避免在极端情况下出现了指数级的解析时间而降低解析器速度</li>\n<li><code>--dependency</code> -- 给解析器指定依赖（可以多次指定）</li>\n<li><code>--export-<span class=\"keyword\">var</span></code> -- 指定一个全局变量名称，当没有进行模块到处时，解析器对象会以该名称命名</li>\n<li><code>--extra-options</code> -- 其他的传递给 <code>peg.generate</code> 的选项（JSON 格式）</li>\n<li><code>--extra-options-file</code> -- 同上，只不过选项保存在文件里面</li>\n<li><code>--format</code> -- 指定解析器的到导出格式，如 <code>amd</code>， <code>commonjs</code>，<code>globals</code>，<code>umd</code>（默认: <code>commonjs</code>）</li>\n<li><code>--optimize</code> -- 在优化解析速度（<code>speed</code>）和代码大小（<code>size</code>）之间进行选择（默认：<code>speed</code>）</li>\n<li><code>--plugin</code> -- 让 PEG.js 使用一个指定的插件（可以多次指定）</li>\n<li><code>--trace</code> -- 让解析器跟踪其运行情况</li>\n</ul>\n<h3 id=\"javascript-api\">JavaScript API</h3>\n<p>在 Node.js 中，需要引入 PEG.js 这个模块</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> peg = <span class=\"keyword\">require</span>(&amp;<span class=\"comment\">#39;pegjs&amp;#39;);</span>\n</code></pre>\n<p>在浏览器中，通过 <code>&lt;script&gt;</code> 标签引入 PEG.js 库到你的网页中。如果 PEG.js 使用 AMD 模块化方案，它会把模块定义在一个变量上面，否则他的 API 将会挂载在全局对象 <code>peg</code> 中</p>\n<p>为了生成一个解析器，调用 <code>peg.generate</code> 方法并把你的语法作为参数传递进去</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> parser = peg.generate(&quot;start = (&amp;<span class=\"comment\">#39;a&amp;#39;/&amp;#39;b&amp;#39;)+&quot;);</span>\n</code></pre>\n<p>这个方法会返回解析器对象或者返回源码（取决于你的 <code>output</code> 参数 -- 参见下文）。如果语法非法它将抛出错误，错误会包含 <code>message</code> 属性，它携带更详细的错误信息</p>\n<p>你可以传入以下选项组成的对象作为 <code>peg.generate</code> 的第二个参数，以下选项是受支持的：</p>\n<ul>\n<li><code>allowedStartRules</code> -- 指定解析器从哪个规则开始解析（默认：语法中的第一个规则）</li>\n<li><code>cache</code> -- 如果为 <code><span class=\"keyword\">true</span></code>，解析器会缓存结果以避免指数级的解析时间影响解析器效率（默认：<code><span class=\"keyword\">false</span></code>）</li>\n<li><code>dependencies</code> -- 解析需要的依赖，它的值为一个变量与依赖模块映射的对象。解析器通过这些变量来使用那些模块。只有当 <code>format</code> 被设置为 <code>amd</code>，<code>commonjs</code> 或者 <code>umd</code> （默认：<code>{}</code>）时才有效。</li>\n<li><code>exportVar</code> -- 一个全局对象名，当没有进行模块导出时，解析器对象会以该名称命名</li>\n<li><code>format</code> -- 生成的解析器的导出格式（&quot;amd&quot;，&quot;bare&quot;，&quot;commonjs&quot;，&quot;globals&quot;，&quot;umd&quot;），只有当 <code>output</code> 设置为 <code>source</code> 时（默认：<code><span class=\"keyword\">null</span></code>）才有效</li>\n<li><code>optimize</code> -- 在优化解析速度（<code>speed</code>）和代码大小（<code>size</code>）之间进行选择（默认：<code>speed</code>）</li>\n<li><code>output</code> -- 如果设置为 <code>parser</code>，这个方法将返回解析器对象；如果设置为 <code>source</code>，它会以字符串的形式返回生成的解析器的源码（默认：<code>parser</code>）</li>\n<li><code>plugin</code> -- 让 PEG.js 使用一个指定的插件（可以多次指定）</li>\n<li><code>trace</code> -- 让解析器跟踪其运行情况</li>\n</ul>\n<h2 id=\"-\">使用解析器</h2>\n<p>使用生成的解析器的方法十分简单，只要调用它的 <code>parse</code> 方法并把参数作为一个字符串传入即可。该方法会返回解析的结果（确切的值取决于你的生成该解析器的语法）或者抛出错误（如果你的输入非法）。抛出的错误信息带有 <code>location</code>，<code>expected</code>，<code>found</code> 以及包含更多错误信息的 <code>message</code> </p>\n<pre><code class=\"lang-js\">parser.parse(&quot;abba&quot;);        <span class=\"comment\">// returns [&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;]</span>\nparser.parse(&quot;abcd&quot;);        <span class=\"comment\">// throws an exception</span>\n</code></pre>\n<p>你还可以通过传入第二个参数来调整解析行为，该参数是一个支持以下可选项的对象：</p>\n<ul>\n<li><code>startRule</code> -- 从这个规则开始解析</li>\n<li><code>tracer</code> -- 追踪解析行为</li>\n</ul>\n<p>解析器也支持你自定义的选项</p>\n<h2 id=\"-\">句法和语义</h2>\n<p>PEG.js 的句法不是面向行的，并且会忽略标记（token）之间的空白，这一点和 JavaScript 相似。你也可以使用 JavaScript 风格的注释（<code><span class=\"comment\">//...</span></code> 和 <code><span class=\"comment\">/*...*/</span></code>）</p>\n<p>让我们看一个简单的可以识别形如 <code>2*(3+4)</code> 这样的表达式的语法。根据这个语法生成的解析器可以计算该表达式的值</p>\n<pre><code class=\"lang-javascript\">start\n  = additive\n\nadditive\n  = left:multiplicative &quot;+&quot; right:additive { <span class=\"keyword\">return</span> left + right; }\n  / multiplicative\n\nmultiplicative\n  = left:primary &quot;*&quot; right:multiplicative { <span class=\"keyword\">return</span> left * right; }\n  / primary\n\nprimary\n  = integer\n  / &quot;(&quot; additive:additive &quot;)&quot; { <span class=\"keyword\">return</span> additive; }\n\ninteger &quot;integer&quot;\n  = digits:[<span class=\"number\">0</span>-<span class=\"number\">9</span>]+ { <span class=\"keyword\">return</span> parseInt(digits.join(&quot;&quot;), <span class=\"number\">10</span>); }\n</code></pre>\n<p>在顶层，语法包含了规则（在我们的例子中，有五条规则）。每条规则都由一个名字（例如 <code>integer</code>）来区分它们，并且还有一个解析表达式（例如 <code>digits:[<span class=\"number\">0</span>-<span class=\"number\">9</span>]+ { <span class=\"keyword\">return</span> parseInt(digits.join(&quot;&quot;), <span class=\"number\">10</span>); }</code>）来定义一个对输入文本的匹配，你还可以在其中包含你的 JavaScript 代码来处理被成功匹配到的文本。规则可以包含别名以便于错误提示（例如上面的例子中，只有 <code>integer</code> 规则具有别名）。解析将从第一条规则，这条规则也叫作 <em>start rule</em></p>\n<p>一个规则名必须是一个 JavaScript 标识符，它后面跟着一个 <code>=</code> 和解析表达式。如果这个规则名有一个别名，它作为一个 JavaScript 字符串书写在规则名和 <code>=</code> 之间。规则之间需要用空格分割开，但在解析表达式后面跟着 <code>;</code> 也是可以的。</p>\n<p>你可以在第一个规则前初始化一些用 <code>{}</code> 闭合的 JavaScript 代码。这些代码会在解析器开始解析之前先执行。在初始化操作中定义的变量名和函数可以在规则操作和语义谓词中直接使用，同时他们也可以直接访问通过 <code>options</code> 传递进来的对象。初始化过程中括号必须严格闭合。比如我们来看一个简单的例子：</p>\n<pre><code class=\"lang-javascript\">{\n  <span class=\"keyword\">function</span> makeInteger(o) {\n    <span class=\"keyword\">return</span> parseInt(o.join(&quot;&quot;), <span class=\"number\">10</span>);\n  }\n}\n\nstart\n  = additive\n\nadditive\n  = left:multiplicative &quot;+&quot; right:additive { <span class=\"keyword\">return</span> left + right; }\n  / multiplicative\n\nmultiplicative\n  = left:primary &quot;*&quot; right:multiplicative { <span class=\"keyword\">return</span> left * right; }\n  / primary\n\nprimary\n  = integer\n  / &quot;(&quot; additive:additive &quot;)&quot; { <span class=\"keyword\">return</span> additive; }\n\ninteger &quot;integer&quot;\n  = digits:[<span class=\"number\">0</span>-<span class=\"number\">9</span>]+ { <span class=\"keyword\">return</span> makeInteger(digits); }\n</code></pre>\n<p>规则的解析表达式用来匹配输入的文本。这里由好几种类型的表达式 -- 匹配字符或字符类，显示可选部分和重复等等。表达式中也可以包含其他规则的引用。详细介绍见下文。</p>\n<p>如果一个表达式成功的匹配到了一个输入流的部分文本，它会产生一个匹配结果，这是一个 JavaScript 值。例如：</p>\n<ul>\n<li>一个匹配字符串的表达式生成一个包含被匹配串的 JavaScript 字符串</li>\n<li>一个匹配包含子表达式的字符串的表达式生成一个含有全部被匹配项的 JavaScript 数组</li>\n</ul>\n<p>当在表达式中使用规则名时，它将递归的解析下去并最终返回全部解析完成的结果</p>\n<p>一个特殊的情况是解析表达式是一个解析行为 -- 一段 JavaScript 代码包含在 <code>{}</code> 里面。它会处理匹配到的文本串并返回处理的结果，这个值是也被认为是表达式匹配的结果（换句话说，解析行为是对被匹配文本的一个变换器）</p>\n<p>在我们的算术例子中由几个解析行为。比如这个表达式 <code>digits:[<span class=\"number\">0</span>-<span class=\"number\">9</span>] + { <span class=\"keyword\">return</span> parseInt(digits.join(&quot;&quot;), <span class=\"number\">10</span>); }</code>，它处理 [0-9]+ 匹配的结果，这个结果是一个包含匹配的数字字符串组成的数组，它作为参数传入到该后面的行为被拼接成为一个 JavaScript <code>number</code> 对象后返回</p>\n<h2 id=\"-\">解析表达式类型</h2>\n<p>解析表达式有好几种类型，他们当中可能有些还包含子表达式从而形成一个递归结构</p>\n<p>&quot;<em>literal</em>&quot;</p>\n<p>&#39;<em>literal</em>&#39;</p>\n<p>解析表达式会精确匹配字符串并返回，该字符串的句法和 JavaScript 一样。在字符串后面追加 <code>i</code> 使得匹配区分大小写</p>\n<p><em>.</em></p>\n<p>匹配一个字符并作为一个字符串返回</p>\n<p><em>[characters]</em></p>\n<p>从一个集合中匹配一个字符并作为一个字符串返回。集合中的字符可以以和 JavaScript 字符串相同的方式进行转义处理。集合中的字符也可以包含范围（例如 [a-z] 表示匹配一个小写字母）。在字符前面加上 <code>^</code> 表示取反（例如：<code>[^a-z]</code> 表示匹配一个非小写字母）。在右括号后面添加 <code>i</code> 可以让匹配区分大小写</p>\n<p><em>rule</em></p>\n<p>递归的匹配一个解析表达式规则并返回匹配的结果</p>\n<p><em>( expression )</em></p>\n<p>匹配一个子表达式并返回匹配的结果</p>\n<p><em>expression *</em></p>\n<p>匹配表达式零次或多次并以数组的形式返回匹配结果。这个匹配是贪婪匹配，即解析器会尽可能的进行多次匹配。不像正则表达式，解析表达式没有回溯</p>\n<p><em>expression +</em></p>\n<p>匹配表达式一次或多次并以数组的形式返回匹配结果。这个匹配是贪婪匹配，即解析器会尽可能的进行多次匹配。不像正则表达式，解析表达式没有回溯</p>\n<p><em>expression ?</em></p>\n<p>尝试匹配表达式，如果匹配成功，返回匹配的结果，否则返回 <code><span class=\"keyword\">null</span></code>。不像正则表达式，解析表达式没有回溯</p>\n<p><em>&amp; expression</em></p>\n<p>尝试匹配表达式，如果匹配成功，只返回 <code>undefined</code> 并且不消耗任何输入，否则认为匹配是失败的</p>\n<p><em>! expression</em></p>\n<p>尝试匹配表达式，如果匹配不成功，只返回 <code>undefined</code> 并且不消耗任何输入，否则认为匹配是失败的</p>\n<p><code>&amp; { predicate }</code></p>\n<p><code>predicate</code> 是一段 JavaScript 代码，可以理解为是它是在一个函数里面等待执行。它会把前面表达式匹配得到的结果作为它的参数。它通过 <code><span class=\"keyword\">return</span></code> 来返回 JavaScript 值。If the returned value evaluates to <code><span class=\"keyword\">true</span></code> in boolean context，返回 <code>undefined</code> 并且不消耗任何输入，否则认为匹配是失败的</p>\n<p>在 <code>predicate</code> 中的代码可以访问初始化时定义的变量和方法</p>\n<p>在 <code>predicate</code> 中的代码可以通过调用 <code>location</code> 函数来访问当前位置信息，它会返回一个像下面这样的对象：</p>\n<pre><code class=\"lang-json\">{\n  start: { offset: 23, line: 5, column: 6 },\n  end: { offset: 23, line: 5, colume: 6}\n}\n</code></pre>\n<p><code>start</code> 和 <code>end</code> 都指向当前解析的位置，<code>offset</code> 为一个从 0 开始的偏移值，<code>line</code> 和 <code>column</code> 为从 1 开始的行号和列号</p>\n<p>在 <code>pedicate</code> 中的代码可以通过 <code>options</code> 变量来访问解析器被调用时传递进来的选项对象</p>\n<p>注意括号必须严格闭合</p>\n<p><em>! { predicate }</em></p>\n<p><code>predicate</code> 是一段 JavaScript 代码，可以理解为是它是在一个函数里面等待执行。它会把前面表达式匹配得到的结果作为它的参数。它通过 <code><span class=\"keyword\">return</span></code> 来返回 JavaScript 值。If the returned value evaluates to <code><span class=\"keyword\">false</span></code> in boolean context，返回 <code>undefined</code> 并且不消耗任何输入，否则认为匹配是失败的</p>\n<p>在 <code>predicate</code> 中的代码可以访问初始化时定义的变量和方法</p>\n<p>在 <code>predicate</code> 中的代码可以通过调用 <code>location</code> 函数来访问当前位置信息，它会返回一个像下面这样的对象：</p>\n<pre><code class=\"lang-json\">{\n  start: { offset: 23, line: 5, column: 6 },\n  end: { offset: 23, line: 5, colume: 6}\n}\n</code></pre>\n<p><code>start</code> 和 <code>end</code> 都指向当前解析的位置，<code>offset</code> 为一个从 0 开始的偏移值，<code>line</code> 和 <code>column</code> 为从 1 开始的行号和列号</p>\n<p>在 <code>pedicate</code> 中的代码可以通过 <code>options</code> 变量来访问解析器被调用时传递进来的选项对象</p>\n<p>注意括号必须严格闭合</p>\n<p><em>$ expression</em></p>\n<p>尝试匹配表达式，如果匹配成功，返回匹配的文本而不是匹配的结果</p>\n<p><em>label: expression</em></p>\n<p>匹配表达式并使用 <code>label</code> 来保存匹配结果，<code>label</code> 必须是一个 JavaScript 符号</p>\n<p>符号表达式通常和解析行为一起使用，表达式匹配结果保存在符号中，解析行为通过符号来访问匹配结果</p>\n<p><em>expression_1</em> <em>expression_2</em> ... <em>expression_n</em></p>\n<p>匹配一连串表达式并把匹配结果作为一个数组返回</p>\n<p><em>expression { action }</em></p>\n<p>匹配表达式，如果匹配成功，则执行表达式，否则认为匹配是失败的</p>\n<p><code>action</code> 是一段 JavaScript 代码，可以理解为是它是在一个函数里面等待执行。它会把前面表达式匹配得到的结果作为它的参数。它通过 <code><span class=\"keyword\">return</span></code> 来返回 JavaScript 值。返回值是匹配的结果。</p>\n<p>为了便于查错，<code>action</code> 里面可以调用 <code>expected</code> 函数来让解析器抛出一个错误。这个函数有两个参数，一个描述当前位置预期的结果和可选的当前位置的信息（默认为 <code>location</code> 函数调用返回的结果 -- 见下文）。这个描述会作为抛出错误信息的一部分</p>\n<p><code>action</code> 里面也可以调用 <code>error</code> 函数，同样也会让编译器抛出错误。这个函数也由两个参数 -- 错误信息和可选的位置信息（默认为 <code>location</code> 函数调用返回的结果 -- 见下文）。错误信息将被抛出的错误所使用</p>\n<p><code>action</code> 里面的代码也可以访问语法初始化时的定义的变量和方法。注意必须严格括号闭合</p>\n<p><code>action</code> 里面的代码也可以通过 <code>text</code> 函数来访问前面表达式匹配的字符串</p>\n<p><code>action</code> 里面的代码也可以通过调用 <code>location</code> 函数来访问当前位置信息，它会返回一个像下面这样的对象：</p>\n<pre><code class=\"lang-json\">{\n  start: { offset: 23, line: 5, column: 6 },\n  end: { offset: 25, line: 5, colume: 8}\n}\n</code></pre>\n<p><code>start</code> 执行表达式开始的位置，而 <code>end</code> 指向表达式结束的位置。<code>offset</code> 是从 0 开始的偏移值，<code>line</code> 和 <code>column</code> 是从 1 开始的行数和列数</p>\n<p><code>action</code> 里面的代码可以通过 <code>options</code> 变量来访问解析器被调用时传递进来的选项对象</p>\n<p>注意括号必须严格闭合</p>\n<p><em>expression_1 / expression_2 / ... / expression_n</em></p>\n<p>尝试匹配第一个表达式，如果没有匹配到，则尝试第二个，以此类推。最后返回第一个匹配成功的表达式匹配的结果。如果没有成功匹配的表达式，则认为匹配失败。</p>\n<h2 id=\"-\">兼容性</h2>\n<p>解析器生成器和生成的解析器都可以在以下环境中运行：</p>\n<ul>\n<li>Node.js 4+</li>\n<li>Internet Explorer 8+</li>\n<li>Edge</li>\n<li>Firefox</li>\n<li>Chrome</li>\n<li>Safari</li>\n<li>Opera</li>\n</ul>\n<h2 id=\"development\">Development</h2>\n<ul>\n<li><a href=\"http://pegjs.org/\">Project website</a></li>\n<li><a href=\"https://github.com/pegjs/pegjs/wiki\">Wiki</a></li>\n<li><a href=\"https://github.com/pegjs/pegjs\">Source code</a></li>\n<li><a href=\"https://github.com/pegjs/pegjs/issues\">Issue tracker</a></li>\n<li><a href=\"http://groups.google.com/group/pegjs\">Google Group</a></li>\n<li><a href=\"http://twitter.com/peg_js\">Twitter</a></li>\n</ul>\n<p>PEG.js is developed by <a href=\"http://majda.cz/\">David Majda</a> (<a href=\"http://twitter.com/dmajda\">@dmajda</a>). The <a href=\"https://github.com/pegjs/bower\">Bower package</a> is maintained by <a href=\"http://www.michel-kraemer.com/\">Michel Krämer</a> (<a href=\"https://twitter.com/michelkraemer\">@michelkraemer</a>).</p>\n<p>You are welcome to contribute code. Unless your contribution is really trivial you should get in touch with me first — this can prevent wasted effort on both sides. You can send code both as a patch or a GitHub pull request.</p>\n<p>Note that PEG.js is still very much work in progress. There are no compatibility guarantees until version 1.0.</p>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"编译原理与PEG-js.md","link":"/post/编译原理与PEG-js.html"},{"title":"Angular 最佳实践总结 (一)","date":"2016-09-29T14:45:13.000Z","categories":"Angular","tags":["Angular"],"content":"<p>搞了快一年的 Angular，Angular 真的是一个非常强大非常齐全非常好用的框架，而且拥有强大的社区支持，虽然踩了很多坑，但是仍然无悔学习了这样一个框架。Angular 2 已经正式发布了，我也打算学 Angular2 去了，现在手头上还有一个用 Angular 的项目，这个项目我是想把我学到的很多 Angular 的最佳实践都用进去，借此我就想干脆也写几篇博客总结下好了，我写的比较散，想到什么就说什么。</p>\n<h2 id=\"-\">使用单次绑定或单向绑定</h2>\n<p>从 Angular 1.3 开始就有了 once-time binding，Angular 1.5 开始支持了指令和组件的 one-way binding。看看他们的用法：</p>\n<p>单次绑定很简单，加上<code>::</code> 就可以了。</p>\n<pre><code class=\"lang-javascript\">&lt;p&gt;{{::vm.title}}&lt;/p&gt;\n</code></pre>\n<blockquote>\n<p>An expression that starts with <code>::</code> is considered a one-time expression. One-time expressions will stop recalculating once they are stable, which happens after the first digest if the expression result is a non-undefined value (see value stabilization algorithm below).</p>\n</blockquote>\n<p>当 digest 结束之后并且单次绑定的值不为 undefined 时，这个值将不再被监听。官方称这个算法为 <code>Value stabilization algorithm</code> 还解释了一下。看到这个，再想起 Angular 源码那注释，觉得真的业界良心啊。想具体了解下单次绑定，出门右转 -&gt; <a href=\"https://docs.angularjs.org/guide/expression\">docs.angularjs</a></p>\n<p>在视图进行单向绑定也很简单，使用 <code>ng-bind</code> 就可以了，这里主要说的是指令和组件中的单向绑定。</p>\n<p>其实 Angular1 还是不断再发展，现在最新的是 1.5.9，加了很多新的东西，也做了很多性能优化。单向绑定也是 1.5 之后才引入的新东西。1.5 也引入了一个新的东西叫 component，和 directive 差不多，具体我没用过我也不太了解，不过写法简洁了很多。单向绑定主要就是用于 component 和 directive 的。</p>\n<p>随便找个比较简单的例子来说下，</p>\n<pre><code class=\"lang-javascript\">(<span class=\"keyword\">function</span>(){\n  &amp;<span class=\"comment\">#39;use strict&amp;#39;;</span>\n  <span class=\"keyword\">var</span> app = angular.module(&amp;<span class=\"comment\">#39;app&amp;#39;);</span>\n\n  app.component(&amp;<span class=\"comment\">#39;menuBar&amp;#39;, {</span>\n    <span class=\"comment\">// defines a two way binding in and out of the component</span>\n    bindings: {\n      brand:&amp;<span class=\"comment\">#39;&lt;&amp;#39;</span>\n     },\n    <span class=\"comment\">// Load the template</span>\n    templateUrl: &amp;<span class=\"comment\">#39;/js/components/appComponent.html&amp;#39;,</span>\n    controller: <span class=\"keyword\">function</span> () {\n    <span class=\"comment\">// A list of menus</span>\n      <span class=\"keyword\">this</span>.menu = [{\n        name: &quot;Home&quot;,\n        component: &quot;home&quot;\n      }, {\n        name: &quot;About&quot;,\n        component: &quot;about&quot;\n      }, {\n        name: &quot;Contact&quot;,\n        component: &quot;contact&quot;\n      }];\n    }\n  });\n})();\n</code></pre>\n<p>单向绑定就上面的 <code>&lt;</code> ，我们知道一般有 <code>@</code>, <code>=</code>, <code>&amp;</code> 三种方式，分别表示绑定字面量，绑定表达式，绑定事件，而新增的 <code>&lt;</code> 是用来实现单向绑定的。上面这段代码是从别的地方找来的，由于我自己没有使用过，所以暂时不过多介绍，晚点搞清楚了再补充下。</p>\n<h2 id=\"-interval\">谨慎使用 $interval</h2>\n<p>如果我们要实现实时显示当前时间的效果，可以有下面三种方式:</p>\n<pre><code class=\"lang-javascript\">vm.time = Date.now();\n\n<span class=\"comment\">// 方式一</span>\nsetInterval(() =&gt; {\n  vm.time = Date.now();\n  <span class=\"variable\">$scope</span>.<span class=\"variable\">$digest</span>();\n}, <span class=\"number\">1000</span>);\n\n<span class=\"comment\">// 方式二</span>\nsetInterval(() =&gt; {\n  <span class=\"variable\">$scope</span>.<span class=\"variable\">$apply</span>(() =&gt; {\n    vm.time = Date.now();\n  })\n}, <span class=\"number\">1000</span>);\n\n<span class=\"comment\">// 方式三</span>\n<span class=\"variable\">$interval</span>(() =&gt; {\n  vm.time = Date.now();\n}, <span class=\"number\">1000</span>);\n</code></pre>\n<p>考虑到页面还有其他双向绑定量，你觉得上面三种方式哪种性能消耗会小一点？</p>\n<p>我这边测试了下，三种方式导致当前 digest 所执行的 watcher 表达式数量分别是　方式一 (34) &lt; 方式二 (140) = 方式三 (140)。</p>\n<p>{% asset_img 方式一.png 方式一 %}</p>\n<p>{% asset_img 方式二.png 方式二 %}</p>\n<p>{% asset_img 方式三.png 方式三 %}</p>\n<p>我感觉有种被骗的感觉，我记得大家都说不要手动调用 <code><span class=\"variable\">$digest</span></code> 啊要用 <code><span class=\"variable\">$apply</span></code> 啊... 但事实是这里的方式一是性能最好的，如果要说原因，那是因为<code><span class=\"variable\">$scope</span>.<span class=\"variable\">$digest</span>()</code> 只会触发当前 scope 进行 digest，而其余的就会从 <code><span class=\"variable\">$rootScope</span></code> 下来整个都进行 digest，对于我们这里只是想要实现时间变化的需求来说就显得有点多于了，这种情况下还是方式一合适些。当然了你也可以用原生 JS 来写，但这样就使用不了 Angular 的日期格式化功能了~</p>\n<p>不少人认为 Angular 脏检查是轮询，如果不加限制使用 <code><span class=\"variable\">$interval</span></code>，不就和轮询没区别了。所以能少用就少用，这里不用 <code><span class=\"variable\">$interval</span></code> 是因为它会在每次循环结束自动调用 <code><span class=\"variable\">$rootScope</span></code> 上面的 digest，因此使用 setInterval，如果你不触发 digest，那么这个数据的变化是不会同步到视图中的，所以我们手动的触发了当前作用于的 digest。</p>\n<h2 id=\"ng-repeat-trackby-\">ng-repeat 使用 trackby 优化</h2>\n<p>Angular 会为每个 watch 变量生成一个 <code>hashkey</code>，并使用他来跟踪其值的变化，当我们使用 ng-repeat 时，如果数组的内容发生了变化，Angular 不会重新销毁和渲染整个 DOM，而是找出变化的一部分做出修改，由于 <code>hashkey</code> 是根据节点内容产生的，这意味着我们的数组中不能有完全一样的两个节点存在。并且当数组的子项为对象时，用一个类似的新的数组覆盖它会导致 Angular 销毁并重新渲染整个 DOM。我们试一试便知。</p>\n<pre><code class=\"lang-html\">&lt;!-- 不使用 track by --&gt;\n&lt;p ng-repeat=&quot;item in items&quot;&gt;\n  {{item.value}}\n&lt;/p&gt;\n\n&lt;!-- 使用 track by --&gt;\n&lt;p ng-repeat=&quot;item in vm.items track by item.key&quot;&gt;\n  {{item.value}}\n&lt;/p&gt;\n</code></pre>\n<p>我们在控制器里面这样写看下</p>\n<pre><code class=\"lang-javascript\">vm.items = [{key: <span class=\"number\">1</span>, value: <span class=\"number\">2</span>}, {key: <span class=\"number\">3</span>, value: <span class=\"number\">4</span>}, {key: <span class=\"number\">5</span>, value: <span class=\"number\">6</span>}];\n<span class=\"variable\">$timeout</span>(() =&gt; vm.items = [{key: <span class=\"number\">1</span>, value: <span class=\"number\">2</span>}, {key: <span class=\"number\">3</span>, value: <span class=\"number\">4</span>}, {key: <span class=\"number\">5</span>, value: <span class=\"number\">6</span>}], <span class=\"number\">2000</span>);\n<span class=\"variable\">$timeout</span>(() =&gt; vm.items.push({key: <span class=\"number\">7</span>, value: <span class=\"number\">8</span>}), <span class=\"number\">3000</span>);\n</code></pre>\n<p>可以自己试一试，然后调出开发者工具查看下 DOM 的变化</p>\n<p>结果是：</p>\n<ul>\n<li><p>不使用 track by</p>\n<p>2 秒后重新渲染全部子节点，3 秒后添加渲染了一个新节点。</p>\n</li>\n<li><p>使用 track by</p>\n<p>2 秒后没变化，3秒后添加渲染了一个新节点。</p>\n</li>\n</ul>\n<p>他们的区别就在数组重新赋值上面，还有就是数组必须是一个由对象组成的数组。在有些情况下，我们可能需要使用一个新的数组覆盖旧的数组，而他们之间可能有部分是相同的，如果我们使用 trackBy，Angular 就可以利用这一部分已经渲染好的 DOM，从而达到了优化的目的。</p>\n<p>如果没有特别的唯一标识可以指定，也可以直接使用 <code>track by <span class=\"variable\">$index</span></code>，也可以起到一样的作用。</p>\n<h2 id=\"-\">关闭调试信息</h2>\n<p>据说这个方法很多人都不知道？</p>\n<pre><code class=\"lang-javascript\"><span class=\"variable\">$compileProvider</span>.debugInfoEnabled(<span class=\"keyword\">false</span>);\n</code></pre>\n<p>这样就可以关闭 Angular 插在视图里面的任何辅助调试信息例如 <code>ng-<span class=\"keyword\">if</span></code> 和 <code>ng-repeat</code> 等注释以及 <code>ng-binding</code> 等 CSS 类。上线的时候关掉会比较好一点。</p>\n<h2 id=\"-interceptors\">使用超级强大的 interceptors</h2>\n<p>这个在做全局请求和相应处理时特别强大，通过它我们可以实现统一修改每个请求的 header，对返回的结果进行处理，全局 HTTP 错误响应处理等等。用法也相当简单：</p>\n<pre><code class=\"lang-javascript\"><span class=\"variable\">$httpProvider</span>.interceptors.push(<span class=\"keyword\">function</span>(<span class=\"variable\">$q</span>) {\n  <span class=\"keyword\">return</span> {\n    &amp;<span class=\"comment\">#39;request&amp;#39;: function(config) {</span>\n\n    },\n    &amp;<span class=\"comment\">#39;requestError&amp;#39;: function(rejection) {</span>\n\n    },\n    ‘response&amp;<span class=\"comment\">#39;: function(response) {</span>\n\n    },\n    &amp;<span class=\"comment\">#39;responseError&amp;#39;: function(rejection) {</span>\n\n    }\n  }\n});\n</code></pre>\n<p>额，举个粟子：</p>\n<pre><code class=\"lang-javascript\">(<span class=\"keyword\">function</span>() {\n    angular\n        .module(&amp;<span class=\"comment\">#39;app&amp;#39;)</span>\n        .factory(&amp;<span class=\"comment\">#39;tokenInjector&amp;#39;, tokenInjector);</span>\n\n    <span class=\"keyword\">function</span> tokenInjector(<span class=\"variable\">$injector</span>, <span class=\"variable\">$q</span>, <span class=\"variable\">$cookies</span>, <span class=\"variable\">$cacheFactory</span>, <span class=\"variable\">$timeout</span>) {\n        let jwt = undefined;\n\n        <span class=\"keyword\">return</span> {\n            request: <span class=\"keyword\">function</span>(config) {\n                <span class=\"keyword\">if</span>(void <span class=\"number\">0</span> === jwt) {\n                    jwt = <span class=\"variable\">$cookies</span>.get(&amp;<span class=\"comment\">#39;jwt&amp;#39;);</span>\n                }\n                config.headers[&amp;<span class=\"comment\">#39;Authorization&amp;#39;] = &quot;Bearer &quot; + jwt;</span>\n                <span class=\"keyword\">return</span> <span class=\"variable\">$q</span>.when(config);\n            },\n        }\n    };\n}());\n</code></pre>\n<p>上面新建了一个 <code>tokenInjector</code>，之后我们这样使用就可以了:</p>\n<pre><code class=\"lang-javascript\"><span class=\"variable\">$httpProvider</span>.interceptors.push(tokenInjector);\n</code></pre>\n<p>作用就是实现每次请求都自动把 token 添加到 header 的 Aturhorization 中。除此之外还可以做好多好多东西，这里就不详细介绍下去了。</p>\n<h2 id=\"-ui-router-ngroute\">使用 ui-router 替代 ngRoute</h2>\n<p>自从用了 ui-router 就再也回不去 ngRoute 了，ui-router 使用状态来进行转移，支持多视图和嵌套视图，使用方法更加灵活，并且也有更加丰富的 API。多视图，嵌套视图你知道意味什么吧，这些 ngRoute 做不到，官方现在也是主推 ui-router，前段时间 ui-router 已经出了新的 1.0 版本，相信大部分开发者还是在用老版本吧，可以考虑迁移了，想要了解新版本的迁移事项看<a href=\"https://ui-router.github.io/guide/ng1/migrate-to-1_0\">这里</a>。</p>\n<p>对于还在使用 ngRoute 的童鞋，我也强烈建议你去使用 ui-router。</p>\n<p>多视图和嵌套视图就不多说了，除此之外还有比较强大实用的地方就是 ui-router 提供的生命周期钩子即 <code><span class=\"variable\">$stateChangeStart</span></code>, <code><span class=\"variable\">$stateChangeSuccess</span></code>, <code><span class=\"variable\">$stateChangeError</span></code>，ngRoute 不知道有没有，没有去了解过。下面举个粟子说下用法：</p>\n<pre><code class=\"lang-javascript\"><span class=\"variable\">$rootScope</span>.<span class=\"variable\">$on</span>(&quot;<span class=\"variable\">$stateChangeStart</span>&quot;, <span class=\"keyword\">function</span> (event, toState, toStateParams, fromState, fromStateParams) {\n    <span class=\"variable\">$rootScope</span>.loading = <span class=\"keyword\">true</span>;\n});\n<span class=\"variable\">$rootScope</span>.<span class=\"variable\">$on</span>(&quot;<span class=\"variable\">$stateChangeSuccess</span>&quot;, <span class=\"keyword\">function</span> (event, toState, toStateParams, fromState, fromParams) {\n  <span class=\"keyword\">if</span>(ga) {\n    let re = /\\{(.*?)}/g, url;\n    <span class=\"keyword\">if</span>(Object.keys(toStateParams).length &gt; <span class=\"number\">0</span>) {\n      url = toState.url.replace(re, Object.values(toStateParams).reduce((pre, curr) =&gt; curr));\n    } <span class=\"keyword\">else</span> {\n      url = toState.url;\n    }\n    ga(&amp;<span class=\"comment\">#39;send&amp;#39;, &amp;#39;pageview&amp;#39;, url);</span>\n  }\n  <span class=\"variable\">$rootScope</span>.loading = <span class=\"keyword\">false</span>;\n});\n<span class=\"variable\">$rootScope</span>.<span class=\"variable\">$on</span>(&quot;<span class=\"variable\">$stateChangeError</span>&quot;, <span class=\"keyword\">function</span> (event, toState, toStateParams, fromState, fromParams, error) {\n  <span class=\"variable\">$rootScope</span>.loading = <span class=\"keyword\">false</span>;\n});\n</code></pre>\n<p>其实上面应该时比较 tricky 的做法，作用就是全局视图切换动画以及让 google analysis 工作，从 <code>stateChangeStart</code> 开始，<code>isLoading</code> 变为 true 直到 <code>stateChangeSuccess</code> 的时候变为 false。我们把 <code>isLoading</code> 挂在 <code><span class=\"variable\">$rootScope</span></code> 上面方便使用，用这个变量就可以判断是否加载一个 Loading 的 DOM。</p>\n<p>其次，由于单页应用特性，google analysis 只被加载一次从而无法实时反馈用户当前所访问的页面，我们可以手动进行调用，上面就是用法了，也是每次在成功状态变化之后发送当前 url。</p>\n<p>不过遗憾的是这个 API 在 ui-router 1.0 版本废弃了，不过 ui-router 1.0 目录下带了另一个文件，引入这个文件即可以继续使用。我猜测 ui-router 1.0 应该是有更好的解决方案来替代它，详细的可以自己去了解下。</p>\n<p>另外还想说的一个地方就是 ui-router 的 resolve 功能，允许我们在控制器初始化之前先获取和处理数据，如果 resolve 的东西是一个 promise，如果 promise 状态为 rejected，那么视图就不会被成功切换。基于此我们可以把视图需要的一些 HTTP 请求放到 ui-router 的 resolve 上面来做，然后再注入到控制器给控制器使用，并且这样还可以避免数据未到达时视图的数据显示问题以及数据请求失败后的问题。举个粟子：</p>\n<pre><code class=\"lang-javascript\">.state(&amp;<span class=\"comment\">#39;posts&amp;#39;, {</span>\n  url: &amp;<span class=\"comment\">#39;/posts/:type&amp;#39;,</span>\n  templateUrl: &amp;<span class=\"comment\">#39;posts/posts_tpl.html&amp;#39;,</span>\n  controller: &amp;<span class=\"comment\">#39;PostsController as vm&amp;#39;,</span>\n  resolve: {\n    posts: <span class=\"keyword\">function</span>(Posts, <span class=\"variable\">$stateParams</span>, <span class=\"variable\">$q</span>) {\n      let defer = <span class=\"variable\">$q</span>.defer();\n      <span class=\"keyword\">if</span>([&amp;<span class=\"comment\">#39;unread&amp;#39;, &amp;#39;mark&amp;#39;].indexOf($stateParams.type) !== -1) {</span>\n        defer.resolve(Posts.get({type: <span class=\"variable\">$stateParams</span>.type}).<span class=\"variable\">$promise</span>);\n      } <span class=\"keyword\">else</span> {\n        defer.reject(&amp;<span class=\"comment\">#39;参数不正确&amp;#39;);</span>\n      }\n      <span class=\"keyword\">return</span> defer.promise;\n    },\n  }\n})\n</code></pre>\n<p>这是一个路由的状态，这里应用了 promise 的反模式，其实我自己也不是特别了解，之前看到一篇文章再批评这个。我回去学习下再补充。</p>\n<p>这个地方的作用就是判断 state 传进的参数是否符合要求，如果不符合要求则无法加载，符合要求的话就会去请求资源，如果请求失败的话视图也不会被加载，即状态不会切换成功，如果请求成功我们可以再控制器依赖注入 <code>posts</code> 取得返回结果。</p>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"Angular-最佳实践总结 (一).md","link":"/post/Angular-最佳实践总结 (一).html"},{"title":"Angular1之折腾记","date":"2016-09-24T23:40:50.000Z","categories":"Angular","tags":["Angular","JavaScript"],"content":"<p>前几天 Angular2 正式发布了，虽然他也在我的学习计划里面，但我并没有把他应用在我最近开展的一个项目中。最近在写一个 Rss 订阅器，基于 Angular1 和 Koa2(总感觉两个有点不搭 =.= )，主要是不想在这个项目花太长时间，再者我还想集我目前掌握的所有技术之大成写一个能拿的出手的项目，所以就没有选择 Angular2 了。至于 Koa2，其实很早就想学了，只是之前一直在忙别的。</p>\n<h2 id=\"angular-resource-\">angular-resource 介绍</h2>\n<p>今天捣鼓 Angular 的 Resource 功能，前端后端都掌握在自己的手上时去用 Angular 的 Resource 特别舒服，大大减少了代码量，特么强大。</p>\n<pre><code class=\"lang-js\">(<span class=\"keyword\">function</span>() {\n    angular\n        .module(&amp;<span class=\"comment\">#39;app&amp;#39;)</span>\n        .factory(&amp;<span class=\"comment\">#39;Post&amp;#39;, $resource =&gt; {</span>\n            <span class=\"keyword\">return</span> <span class=\"variable\">$resource</span>(&amp;<span class=\"comment\">#39;/api/feed/:feed_id/post/:id&amp;#39;, {id: &amp;#39;@_id&amp;#39;}, {</span>\n                update: {method: &amp;<span class=\"comment\">#39;PUT&amp;#39;},</span>\n                get: {method: &amp;<span class=\"comment\">#39;GET&amp;#39;, cache: true}</span>\n            });\n        })\n}());\n</code></pre>\n<p>在上面我定义了一个 <code>Post</code> 资源，一旦创建完成后，他就自动拥有了以下方法。</p>\n<pre><code class=\"lang-js\">{\n    &amp;<span class=\"comment\">#39;get&amp;#39;: {method: &amp;#39;GET&amp;#39;},</span>\n    &amp;<span class=\"comment\">#39;save&amp;#39;: {method: &amp;#39;POST&amp;#39;},</span>\n    &amp;<span class=\"comment\">#39;query&amp;#39;: {method: &amp;#39;GET&amp;#39;, isArray: true},</span>\n    &amp;<span class=\"comment\">#39;remove&amp;#39;: {method: &amp;#39;DELETE&amp;#39;},</span>\n    &amp;<span class=\"comment\">#39;delete&amp;#39;: {method: &amp;#39;DELETE&amp;#39;}</span>\n}\n</code></pre>\n<p>有些 IE 浏览器可能不支持 <code>delete</code>，这时候可以使用 <code>remove</code>。\n我们还可以自定义或者修改里面的方法，比如我上面中就自定义了一个 <code>update</code> 方法以及给 <code>get</code> 方法开启了缓存。</p>\n<p>那怎么使用呢？也很简单，如果对 <code>restfulAPI</code> 比较熟悉应该很容易理解。</p>\n<pre><code class=\"lang-js\"><span class=\"variable\">$stateProvider</span>\n    .state(&amp;<span class=\"comment\">#39;feed.post&amp;#39;, {</span>\n          url: &amp;<span class=\"comment\">#39;/post/:post_id&amp;#39;,</span>\n          templateUrl: &amp;<span class=\"comment\">#39;post/post_tpl.html&amp;#39;,</span>\n          controller: &amp;<span class=\"comment\">#39;PostController as vm&amp;#39;,</span>\n          resolve: {\n              post: <span class=\"keyword\">function</span>(Post, <span class=\"variable\">$stateParams</span>, <span class=\"variable\">$state</span>) {\n                  <span class=\"keyword\">return</span> Post.get({feed_id: <span class=\"variable\">$stateParams</span>.id, id: <span class=\"variable\">$stateParams</span>.post_id}).<span class=\"variable\">$promise</span>;\n              }\n          }\n      })\n</code></pre>\n<p>这里就调用了 <code>get</code> 方法，同时把参数传入，这样就好了。其他方法其实一样的。\n<code>resource</code> 也有很多功能。</p>\n<pre><code class=\"lang-js\"><span class=\"variable\">$resource</span>(url, [paramDefaults], [actions], options);\n</code></pre>\n<p>第二个参数设置默认参数用，比如我们发起了一个 <code>get</code> 请求得到数据，这条数据有一个 <code>_id</code> 属性，我们可以把他绑定为默认的 <code>id</code> 参数，这样在之后执行该资源的其他方法时我们可以不指定 <code>id</code>。\n第三个参数就是自定义方法的地方了，前面我给 <code>get</code> 方法升级了下，是这样的，这个也就是第三个参数了。</p>\n<pre><code class=\"lang-js\"><span class=\"variable\">$resource</span>(&amp;<span class=\"comment\">#39;/api/feed/:feed_id/post/:id&amp;#39;, {id: &amp;#39;@_id&amp;#39;}, {</span>\n    update: {method: &amp;<span class=\"comment\">#39;PUT&amp;#39;},</span>\n    get: {method: &amp;<span class=\"comment\">#39;GET&amp;#39;, cache: true}</span>\n});\n</code></pre>\n<p>格式是这样的：</p>\n<pre><code class=\"lang-js\">{action1: {method:?, params:?, isArray:?, headers:?, ...},\n action2: {method:?, params:?, isArray:?, headers:?, ...},\n ...}\n</code></pre>\n<p>更多说明参考<a href=\"https://docs.angularjs.org/api/ngResource/service/$resource\">官方文档</a>咯。\n第四个参数没看明白，可以自己看下官方文档。</p>\n<h2 id=\"angular-resource-\">angular-resource 缓存问题</h2>\n<p>上一个项目没有用 angular-resource 的时候，我就在 factory 里面缓存 response，下次请求时直接返回该 response。由于用户所操作的和所缓存的都是同一个对象，因此在进行一些对该 response 的修改时比如，用户进行点赞操作，那么我除了发出一个请求之外，我还要将 response 里的是否点赞的值修改过来，这样视图才能反映出来，由于和缓存是同一份东西，因此实现了缓存的同步变化。\n但不知道是不是这种方式容易导致缓存被破坏还是怎么样，我看了下 angular 以及 angular-resource 的部分源码，发现 angular 在处理 http 缓存时对数据进行了 serialize 操作，而且第一次返回给用户的并不是缓存的结果，而是自己 resource 里面的东西，下次访问时才从缓存取出来后 deserialize 后返回。 \n关于这个问题其实老早就有人发出 issue 了，但官方并没有回应，目前比较好的解决方案就是在修改资源时，删除缓存。可以这样操作:</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> <span class=\"variable\">$httpDefaultCache</span> = <span class=\"variable\">$cacheFactory</span>.get(&amp;<span class=\"comment\">#39;$http&amp;#39;);</span>\n<span class=\"variable\">$httpDefaultCache</span>.remove(key)；\n<span class=\"comment\">// The cache key is the request URL including search parameters;</span>\n</code></pre>\n<p>那有没有更好的办法呢，其实我也想过，有想到用缓存数据替代返回到控制器的数据，然而从这个尝试开始就发现了很多很坑的地方。\n我在 httpInjector 里面拦截 response 加入了这么一段代码</p>\n<pre><code class=\"lang-javascript\">setTimeout(() =&gt; {\n     <span class=\"comment\">// 只对 resource 的 cache 进行处理</span>\n     <span class=\"keyword\">if</span>(config.config &amp;&amp; config.config.cache === <span class=\"keyword\">true</span>) {\n         let url = config.config.url;\n         <span class=\"variable\">$cacheFactory</span>.get(&amp;<span class=\"comment\">#39;$http&amp;#39;).get(url)[1] = angular.fromJson($cacheFactory.get(&amp;#39;$http&amp;#39;).get(url)[1]);</span>\n         config.resource.data = <span class=\"variable\">$cacheFactory</span>.get(&amp;<span class=\"comment\">#39;$http&amp;#39;).get(url)[1].data;</span>\n         config.config.data = <span class=\"variable\">$cacheFactory</span>.get(&amp;<span class=\"comment\">#39;$http&amp;#39;).get(url)[1].data;</span>\n         config.data = <span class=\"variable\">$cacheFactory</span>.get(&amp;<span class=\"comment\">#39;$http&amp;#39;).get(url)[1].data;</span>\n         console.log(<span class=\"variable\">$cacheFactory</span>.get(&amp;<span class=\"comment\">#39;$http&amp;#39;).get(url));</span>\n     }\n });\n</code></pre>\n<p>作用就时强制 serialize 缓存的数据，然后讲全部数据都替换成缓存中的数据，由于在这一阶段并没有开始缓存，所以要设置 setTimeout 推迟操作。\n这样做了之后，对第一次加载仍然没有什么影响，但第二次加载时就开始起作用了，更改会同步变化到缓存，其实就是之后用的就直接是缓存的对象，而不再是 deserialize 化后的数据，这一步应该归功于我修改了缓存中数据的存储形式。\n由于第一次返回给控制器的数据并不是从缓存取出来的，而是从 resource 里面取出来的即上面的 <code>config.resource.data</code>，所以我也把他改到缓存中的对象去。为了更好说明问题，我把控制器代码也贴上来。我的目的就是进行 mark 操作后缓存也会自动同步过来。</p>\n<pre><code class=\"lang-javascript\">(<span class=\"keyword\">function</span>() {\n    angular\n        .module(&amp;<span class=\"comment\">#39;app&amp;#39;)</span>\n        .controller(&amp;<span class=\"comment\">#39;PostController&amp;#39;, PostController);</span>\n\n    <span class=\"keyword\">function</span> PostController(<span class=\"variable\">$state</span>, post, Post, <span class=\"variable\">$scope</span>, _, <span class=\"variable\">$rootScope</span>, <span class=\"variable\">$timeout</span>, <span class=\"variable\">$cacheFactory</span>) {\n        <span class=\"keyword\">var</span> vm = <span class=\"keyword\">this</span>;\n        vm.post = post;\n\n        vm.mark = mark;\n\n        vm.currentPost = post.data.result;\n        vm.currentPostDetail = post.data.detail;\n\n        <span class=\"keyword\">function</span> mark() {\n            vm.currentPostDetail.mark = !vm.currentPostDetail.mark;\n            Post.update({feed_id: vm.currentPost.feed_id[<span class=\"number\">0</span>], id: vm.currentPost._id}, {type: &amp;<span class=\"comment\">#39;mark&amp;#39;});</span>\n        }\n    }\n}());\n</code></pre>\n<p>按理说，控制器初始化的时候 <code>post</code> 是一个 resource 对象，我在 <code>setTimeout</code> 中修改了 resource 内部的数据，指向到缓存中被 serialize 化的数据。而 <code>vm.currentPost</code> 和 <code>vm.currentPostDetail</code> 又是分别指向 <code>post.data.result</code> 和 <code>post.data.detail</code>，应该我在 <code>vm</code> 上面的操作可以影响到缓存才对，然而并不能。试试看修改 <code>mark</code> 方法。</p>\n<pre><code class=\"lang-javascript\"><span class=\"keyword\">function</span> mark() {\n    vm.currentPostDetail.mark = !vm.currentPostDetail.mark;\n    post.data.detail.mark = !post.data.detail.mark;\n    Post.update({feed_id: vm.currentPost.feed_id[<span class=\"number\">0</span>], id: vm.currentPost._id}, {type: &amp;<span class=\"comment\">#39;mark&amp;#39;, revert: true});</span>\n}\n</code></pre>\n<p>也就是加了一句话，更改 <code>post</code> 中的数据。结果是工作了！这说明 post 确实此时是指向缓存的。那 <code>vm.currentPostDetail</code> 也是指向 <code>post.data.detail</code> 的，为什么它不工作？\n其实这不是 angular 的锅，console 试试下面就知道了。</p>\n<pre><code class=\"lang-javascript\">pre = {status: <span class=\"number\">200</span>, result: {detail: {a:<span class=\"number\">1</span>}, result: {b:<span class=\"number\">2</span>}}};\nctrl = pre.result.detail;        <span class=\"comment\">// {a:1}</span>\ncache = {status: <span class=\"number\">200</span>, result: {detail: {a:<span class=\"number\">2</span>}, result: {b:<span class=\"number\">3</span>}}};\npre = cache;\nconsole.log(ctrl);                <span class=\"comment\">// {a:1}</span>\n</code></pre>\n<p>应该不止我一个人会认为最后结果应该是 <code>{a: 2}</code> 吧...其实上面还可以再简化成这样</p>\n<pre><code class=\"lang-javascript\">a = {a:<span class=\"number\">1</span>};\nb = a;\na = {a:<span class=\"number\">2</span>};\nconsole.log(b);        <span class=\"comment\">// {a:1}</span>\n</code></pre>\n<p>画一个图的话是这样子的。\n{% asset_img object.png object %}\n这样应该就明了了，所以由于控制器第一次取到的 response 一定是 resource 内部的结果，而 httpInjector 是在返回 response 前进行修改，因此我们无法通过 httpInjector 来达到目的。唯一能做到的方法就是让控制器接受到的结果与缓存指向同一内存，假设 $cacheFactory 缓存 http 的结果没有被序列化，那么将 resource 中的数据加入缓存，同时把这个数据返回给控制器，就实现了控制器数据和缓存数据指向一致的目的，所以最终问题还是在 $cacheFactory 把结果给序列化了再存储。\n为了验证下我们的说法，可以修改下 angular 源码下面的地方:</p>\n<pre><code class=\"lang-javascript\"><span class=\"keyword\">function</span> done(status, response, headersString, statusText) {\n    <span class=\"keyword\">if</span> (cache) {\n        <span class=\"keyword\">if</span> (isSuccess(status)) {\n        cache.put(url, [status, response, parseHeaders(headersString), statusText]);\n        } <span class=\"keyword\">else</span> {\n        <span class=\"comment\">// remove promise from the cache</span>\n        cache.remove(url);\n        }\n    }\n\n    <span class=\"keyword\">function</span> resolveHttpPromise() {\n        resolvePromise(response, status, headersString, statusText);\n    }\n\n    <span class=\"keyword\">if</span> (useApplyAsync) {\n        <span class=\"variable\">$rootScope</span>.<span class=\"variable\">$applyAsync</span>(resolveHttpPromise);\n    } <span class=\"keyword\">else</span> {\n        resolveHttpPromise();\n        <span class=\"keyword\">if</span> (!<span class=\"variable\">$rootScope</span>.$<span class=\"variable\">$phase</span>) <span class=\"variable\">$rootScope</span>.<span class=\"variable\">$apply</span>();\n    }\n}\n</code></pre>\n<p>把这一行</p>\n<pre><code class=\"lang-javascript\">cache.put(url, [status, response, parseHeaders(headersString), statusText]);\n</code></pre>\n<p>改为</p>\n<pre><code class=\"lang-javascript\">cache.put(url, [status, angular.fromJson(response), parseHeaders(headersString), statusText]);\n</code></pre>\n<p>之后就会发现，从第二次开始缓存的数据就会同步变更了，因为存的是对象，所以下次从缓存取的时候就直接用的对象，所以就可以保持数据的同步了。但第一次还是不行，我也没有再深究下去了，源码有点绕，看不太懂。\n另外，过程中曾经有想利用 <code><span class=\"variable\">$stateChangeStart</span></code> 和 <code><span class=\"variable\">$stateChangeSuccess</span></code> 着手，但是发现这两个事件没有效果，查了资料才知道，<code>ui-router</code> 的新版本(1.0)已经有较大的变化，不再支持上面的事件，而是转而通过 <code><span class=\"variable\">$transition</span></code> 来操作。如果你还在用老版本的 <code>ui-router</code>，可以试试看这个新版本的，迁移可以参考<a href=\"https://ui-router.github.io/guide/ng1/migrate-to-1_0#state-change-events\">这里</a>。</p>\n<p>花了好几个小时想尝试解决这个问题都没搞定，现在还是搞不懂为什么 angular 要把数据序列化后缓存，是为了数据的稳定吗？如果可以提供一个 option 来设置不是很好吗？不知道有没有什么解决方案，一直没找着，貌似是因为缓存的数据就不应该被修改，但在一些场景它还是有应用用途的吧。</p>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"Angular1之折腾记.md","link":"/post/Angular1之折腾记.html"},{"title":"提升网站加载速度的 N 个方法","date":"2016-09-11T13:53:33.000Z","categories":"还不知道分什么类好","tags":["Web","HTTP","JavaScript"],"content":"<p>Web 这几年的一个变化之一估计就是各种优化小技巧不断涌出...自己也琢磨和尝试了不少优化，毕竟自己项目的网页首屏加载也是一度接近 2M 的。以下针对 HTTP1 和 HTTP1.1，在 HTTP2 中，很多最佳实践都适得其反了。</p>\n<h2 id=\"-\">减少文件传输数量</h2>\n<p>现在前端代码发布上线的时候一般都会进行压缩，混淆，合并等操作，他们起到了减少文件体积和数量以及混淆代码降低可读性的作用。</p>\n<p>浏览器针对同一域名的并发请求数目是有限制的，而在 HTTP1 和 HTTP1.1 中每传输一个资源就得建立一条连接。因此当网站的请求资源数量过多时，会导致后面资源请求的阻塞，也会导致频繁的连接建立和关闭带来的开销。一般浏览器的并发请求数量在4-8之间。因此我们针对同一域名的资源不宜过多，否则就会导致后面资源的阻塞。</p>\n<p>针对该问题，我们可以采用合并文件，将资源分到不同域名，缓加载资源，提前加载资源，缓存等手段。具体如下：</p>\n<ol>\n<li>合并文件以减少并发请求数量\n合并文件也不能简单粗暴的合并为一个，对于长时间不会改变的文件我们要单独合并出来，这个文件是可以进行长期缓存的，而一些变动较为频繁的我们就不应该和上面的这些文件合并在一起，并且他们也不应该设置过激的缓存策略。</li>\n<li>将次要文件延迟加载，比如 Google Analysis\n一些无关痛痒的文件可以放到页面最尾部，这是最佳实践，这里特别想提一下 async 和 defer，他们并没有对文件的请求产生影响，只是影响了执行的过程，所以我们不应该使用 async 或者 defer 方法来优化。\n{% asset_img async-defer.jpg async-defer %}\n使用 async，会立即开始并行加载，加载完成后会进行执行并阻塞主渲染进程。\n使用 defer，会立即开始并行加载，但会延迟到最后才执行。</li>\n<li>分散资源到不同域名\n比如图片有专门的域名(img.xxx.com)来存储。一些资源可以考虑第三方 CDN 比如 Bootcss 的 CDN，因为这类 CDN 使用较广，有可能用户浏览器已经有过缓存，这就避免了再次请求和加载，同时也减轻了服务器压力。</li>\n<li>使用雪碧图(css sprites)来合并小图片\n这个优化技术其实挺常见，将图片合并为一个后使用 background-image 和 background-position 等来控制显示雪碧图的哪一部分就好了，据说还可以自动生成雪碧图自动定位。</li>\n<li>利用 200 缓存\n这是一个比较极端的缓存方式，200 缓存时浏览器不发出网络请求，直接调用本地缓存，这需要强制浏览器使用本地缓存。我们可以使用 Expires 标志。即给出日期时间，超出该时间后则认为是过时，浏览器才会重新发起请求。这个具体细节我还不太了解。过后补充。</li>\n<li>使用懒加载(lazy load)\n很多网站特别是有大量图片的网站都会使用该技术。当用户下滑页面时，才开始加载下面的图片。一来减少了页面加载的请求数和加载时间，二来也减少用户流量。不过可能有人会说这样体验不太好，好在业内有人把这个技术做到了堪称极致的地步，就是预先加载一个高度压缩的原图，然后淡出原图。大家应该有体验到类似的技术，就不多说了。</li>\n<li><p>使用预加载技术(prefetch)\n这个技术知道的人可能不多，MDN 上面是这样解释的：</p>\n<blockquote>\n<p>页面资源预加载(Link prefetch)是浏览器提供的一个技巧，目的是让浏览器在空闲时间下载或预读取一些文档资源，用户在将来将会访问这些资源。一个Web页面可以对浏览器设置一系列的预加载指示，当浏览器加载完当前页面后，它会在后台静悄悄的加载指定的文档，并把它们存储在缓存里。当用户访问到这些预加载的文档后，浏览器能快速的从缓存里提取给用户。</p>\n</blockquote>\n<p>不过资源预加载其实使用的并不多，可能是因为技术本身不成熟，浏览器支持不够等原因。目前没有发现有哪个网站使用了这个技术。感兴趣的自己去了解下，这里不多阐述这个技术。</p>\n</li>\n<li>集中加载资源\n额，这个名字是我自己起的，姑且我认为也是一种优化手段，主要针对的时 SPA。比如 Angular 搭建的 SPA。Angular 提供了 templateCache 这个模块。这个在前面的博客中已经介绍过，简单说就是一个数组，我们把模板全部都预先放入这个数组中。Angular 在请求页面的时候会先检查 templateCache 是否已经缓存了，如果有则直接调用这个缓存的模板，否则发出网络请求获取该模板，同时会放入 templateCache 中缓存。有人可能会问那不是增加了首屏加载的体积大小了吗？的确，但比起用户每点击一个新的页面就发起一个请求而言，这种方式无疑会更适合不是吗？并且如果你的文件确实太大了，那你应该考虑下你是否充分利用了指令功能。</li>\n</ol>\n<h2 id=\"-\">减少文件大小</h2>\n<p>除了减少文件数量，减少文件大小也同样重要，不过比起合并文件这样简单的减少文件数量的操作，减少文件大小就没来的那么简单了。常用的方法如下：</p>\n<ol>\n<li><p>开启 GZIP 压缩\nGZIP 压缩应用非常广泛，因其可以有效明显的减少文件的体积。在 Nginx 中，我们可以很简单的进行配置开启 GZIP 压缩。</p>\n<pre><code class=\"lang-bash\">gzip on;\ngzip_vary on;\ngzip_comp_level 4;\ngzip_buffers 16 8K;\ngzip_min_length 1k;\ngzip_proxied any;\ngzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\ngzip_disable &quot;MSIE [1-6]\\.&quot;;\n</code></pre>\n<p>这是我项目服务器上面 Nginx 关于 gzip 的配置。我们关心的当然还是压缩前后文件大小的差异，找别人的一个图贴下：\n{% asset_img gzip_comp_level.png gzip_comp_level %}\n可以看到效果还是很明显的，一般 GZIP 等级不宜高于 4 级。因为压缩意味着浏览器下载后还需要解压，所以压缩等级过高反而会带来性能问题（移动端耗电增加）甚至是降低页面渲染（解压占用CPU影响页面渲染且耗时）。\n另外，大文件压缩效果更明显，所以合并文件后再压缩会比分开压缩效果要好。</p>\n</li>\n<li><p>使用 WebP 格式图片\nWebP 是 Google 推出的一种同时提供有损压缩与无损压缩的图片文件格式。根据 Google 较早的测试，无损压缩后的 WebP 比 PNG 文件少了45%的文件大小，即使这些 PNG 文件经过其他压缩工具压缩之后，WebP 还是可以减少28%的文件大小。\n{% asset_img WebP.png WebP %}\nWebP 在互联网上已经非常流行，主流浏览器都已经支持，并且国内也有大量站点如淘宝网，腾讯网，QQ空间等等都使用了这一格式。另外，针对不支持的浏览器，也可以引入相应的 shim 解决。\n{% asset_img WebP支持情况.png WebP支持情况 %}</p>\n</li>\n<li><p>书写压缩友好的代码\n这个对开发人员就要较高的要求了，并且如果不是对文件体积有很大的要求一般都不会做到这一步。在代码压缩的过程有一步就是进行变量替换，举一个前面博客中的例子来说</p>\n<pre><code class=\"lang-javascript\"><span class=\"keyword\">var</span> ArrayProto = <span class=\"keyword\">Array</span>.prototype, ObjProto = Object.prototype;\n<span class=\"keyword\">var</span> SymbolProto = typeof Symbol !== &amp;<span class=\"comment\">#39;undefined&amp;#39; ? Symbol.prototype : null;</span>\n<span class=\"keyword\">var</span> push = ArrayProto.push,\n slice = ArrayProto.slice,\n toString = ObjProto.toString,\n hasOwnProperty = ObjProto.hasOwnProperty;\n</code></pre>\n<p> <code><span class=\"keyword\">Array</span>.prototype.push</code> 是无法压缩的，而如果我们赋值 <code>ArrayProto = <span class=\"keyword\">Array</span>.prototype</code> ，那么 <code>ArrayProto</code> 就可以被替换掉，同理，上面中的 <code>push</code>, <code>slice</code> 等都是对压缩友好的。除此之外，一般的压缩工具还会把 <code>undefined</code>  都替换为 <code>void 0</code>，一来可以避免 <code>underfined</code> 重写的问题，二来字符数少了。目前我比较清楚的就这两个，有兴趣的话可以去了解下压缩的过程，对比下压缩前后。</p>\n</li>\n<li><p>避免引入无用代码\n有一种比较常见的场景是我们使用了 FontAweSome 等的文件后，虽然我们可以很方便的通过写 CSS 类名来添加修改图标，但我们用到的毕竟时少数图标，所以其他没有用到的图标的引入就是非必须的。这个我自己没有实践过，可以看看<a href=\"http://stackoverflow.com/questions/15331525/optimize-font-awesome-for-only-used-classes\">Optimize Font Awesome for only used classes</a>这里的讨论。\n除了去做筛选之外，还有的办法就是我们不要引入整个图标文件，有些提供图标的网站可以让你自己选择需要的图标后以字体和 CSS 文件的形式下载下来。这样做就稍微麻烦一点，不过既然你要图文件小，那麻烦一点也没什么。</p>\n</li>\n</ol>\n<h2 id=\"-web-\">其他 Web 提速手段</h2>\n<p>前面集中就文件请求数和文件体积开展讨论，其实还远远不止上面这些办法。常用的还有以下这些。</p>\n<ol>\n<li><p>dns-prefetch\n这个其实和前面说的资源预加载差不多，只是这个是 DNS 预解析。用户访问一个新的域名之前，会首先通过 DNS 解析得到他的 IP 地址，之后才开始建立连接。DNS 解析也是需要时间的，而这个技术的作用就是在用户页面空闲的时候去预获取 IP 地址并缓存，这样当访问该域名页面的时候，就不需要再解析域名，从而缩短了页面加载时间。\n{% asset_img dns-prefetch.png 淘宝网 dns-prefetch %}</p>\n</li>\n<li><p>Preconnect\n这个和上面差不多，但是不光会解析 DNS 还会建立 TCP 握手连接和 TLS 协议(如果需要的话)用法如下：</p>\n<pre><code class=\"lang-html\">&lt;link rel=&quot;preconnect&quot; href=&quot;https:<span class=\"comment\">//ruiming.github.io&quot;&gt;</span>\n</code></pre>\n<p>但是这个的支持还比较一般，我也没找到有谁使用了这个技术。\n{% asset_img preconnect.png preconnect %}\n其实类似的预xx技术还挺多，还有预渲染等，感兴趣的可以参考<a href=\"http://www.alloyteam.com/2015/10/prefetching-preloading-prebrowsing/\">此处</a></p>\n</li>\n<li><p>使用第三方 CDN\n前面也有稍微提了下 CDN。对于 CDN 的使用应该根据实际情况来，如果整个页面就只引入了两三个第三方库，我们可以考虑使用公共 CDN 比如 Bootcss 的 CDN。其一是真的很快，比七牛什么都快好多，其二是用的人多，可能用户浏览器已经缓存了，另外 Bootcss 的 CDN 默认使用 HTTP2，在支持 HTTP2 的浏览器中，他也可以避免影响我们网站资源并发请求数量的问题，当然如果你也是用 HTTP2 这个问题就不大了。\n如果不使用公共 CDN，对于个人也可以使用七牛或者其他的提供的 CDN 存储。CDN 的好处在可以根据用户位置就近分配资源，同时也可以减轻服务器压力。</p>\n</li>\n</ol>\n<hr>\n<p>参考资料：\nWebP 探寻之路: <a href=\"https://isux.tencent.com/introduction-of-webp.html\">https://isux.tencent.com/introduction-of-webp.html</a>\n一箩筐的预加载技术: <a href=\"http://www.alloyteam.com/2015/10/prefetching-preloading-prebrowsing\">http://www.alloyteam.com/2015/10/prefetching-preloading-prebrowsing</a></p>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"提升网站加载速度的-N 个方法.md","link":"/post/提升网站加载速度的-N 个方法.html"},{"title":"浅谈 Angular 脏检查","date":"2016-09-04T14:57:22.000Z","categories":"Angular","tags":["Angular"],"content":"<p>Angular 的脏值检查机制一直是 Angular 被人诟病的地方，但瑕不掩瑜，Angular 还是一个非常优秀的框架，并且 Angular2 也已经抛弃了这个脏值检查的算法。\n最近在看《AngularJS 深度剖析与最佳实践》，不得不说是一本很好的书籍，作者在第三章开始讲背后的原理，这里分析了 Angular 的 $digest 函数，即脏检查机制。所以自己也去下载了 Angular 最新的源码去瞧了下，然后做下笔记吧。</p>\n<p>首先要注意，Angular 的 digest 的触发不是定时的，只有在指定的事件触发之后才会进入 $digest。基本上我们用的带 <code>$</code> 的东西调用之后都可能会触发 digest。比如我们使用 <code>setTimeout</code> 就不会触发 digest，即当你使用 <code>setTimeout</code> 更改 viewmodel 的值后，它不会同步的反映到用户的视图中去，解决方法有两个，一个是使用 Angular 提供的 <code><span class=\"variable\">$timeout</span></code> 替代 <code>setTimeout</code>，<code><span class=\"variable\">$timeout</span></code> 会在执行结束之后自动触发 digest； 另一个方法是手动调用 $apply，$apply 是 Angular 对 digest 的一层封装，我们一般不会直接调用 digest 而是通过使用 $apply 方法。比如对于 <code>setTimeout</code>，我们就可以这样触发 digest。</p>\n<pre><code class=\"lang-javascript\">setTimeout(() =&gt; {\n  <span class=\"variable\">$scope</span>.<span class=\"variable\">$apply</span>(() =&gt; {\n    <span class=\"variable\">$scope</span>.test = <span class=\"number\">123</span>;\n  })    \n}, <span class=\"number\">500</span>);\n</code></pre>\n<p>我们看一个例子，这也是 Angular 源码 $digest 部分的一个示例。</p>\n<pre><code class=\"lang-javascript\"><span class=\"keyword\">var</span> scope = ...;\nscope.name = &amp;<span class=\"comment\">#39;misko&amp;#39;;</span>\nscope.counter = <span class=\"number\">0</span>;\n\nexpect(scope.counter).toEqual(<span class=\"number\">0</span>);\nscope.<span class=\"variable\">$watch</span>(&amp;<span class=\"comment\">#39;name&amp;#39;, function(newValue, oldValue){</span>\n  scope.counter = scope.counter + <span class=\"number\">1</span>;\n});\nexpect(scope.counter).toEqual(<span class=\"number\">0</span>);\n\n<span class=\"comment\">// 执行第一次 digest，第一次 digest 会遍历全部的 watcher，并触发上面的方法，从而使的 count+1</span>\nscope.<span class=\"variable\">$digest</span>();\nexpect(scope.counter).toEqual(<span class=\"number\">1</span>);\n\n<span class=\"comment\">// 第二次调用时，由于上一次调用检查 name 不脏，所以不会再去处理</span>\nscope.<span class=\"variable\">$digest</span>();\nexpect(scope.counter).toEqual(<span class=\"number\">1</span>);\n\n<span class=\"comment\">// 第三次调用时，由于 name 发生了变化，使得当前值和上一次保存的值不同，所以会触发起 $watch 方法</span>\nscope.name = &amp;<span class=\"comment\">#39;adam&amp;#39;;</span>\nscope.<span class=\"variable\">$digest</span>();\nexpect(scope.counter).toEqual(<span class=\"number\">2</span>);\n</code></pre>\n<p>Angular 的脏值检查过程大致如下：\n对当前作用域和子作用域上的 <code>$<span class=\"variable\">$watchers</span></code> 进行遍历，<code>$<span class=\"variable\">$watches</span></code> 保存着 scope 上的所有变量以及其 <code><span class=\"variable\">$watch</span></code> 方法，调用时会取当前值和上一次值进行比较，如果不相等则会调用 <code><span class=\"variable\">$watch</span></code> 方法，同时会保存当前的值以在下一次进行比较，并且记录此次检查结果为脏。然后重复进行直到数据不脏为止，因此至少要 digest 两次，超出 10 次会报错，可以调高这个次数限制。当数据不再脏即 model 稳定下来之后， Angular 才会开始一次性批量更新 UI。从而减少了浏览器的 repaint 次数，提升性能。</p>\n<p>深入到源码来看：</p>\n<pre><code class=\"lang-javascript\"><span class=\"variable\">$digest</span>: <span class=\"keyword\">function</span>() {\n  <span class=\"keyword\">var</span> watch, value, last, fn, get,\n      watchers,\n      length,\n      dirty, ttl = TTL,\n      next, current, target = <span class=\"keyword\">this</span>,\n      watchLog = [],\n      logIdx, asyncTask;\n\n  beginPhase(&amp;<span class=\"comment\">#39;$digest&amp;#39;);</span>\n  <span class=\"variable\">$browser</span>.$<span class=\"variable\">$checkUrlChange</span>();\n\n  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> === <span class=\"variable\">$rootScope</span> &amp;&amp; applyAsyncId !== <span class=\"keyword\">null</span>) {\n    <span class=\"variable\">$browser</span>.defer.cancel(applyAsyncId);\n    flushApplyAsync();\n  }\n\n  lastDirtyWatch = <span class=\"keyword\">null</span>;\n\n  <span class=\"keyword\">do</span> {\n    dirty = <span class=\"keyword\">false</span>;\n    current = target;\n\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> asyncQueuePosition = <span class=\"number\">0</span>; asyncQueuePosition &lt; asyncQueue.length; asyncQueuePosition++) {\n      <span class=\"keyword\">try</span> {\n        asyncTask = asyncQueue[asyncQueuePosition];\n        asyncTask.scope.<span class=\"variable\">$eval</span>(asyncTask.expression, asyncTask.locals);\n      } <span class=\"keyword\">catch</span> (e) {\n        <span class=\"variable\">$exceptionHandler</span>(e);\n      }\n      lastDirtyWatch = <span class=\"keyword\">null</span>;\n    }\n    asyncQueue.length = <span class=\"number\">0</span>;\n\n    <span class=\"comment\">// 脏值检查开始</span>\n    traverseScopesLoop:\n    <span class=\"keyword\">do</span> {\n      <span class=\"comment\">// 获取当前 scope 的 $$watchers</span>\n      <span class=\"keyword\">if</span> ((watchers = current.$<span class=\"variable\">$watchers</span>)) {\n        <span class=\"comment\">// process our watches</span>\n        <span class=\"comment\">// 遍历执行这些 watches</span>\n        length = watchers.length;\n        <span class=\"keyword\">while</span> (length--) {\n          <span class=\"keyword\">try</span> {\n            watch = watchers[length];\n            <span class=\"keyword\">if</span> (watch) {\n              get = watch.get;\n              <span class=\"keyword\">if</span> ((value = get(current)) !== (last = watch.last) &amp;&amp;\n                  !(watch.eq\n                      ? equals(value, last)\n                      : (typeof value === &amp;<span class=\"comment\">#39;number&amp;#39; &amp;&amp; typeof last === &amp;#39;number&amp;#39;</span>\n                         &amp;&amp; isNaN(value) &amp;&amp; isNaN(last)))) {\n                           <span class=\"comment\">// 优先使用 === 判断 value 和 last，其次再是根据他们是否为数字做 ng 的深度相等判断或者 isNaN 判断</span>\n                dirty = <span class=\"keyword\">true</span>;\n                lastDirtyWatch = watch;\n                <span class=\"comment\">// 如果 watch.eq 为 true，表示该 watch 的目标为对象，所以把该对象克隆到 watch.last 上面以下一次 digest 时来判断</span>\n                <span class=\"comment\">// 如果 watch.eq 为 false，表示该 watch 的目标为数字，所以直接赋值就可以了</span>\n                <span class=\"comment\">// 这里和上面一样都是为了提高速度和性能用</span>\n                watch.last = watch.eq ? copy(value, <span class=\"keyword\">null</span>) : value;\n                <span class=\"comment\">// 获取该 watch 的表达式并执行</span>\n                fn = watch.fn;\n                <span class=\"comment\">// 如果 last 和最开始的值相同则使用后者，否则使用前者。</span>\n                fn(value, ((last === initWatchVal) ? value : last), current);\n                <span class=\"keyword\">if</span> (ttl &lt; <span class=\"number\">5</span>) {\n                  logIdx = <span class=\"number\">4</span> - ttl;\n                  <span class=\"keyword\">if</span> (!watchLog[logIdx]) watchLog[logIdx] = [];\n                  watchLog[logIdx].push({\n                    msg: isFunction(watch.exp) ? &amp;<span class=\"comment\">#39;fn: &amp;#39; + (watch.exp.name || watch.exp.toString()) : watch.exp,</span>\n                    newVal: value,\n                    oldVal: last\n                  });\n                }\n              } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (watch === lastDirtyWatch) {\n                dirty = <span class=\"keyword\">false</span>;\n                <span class=\"keyword\">break</span> traverseScopesLoop;\n              }\n            }\n          } <span class=\"keyword\">catch</span> (e) {\n            <span class=\"variable\">$exceptionHandler</span>(e);\n          }\n        }\n      }\n\n      <span class=\"comment\">// Insanity Warning: scope depth-first traversal</span>\n      <span class=\"comment\">// yes, this code is a bit crazy, but it works and we have tests to prove it!</span>\n      <span class=\"comment\">// this piece should be kept in sync with the traversal in $broadcast</span>\n      <span class=\"comment\">// 对当前 scope 的子 scope 做遍历</span>\n      <span class=\"keyword\">if</span> (!(next = ((current.$<span class=\"variable\">$watchersCount</span> &amp;&amp; current.$<span class=\"variable\">$childHead</span>) ||\n          (current !== target &amp;&amp; current.$<span class=\"variable\">$nextSibling</span>)))) {\n        <span class=\"keyword\">while</span> (current !== target &amp;&amp; !(next = current.$<span class=\"variable\">$nextSibling</span>)) {\n          current = current.<span class=\"variable\">$parent</span>;\n        }\n      }\n    } <span class=\"keyword\">while</span> ((current = next));\n\n    <span class=\"comment\">// 脏值检查未结束但此时 ttl 为 0，则抛出错误</span>\n    <span class=\"keyword\">if</span> ((dirty || asyncQueue.length) &amp;&amp; !(ttl--)) {\n      clearPhase();\n      <span class=\"keyword\">throw</span> <span class=\"variable\">$rootScopeMinErr</span>(&amp;<span class=\"comment\">#39;infdig&amp;#39;,</span>\n          &amp;<span class=\"comment\">#39;{0} $digest() iterations reached. Aborting!\\n&amp;#39; +</span>\n          &amp;<span class=\"comment\">#39;Watchers fired in the last 5 iterations: {1}&amp;#39;,</span>\n          TTL, watchLog);\n    }\n\n    <span class=\"comment\">// 循环遍历直到 dirty 为 false 并且 asyncQueue.length = 0</span>\n  } <span class=\"keyword\">while</span> (dirty || asyncQueue.length);\n\n  clearPhase();\n\n  <span class=\"comment\">// 执行 postDigest 序列</span>\n  <span class=\"keyword\">while</span> (postDigestQueuePosition &lt; postDigestQueue.length) {\n    <span class=\"keyword\">try</span> {\n      postDigestQueue[postDigestQueuePosition++]();\n    } <span class=\"keyword\">catch</span> (e) {\n      <span class=\"variable\">$exceptionHandler</span>(e);\n    }\n  }\n  postDigestQueue.length = postDigestQueuePosition = <span class=\"number\">0</span>;\n}\n</code></pre>\n<p>不过这段代码我也不是全都理解了，但是核心的算了解了。总体来看这个算法还是很简单粗暴的，这里保留了一段注释，有意思，官方吐槽的感觉。</p>\n<p>由于脏检查的性能问题，在页面绑定数据较多的时候，我们应该尽量减少双向绑定的数量，比如使用 <code>ngInfiniteScroll</code> 这样的插件，适当使用单向绑定，甚至是取消一些变量的 watch 方法。</p>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"浅谈-Angular 脏检查.md","link":"/post/浅谈-Angular 脏检查.html"},{"title":"项目采坑笔记","date":"2016-08-15T16:37:19.000Z","categories":"Angular","tags":["Angular","JavaScript"],"content":"<p>有段时间没写博客了，前段时间在看 Underscore 源码所以写的多了点，这段时间还是在忙自己的其他项目去了，还是有不少收获的。</p>\n<h2 id=\"angular-\">Angular 视图过渡动画</h2>\n<p>之前使用 <code>angular-promise-button</code> 这个模块实现了按钮的自动变化，以前自己是用很多标志位来判断特别二。不仅如此，页面切换动画也是用标志位判断，这样就特别不好维护特别不优雅，上次重构的时候就把这些全部去掉了。但是问题来了，页面数据未到达时候页面就渲染肯定会造成视觉上的问题，怎么解决呢。\n我们都想写一些应用很广的代码，比如指令，比如上面这个 <code>angular-promise-button</code> 模块等等。其实要解决上面的问题，也是几行代码就可以解决的事情了。\n我所使用的是 Angular 的 ui-router。ngRoute 应该也差不多。\n在 ui-router 中可以使用 resolve 达到在控制器初始化以及视图加载前确保数据到达。比如：</p>\n<pre><code class=\"lang-js\"><span class=\"variable\">$stateProvider</span>\n    .state(&amp;<span class=\"comment\">#39;me&amp;#39;,{</span>\n        url: &amp;<span class=\"comment\">#39;/me&amp;#39;,</span>\n        controller: &amp;<span class=\"comment\">#39;MeCtrl&amp;#39;,</span>\n        templateUrl: &amp;<span class=\"comment\">#39;me/me_tpl.html&amp;#39;,</span>\n        controllerAs: &amp;<span class=\"comment\">#39;vm&amp;#39;,</span>\n        nav: <span class=\"keyword\">true</span>,\n        resolve: {\n            me: <span class=\"keyword\">function</span>(userservice) {\n                <span class=\"keyword\">return</span> userservice.getUserInfo()\n                    .then(response =&gt; response);\n            }\n        }\n    })\n</code></pre>\n<p>只有 resolve 中的全部方法执行完后，才会开始初始化控制和加载视图。这个数据如果在控制器或者视图中要使用，可以在控制器中进行依赖注入。例如上面这个我的控制器是这样写的：</p>\n<pre><code class=\"lang-js\">(<span class=\"keyword\">function</span>(){\n    &amp;<span class=\"comment\">#39;use strict&amp;#39;;</span>\n\n    angular\n        .module(&amp;<span class=\"comment\">#39;index&amp;#39;)</span>\n        .controller(&amp;<span class=\"comment\">#39;MeCtrl&amp;#39;, MeCtrl);</span>\n\n    MeCtrl.<span class=\"variable\">$inject</span> = [&amp;<span class=\"comment\">#39;me&amp;#39;];</span>\n\n    <span class=\"keyword\">function</span> MeCtrl(me) {\n        let vm = <span class=\"keyword\">this</span>;\n        vm.user = me;\n    }\n}());\n</code></pre>\n<p>resolve中的方法是阻塞页面进行的，这样就会带来问题了，如果数据请求比较久将导致网站停滞，我们这时候就希望可以有过渡动画出来。要达到全局过渡效果的作用，可以直接监听 <code><span class=\"variable\">$rootScope</span></code> 中的三个状态即 <code><span class=\"variable\">$stateChangeStart</span></code> 和 <code><span class=\"variable\">$stateChangeSuccess</span></code> 以及 <code><span class=\"variable\">$stateChangeError</span></code> 事件。例如上面这个例子中，当我们触发 <code>me</code> 这个 state 时，也就触发了 $rootScope 上的 <code><span class=\"variable\">$stateChangeStart</span></code> 事件，当处理结束后将出发 <code><span class=\"variable\">$stateChangeSuccess</span></code> 并加载视图， 处理失败就会触发 <code><span class=\"variable\">$stateChangeError</span></code> 事件。代码如下：</p>\n<pre><code class=\"lang-js\">    angular\n        .module(&amp;<span class=\"comment\">#39;index&amp;#39;, [</span>\n            &amp;<span class=\"comment\">#39;ui.router&amp;#39;,</span>\n            &amp;<span class=\"comment\">#39;ui.bootstrap&amp;#39;,</span>\n            &amp;<span class=\"comment\">#39;ngAnimate&amp;#39;,</span>\n            &amp;<span class=\"comment\">#39;ngSanitize&amp;#39;,</span>\n            &amp;<span class=\"comment\">#39;ngTouch&amp;#39;,</span>\n            &amp;<span class=\"comment\">#39;infinite-scroll&amp;#39;,</span>\n            &amp;<span class=\"comment\">#39;angularPromiseButtons&amp;#39;</span>\n        ])\n        .config(config)\n        .run((<span class=\"variable\">$state</span>,<span class=\"variable\">$rootScope</span>) =&gt; {\n            <span class=\"variable\">$rootScope</span>.<span class=\"variable\">$state</span> = <span class=\"variable\">$state</span>;\n            <span class=\"variable\">$rootScope</span>.<span class=\"variable\">$on</span>(&quot;<span class=\"variable\">$stateChangeStart</span>&quot;, (event, toState, toStateParams, fromState, fromStateParams) =&gt; {\n                <span class=\"keyword\">var</span> isLoading = toState.resolve;\n                <span class=\"keyword\">if</span>(!isLoading) {\n                    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> prop in toState.views) {\n                        <span class=\"keyword\">if</span> (toState.views.hasOwnProperty(prop)) {\n                            <span class=\"keyword\">if</span>(toState.views[prop].resolve) {\n                                isLoading = <span class=\"keyword\">true</span>;\n                                <span class=\"keyword\">break</span>;\n                            }\n                        }\n                    }\n                }\n                <span class=\"keyword\">if</span> (isLoading) {\n                    <span class=\"variable\">$rootScope</span>.loading = <span class=\"keyword\">true</span>;\n                }\n            });\n            <span class=\"variable\">$rootScope</span>.<span class=\"variable\">$on</span>(&quot;<span class=\"variable\">$stateChangeSuccess</span>&quot;, (event, toState, toParams, fromState, fromParams) =&gt; {\n                <span class=\"variable\">$rootScope</span>.loading = <span class=\"keyword\">false</span>;\n            });\n            <span class=\"variable\">$rootScope</span>.<span class=\"variable\">$on</span>(&quot;<span class=\"variable\">$stateChangeError</span>&quot;, (event, toState, toParams, fromState, fromParams, error) =&gt; {\n                <span class=\"variable\">$rootScope</span>.loading = <span class=\"keyword\">false</span>;\n            });\n        });\n</code></pre>\n<p>入口页面，省去了其他代码，这里第一行就是视图，第二行是加载动画，通过ng-show来控制显示。第三行是引入导航栏，这个在后面会说下。</p>\n<pre><code class=\"lang-html\">&lt;div ui-view <span class=\"keyword\">class</span>=&quot;uiview&quot; ng-show=&quot;!<span class=\"variable\">$root</span>.loading&quot;&gt;&lt;/div&gt;\n&lt;div <span class=\"keyword\">class</span>=&quot;cssload-thecube&quot; ng-show=&quot;<span class=\"variable\">$root</span>.loading&quot;&gt; loading... &lt;/div&gt;\n&lt;div ng-show=&quot;<span class=\"variable\">$state</span>.current.nav&quot; ng-<span class=\"keyword\">include</span>=&quot;&amp;<span class=\"comment\">#39;navbar/navbar_tpl.html&amp;#39;&quot;&gt;&lt;/div&gt;</span>\n</code></pre>\n<p>可以看到上面的代码中是监听了 <code><span class=\"variable\">$stateChangeStart</span></code> 事件，然后获取目标 state 上的 resolve 方法，当 state 上的 resolve 方法全部结束后，<code><span class=\"variable\">$rootScope</span>.loading</code> 设置为 false，否则保持为 true。\n当监听到 <code><span class=\"variable\">$stateChangeSuccess</span></code> 或者 <code><span class=\"variable\">$stateChangeError</span></code> 事件时，置 <code><span class=\"variable\">$rootScope</span>.loading</code> 为 false，退出过渡动画。在视图中可以使用 <code><span class=\"variable\">$root</span></code> 得到 <code><span class=\"variable\">$rootScope</span></code>。\n可以看到这里有很多参数，可见其功能是很强大的。</p>\n<p>再看下上面这个第三行</p>\n<pre><code class=\"lang-html\">&lt;div ng-show=&quot;<span class=\"variable\">$state</span>.current.nav&quot; ng-<span class=\"keyword\">include</span>=&quot;&amp;<span class=\"comment\">#39;navbar/navbar_tpl.html&amp;#39;&quot;&gt;&lt;/div&gt;</span>\n</code></pre>\n<p>结合上面的 JS 代码来看，我已经把 <code><span class=\"variable\">$state</span></code> 注入到了 <code><span class=\"variable\">$rootScope</span></code> 中了，之后我就可以使用 <code><span class=\"variable\">$state</span>.current</code> 来获取当前的视图状态和信息。我需要实现导航栏仅仅出现在我指定的页面中，下方按钮可以根据当前视图来激活。第一点可以通过给路由 state 补充变量比如我这里的 <code>nav</code> 来实现，需要导航栏的地方就设置 <code>nav</code> 为 true, 否则就不设置。第二点则可以利用 <code>ui-sref-active</code> 来实现。如下：</p>\n<pre><code class=\"lang-html\">&lt;!-- navbar/navbar_tpl.html --&gt;\n&lt;nav <span class=\"keyword\">class</span>=&quot;bookist-nav navbar navbar-<span class=\"keyword\">default</span>&quot; role=&quot;navigation&quot;&gt;\n    &lt;ul <span class=\"keyword\">class</span>=&quot;nav navbar-nav&quot;&gt;\n        &lt;li ui-sref-active=&quot;active&quot;&gt;&lt;a ui-sref=&quot;index&quot;&gt;&lt;i <span class=\"keyword\">class</span>=&quot;fa fa-home fa-lg&quot;&gt;&lt;/i&gt;&lt;p&gt;首页&lt;/p&gt;&lt;/a&gt;&lt;/li&gt;\n        &lt;li ui-sref-active=&quot;active&quot;&gt;&lt;a ui-sref=&quot;booklists&quot;&gt;&lt;i <span class=\"keyword\">class</span>=&quot;fa fa-th-large fa-lg&quot;&gt;&lt;/i&gt;&lt;p&gt;书单&lt;/p&gt;&lt;/a&gt;&lt;/li&gt;\n        &lt;li ui-sref-active=&quot;active&quot;&gt;&lt;a ui-sref=&quot;cart&quot;&gt;&lt;i <span class=\"keyword\">class</span>=&quot;fa fa-shopping-cart fa-lg&quot;&gt;&lt;/i&gt;&lt;p&gt;购物车&lt;/p&gt;&lt;/a&gt;&lt;/li&gt;\n        &lt;li ui-sref-active=&quot;active&quot;&gt;&lt;a ui-sref=&quot;me&quot;&gt;&lt;i <span class=\"keyword\">class</span>=&quot;fa fa-user fa-lg&quot;&gt;&lt;/i&gt;&lt;p&gt;我的&lt;/p&gt;&lt;/a&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/nav&gt;\n</code></pre>\n<p>最后还有一个地方就是，下面这个代码</p>\n<pre><code class=\"lang-html\">&lt;div ui-view <span class=\"keyword\">class</span>=&quot;uiview&quot; ng-show=&quot;!<span class=\"variable\">$root</span>.loading&quot;&gt;&lt;/div&gt;\n</code></pre>\n<p>ui-view 的用法其实还不少，如果你有去注意的话，会看到这个视图在变化的时候其类名会变化，依次我们可以结合 angular-animate 来实现切换动画。注意这个切换动画是在视图加载后才开始的，和上面的不一样，如果同时使用，则会在上方过渡效果结束后触发。例如，我们可以实现淡入淡出：</p>\n<pre><code class=\"lang-css\">.uiview {\n  &amp;.ng-enter {\n    transition: .5s;\n    opacity: 0;\n  }\n  &amp;.ng-enter-active {\n    opacity: 1;\n  }\n}\n</code></pre>\n<p>所以上面其实说了好几点：</p>\n<ul>\n<li>使用路由上的 resolve 来实现在控制器初始化前获取到需要的数据</li>\n<li>监听 $rootScope 上的事件来实现 resolve 等待动画</li>\n<li>在 ui-view 上通过使用 angular-animate 来实现视图的切换动画</li>\n<li>通过 ui-sref-active 在当 ui-sref 和当前 state 一致时激活 active 类名</li>\n<li>把 $state 注入到 $rootScope 达到在视图中获取 $state 用途</li>\n<li>使用 $root 得到 $rootScope，利用 $root 获取 $rootScope 上的对象</li>\n</ul>\n<h2 id=\"-\">静态资源自动发布七牛云</h2>\n<p>这个很简单啦，我使用了 gulp-qiniu 这个模块来实现，很简单，结合前面说的 gulp-usemin 就更完美了。</p>\n<pre><code class=\"lang-html\">&lt;!-- build:js <span class=\"comment\">//cdn.bookist.org/bookist.min.js --&gt;</span>\n&lt;script src=&quot;src/js/bookist.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;src/js/templates.js&quot;&gt;&lt;/script&gt;\n&lt;!-- endbuild --&gt;\n</code></pre>\n<p>例如对上面 index.html 中的这一片段，我们要在开发环境中使用本地资源，而在线上环境则使用 CDN 资源。我们可以这样配置 gulpfile。</p>\n<pre><code>gulp.task(&amp;<span class=\"comment\">#39;cdn&amp;#39;, () =&gt; {</span>\n    gulp.src(&amp;<span class=\"comment\">#39;index.html&amp;#39;)</span>\n        .pipe(usemin())\n        .pipe(gulp.dest(&amp;<span class=\"comment\">#39;backend/app/templates&amp;#39;));</span>\n    gulp.src([&amp;<span class=\"comment\">#39;./src/js/bookist.js&amp;#39;, &amp;#39;./src/js/templates.js&amp;#39;])</span>\n        .pipe(plumber())\n        .pipe(uglify())\n        .pipe(babel())\n        .pipe(concat(&amp;<span class=\"comment\">#39;bookist.min.js&amp;#39;))</span>\n        .pipe(qiniu({\n            accessKey: &quot;xxx&quot;,\n            secretKey: &quot;xxx&quot;,\n            bucket: &quot;bookist&quot;,\n            <span class=\"keyword\">private</span>: <span class=\"keyword\">false</span>\n        }));\n}\n</code></pre><p>运行上面的任务后就会在 <code>backend/app/templates</code> 生成一个修改过的 index.html。对于上面的片段，处理之后是这样的：</p>\n<pre><code>&lt;script src=&quot;<span class=\"comment\">//cdn.bookist.org/bookist.min.js&quot;&gt;&lt;/script&gt;</span>\n</code></pre><p>前面的注释是给 usemin 使用的，所以要按照规范书写。\n同时上面的任务也会把资源发布到七牛云上面，如果你还想指定文件头或者版本号之类的信息，可以参考 gulp-qiniu 的文档进行配置。\n上面的方法有一个小问题就是还会在 <code>backend/app/templates</code> 生成一个 <code>cdn.bookist.org</code> 的文件夹，不过无所谓咯，放到 .gitignore 就好了。\n至于图片和 css 都差不多吧，就不多说了。</p>\n<h2 id=\"-\">微信坑逼</h2>\n<p>有段时间我的网站在微信显示部分地方是有问题的，但在手机浏览器和电脑都没任何问题，一开始以为是样式的问题。等到自己要去解决这个问题了，才知道是 js 的问题。\n由于微信开发工具不支持 linux，然后我虚拟机的 win10 有不知道什么原因一直连接不到手机。所以就手动调试了，这边改一点，发布上去，然后等微信缓存没了看效果(微信恶心的缓存...我都叫用苹果的人帮我看，因为苹果可以刷新..)。就这样一步步看，最后定位了问题代码。中间过程就不描述了，直接看：</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">for</span>(let book of books) {\n    <span class=\"keyword\">if</span>(book.rate)   book.star = Math.ceil(book.rate/<span class=\"number\">2</span>);\n    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(book.star)   book.star = Math.ceil(book.star/<span class=\"number\">2</span>);\n}\n</code></pre>\n<p>省略了无关代码，这是一个方法里面的部分代码，如果一个对象传入这个方法中，在微信会得不到返回值，在手机浏览器和电脑上都正常。\n虽然这里使用了 ES6 的语法，但是我其实已经大量使用 let...of... 语句，项目并没有出现太大问题，就只是上面描述的一些地方异常而已。再者我使用了 babel 转码了。越想越觉得没道理啊。。。\n最后虚拟机换了 win7 然后手机连接上了，打开了微信开发工具，调试微信 webview，报错 <code>Symbol is not defined</code>。\n果断控制台敲 Symbol，结果 <code>Symbol is not defined</code>。\n好吧，问题出来了，微信这个辣鸡不支持 Symbol...\n但问题是我没有用 Symbol 这个东西啊，我瞄了 babel 一眼。\n看下上面那段代码转码的结果：</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> _iteratorNormalCompletion5 = <span class=\"keyword\">true</span>;\n<span class=\"keyword\">var</span> _didIteratorError5 = <span class=\"keyword\">false</span>;\n<span class=\"keyword\">var</span> _iteratorError5 = undefined;\n\n<span class=\"keyword\">try</span> {\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> _iterator5 = books[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = <span class=\"keyword\">true</span>) {\n        <span class=\"keyword\">var</span> book = _step5.value;\n\n        <span class=\"keyword\">if</span> (book.rate) book.star = Math.ceil(book.rate / <span class=\"number\">2</span>);<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (book.star) book.star = Math.ceil(book.star / <span class=\"number\">2</span>);\n    }\n} <span class=\"keyword\">catch</span> (err) {\n    _didIteratorError5 = <span class=\"keyword\">true</span>;\n    _iteratorError5 = err;\n} finally {\n    <span class=\"keyword\">try</span> {\n        <span class=\"keyword\">if</span> (!_iteratorNormalCompletion5 &amp;&amp; _iterator5.<span class=\"keyword\">return</span>) {\n            _iterator5.<span class=\"keyword\">return</span>();\n        }\n    } finally {\n        <span class=\"keyword\">if</span> (_didIteratorError5) {\n            <span class=\"keyword\">throw</span> _iteratorError5;\n        }\n    }\n</code></pre>\n<p>什么鬼...算了，不看了，但是确定了是 babel 转码导致的。然后查了下资料：</p>\n<blockquote>\n<p>Babel默认只转换新的JavaScript句法(syntax)，而不转换新的API，比如Iterator, Generator, Set, Maps, Proxy, Reflect, Symbol, Promise等全局对象，以及一些定义在全局对象上的方法(比如Object.assign)都不会转码。</p>\n</blockquote>\n<p>其实早有耳闻 polyfill 这个东西，但我想他一般是用在 IE 这种辣鸡浏览器上的，没想到微信 webview 这么不争气。\n多打包一个 babel-polyfill 解决了这个问题。\n坑比微信...</p>\n<p>故事还没结束...\n昨天发现网站并没有使用 http2，但是已经进行了设置了，最后查了很多资料原因好像是 openssl 的问题，但由于使用的是 docker，貌似不太好搞，但其实更换 nginx 版本就好了，原先是1.9版本，换成1.11-alpine 版就解决了，用 docker 更换 nginx 版本非常方便。额，具体原因不深究了，可能跟 alpine 这个字眼有关？不清楚...\nhttp2 具备多路复用的特点，在 http1.1 中，并行传输文件是有限制的，因为用户端和服务端的最大连接数是有限制的，而连接的建立和销毁又会带来开销，所以在 http1.1 中对文件进行压缩合并是很有必要的。不过在 http2 就不需要这样做了，http2 可以在一条通道上传输多个文件，如果合并剩几个，就没法发挥并行传输的优势，而且文件太大，还会降低运输层的效率，即丢包或者乱序到达的影响。\n我把网站改到了 http2 后，就不再进行文件合并了，转而可以大量使用 bootcss 的 CDN，bootcss 的 CDN 支持 http2，传输很快。至于上面没有的和自己写的，就发布到七牛云上面。恩，电脑上加载是变快了很多。\n但是感觉不到微信加载变快...最后发现是微信不支持 http2...\n好伤心...\n最后我的方案是产生两个 css 文件和两个 js 文件，之所以是两个，因为一个是自己写的，经常变，另一个是用别人的，几乎不会变。</p>\n<p>最后又发现微信好像支持 spdy... 心好累，算了，降了 nginx 版本开启 spdy 不理了。</p>\n<hr>\n<p>总结：</p>\n<ul>\n<li>Angular 是一个大而全的框架，我觉得很强大很牛逼，越来越喜欢 Angular 了</li>\n<li>使用 CDN 可以大大的加速，尽量使用 CDN</li>\n<li>微信这个坑比我就不说了，不支持 Symbol 不支持 http2</li>\n<li>能用 http2 就尽量用 http2</li>\n<li>考虑浏览器兼容性，根据需要引入 babel-polyfill</li>\n</ul>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"项目采坑笔记.md","link":"/post/项目采坑笔记.html"},{"title":"浅谈 JavaScript 模块定义规范","date":"2016-08-06T22:28:35.000Z","categories":"JavaScript","tags":["JavaScript"],"content":"<p>JS 模块定义常见的有三种方式，即 AMD, CMD 和 CommonJS。其实还有一个 UMD，他是 CommonJS 和 AMD 揉和在一起而已。不过这些都 out 了，拥抱 ES6 吧。话虽这么说，你让那些不用 ES6 不用 babel 的怎么活，所以还是要了解下滴。</p>\n<h2 id=\"commonjs\">CommonJS</h2>\n<p>CommonJS 是服务端即 Node.js 采用的模块化方案，我们应该都很熟悉了。例如：</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">const</span> fs = <span class=\"keyword\">require</span>(&amp;<span class=\"comment\">#39;fs&amp;#39;);</span>\nfs.readFileSync();\n</code></pre>\n<p>这个过程是同步的，只有成功加载 <code>fs</code> 后才能执行后面的步骤。但在服务器文件都在本地，所以这个问题不大。但这个在浏览器就不合适了，如果文件加载耗时很长，将导致一直等待。</p>\n<h2 id=\"amd\">AMD</h2>\n<p>AMD 全称 Asynchronous Module Definition，意思就是异步模块定义。\n用法如下：</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">require</span>([&amp;<span class=\"comment\">#39;math&amp;#39;], function(math) {</span>\n    math.add(<span class=\"number\">1</span>, <span class=\"number\">2</span>);\n});\n</code></pre>\n<p>math 模块的加载和 <code>math.add()</code> 方法的执行不是同步的，这样浏览器就不会假死。\nRequireJs 和 CurlJs 实现了 AMD 规范，将他们嵌入网页，就可以在浏览器端进行模块化编程了。\n关于 AMD 的详细模块定义可以参考<a href=\"https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88\">wiki</a>)。这里给出 Underscore 的 AMD 定义方法：</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">if</span> (typeof define == &amp;<span class=\"comment\">#39;function&amp;#39; &amp;&amp; define.amd) {</span>\n    define(&amp;<span class=\"comment\">#39;underscore&amp;#39;, [], function() {</span>\n        <span class=\"keyword\">return</span> _;\n    });\n}\n</code></pre>\n<h2 id=\"cmd\">CMD</h2>\n<p>CMD 全称 Common Module Definition，意思就是通用模块定义。。\n对于依赖的模块，AMD 是提前执行，而 CMD 是延迟执行。AMD 推崇依赖前置，而 CMD 则推崇依赖就近。例如：</p>\n<pre><code class=\"lang-js\">define(<span class=\"keyword\">function</span>(<span class=\"keyword\">require</span>, exports, module) {\n    <span class=\"keyword\">const</span> math = <span class=\"keyword\">require</span>(&amp;<span class=\"comment\">#39;./math&amp;#39;);</span>\n    math.add(<span class=\"number\">1</span>, <span class=\"number\">2</span>);\n});\n</code></pre>\n<p>CMD 的主要实现是 SeaJS\nAMD 预先加载所有依赖，使用的时候才去执行，速度快，可以并行加载多个模块。但这就需要开发的时候把全部依赖都提前定义，不便于开发和阅读，而且部分依赖（弱依赖）可能只在少数情况下使用。\nCMD 只有在真正需要的时候才去加载依赖，使用的时候才去定义执行，但这个加载逻辑偏重，耗性能。</p>\n<h2 id=\"umd\">UMD</h2>\n<p>UMD 全称 Universal Module Definition。\nUMD 是 AMD 和 CommonJS 的揉和，他优先使用 CommonJS 的加载方式，其次才使用 AMD 的加载方式。\n例如：</p>\n<pre><code class=\"lang-js\">(<span class=\"keyword\">function</span> (window, factory) {\n    <span class=\"keyword\">if</span> (typeof exports === &amp;<span class=\"comment\">#39;object&amp;#39;) {</span>\n\n        module.exports = factory();\n    } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (typeof define === &amp;<span class=\"comment\">#39;function&amp;#39; &amp;&amp; define.amd) {</span>\n\n        define(factory);\n    } <span class=\"keyword\">else</span> {\n\n        window.eventUtil = factory();\n    }\n})(<span class=\"keyword\">this</span>, <span class=\"keyword\">function</span> () {\n    <span class=\"comment\">//module ...</span>\n});\n</code></pre>\n<p>其实就是一个服务端和浏览端通用的模块解决方案。</p>\n<h2 id=\"es6-module\">ES6 Module</h2>\n<p>ES6 在语言规格的层面上实现了模块功能，并且实现非常简单，完全可以替代现有的模块加载方案，成为浏览器和服务端都通用的模块解决方案。</p>\n<pre><code class=\"lang-js\">import {stat, exists, readFile} from &amp;<span class=\"comment\">#39;fs&amp;#39;;</span>\n</code></pre>\n<p>这种做法将只在 fs 模块加载3个方法，其他方法不会进行加载。ES6 可以在编译时就完成模块加载，效率比 CommonJS 的加载方式高。\n在浏览器中使用 ES6 模块的语法：</p>\n<pre><code class=\"lang-html\">&lt;script type=&quot;module&quot; src=&quot;foo.js&quot;&gt;&lt;/script&gt;\n</code></pre>\n<p>目前 Node 默认模块格式是 CommonJS，ES6 的模块方案还不支持，但可以通过 babel 来使用。</p>\n<p>现在推荐做法是广泛使用 ES6 甚至 ES7 来书写 JavaScript 以提高开发效率，再使用 babel 转码就好了。所以前后端我们也都可以使用 ES6 的 Module 来进行。其他的模块加载方案应该会渐渐退出历史舞台。</p>\n<hr>\n<p><a href=\"http://es6.ruanyifeng.com/#docs/module\">ECMAScript6 入门 Module</a></p>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"浅谈JavaScript模块定义规范.md","link":"/post/浅谈JavaScript模块定义规范.html"},{"title":"Underscore 源码学习(七)","date":"2016-08-06T15:53:18.000Z","categories":"Underscore","tags":["Underscore","JavaScript"],"content":"<p>Underscore 中间 flatten 相关的方法之前一直不是很理解，现在完全搞懂了，稍微说一下。</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> flatten = <span class=\"keyword\">function</span>(input, shallow, strict, output) {\n    output = output || [];\n    <span class=\"keyword\">var</span> idx = output.length;\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, length = getLength(input); i &lt; length; i++) {\n        <span class=\"keyword\">var</span> value = input[i];\n        <span class=\"comment\">// 若value为数组，把里面东西去出来赋值给output</span>\n        <span class=\"comment\">// 否则直接赋值给output</span>\n        <span class=\"comment\">// isArrayLike的判断可以去掉，保留的原因是因为他用来判断value是否为数组很快，可以迅速筛选掉非数组</span>\n        <span class=\"keyword\">if</span> (isArrayLike(value) &amp;&amp; (_.isArray(value) || _.isArguments(value))) {\n        <span class=\"comment\">// Flatten current level of array or arguments object.</span>\n        <span class=\"keyword\">if</span> (shallow) {\n            <span class=\"comment\">// 如果给了shallow参数，只只遍历一层</span>\n            <span class=\"keyword\">var</span> j = <span class=\"number\">0</span>, len = value.length;\n            <span class=\"keyword\">while</span> (j &lt; len) output[idx++] = value[j++];\n        } <span class=\"keyword\">else</span> {\n            <span class=\"comment\">// 一直遍历下去，如果是元素则按下面赋值，如果是数组则继续遍历</span>\n            flatten(value, shallow, strict, output);\n            idx = output.length;\n        }\n        } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!strict) {\n        output[idx++] = value;\n        }\n    }\n    <span class=\"keyword\">return</span> output;\n};\n</code></pre>\n<p>这个方法不难看懂，作用是将input平铺展开，如果 <code>shallow</code> 为 <code><span class=\"keyword\">true</span></code>，则只展开一层。</p>\n<pre><code class=\"lang-js\">_.flatten([<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">3</span>], [[<span class=\"number\">4</span>, [<span class=\"number\">5</span>]]]])              <span class=\"comment\">// [1, 2, 3, 4, 5]</span>\n_.flatten([<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">3</span>], [[<span class=\"number\">4</span>, [<span class=\"number\">5</span>]]]], <span class=\"keyword\">true</span>)        <span class=\"comment\">// [1, 2, 3, [4, [5]]]</span>\n</code></pre>\n<p>这里的 <code>strict</code> 参数就是之前一直卡住的原因，就是下面这个地方：</p>\n<pre><code class=\"lang-js\">_.without = restArgs(<span class=\"keyword\">function</span>(<span class=\"keyword\">array</span>, otherArrays) {\n    <span class=\"keyword\">return</span> _.difference(<span class=\"keyword\">array</span>, otherArrays);\n});\n\n_.difference = restArgs(<span class=\"keyword\">function</span>(<span class=\"keyword\">array</span>, rest) {\n    rest = flatten(rest, <span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>);\n    <span class=\"comment\">// 遍历array，如果array中一个元素包含在rest中，则去掉该元素</span>\n    <span class=\"keyword\">return</span> _.filter(<span class=\"keyword\">array</span>, <span class=\"keyword\">function</span>(value){\n        <span class=\"keyword\">return</span> !_.contains(rest, value);\n    });\n});\n</code></pre>\n<p>这是两个方法，那时候想 <code>without</code> 方法调用的时候, <code>otherArrays</code>是一个数组了，到 <code>difference</code> 方法的时候，这个数组去调用 <code>flatten</code> 方法的时候不是会出问题吗？</p>\n<pre><code class=\"lang-js\">_.flatten([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>)        <span class=\"comment\">// []</span>\n</code></pre>\n<p>脑子里面就这样想...卡了好久，等我基本看了全部源码才会过来看才理解了。\n<code>difference</code> 方法的 <code>restArgs</code> 很重要，他们两个是各自独立的方法，但是 <code>without</code> 可以共用 <code>difference</code> 的逻辑。\n上面那样子理解是有问题的，因为在 <code>without</code> 方法中 <code>otherArrays</code> 如果是[1, 2, 3]，到了 <code>flatten</code> 调用的时候因为 <code>restArgs</code> 的关系他变成了 [[1, 2, 3]]，调用最后返回结果[1, 2, 3]。然后我就纳闷了，加了一层又解除这是何解...\n不过抛开 <code>without</code> 方法去看 <code>difference</code> 方法就能理解了。</p>\n<pre><code class=\"lang-js\">_.without([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>], <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);\n<span class=\"comment\">// 1, 2, 3通过restArgs变为[1, 2, 3]，传入difference方法</span>\n<span class=\"comment\">// [1, 2, 3]通过restArgs变为[[1, 2, 3]]，传入flatten方法</span>\n<span class=\"comment\">// 返回[1, 2, 3]，剩下的可以看懂了不解释</span>\n<span class=\"comment\">// 之所以shallow和strict都为true，是因为不需要两个数组即使内容一样他们也是不想等的，</span>\n<span class=\"comment\">// 不需要进行处理，所以没必要展开</span>\n_.difference([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>], [<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>]);\n<span class=\"comment\">// [1, 2], [3]通过restArgs变为[1, 2, 3]，传入difference方法，其余同</span>\n</code></pre>\n<p>所以其实 <code>difference</code> 方法的 <code>restArgs</code> 虽然对与 <code>without</code> 方法中的调用是多余的，但是作为一个独立的方法，他还是有必要的。\n上面注释应该说的很清楚了，完。</p>\n<p>其实只是我自己没看清楚而已，也不难。这个地方的很多方法比如 <code>union</code>, <code>intersection</code>等等都是集合的相关操作。比如 <code>difference</code> 就是差集，<code>union</code> 就是并集，而<code>intersection</code> 就是交集。</p>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"Underscore源码学习(七).md","link":"/post/Underscore源码学习(七).html"},{"title":"Underscore 源码学习(六)","date":"2016-08-05T13:59:06.000Z","categories":"Underscore","tags":["Underscore","JavaScript"],"content":"<p>关于 Underscore 的 mixin 方法。\n首先先看个例子：</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">function</span> Panel() {\n  consoe.log(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span> instanceof Panel);\n  <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> instanceof Panel) {\n    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;\n  } <span class=\"keyword\">else</span> {\n    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Panel();\n  }\n}\na = Panel();        <span class=\"comment\">// Window   false</span>\nb = <span class=\"keyword\">new</span> Panel();    <span class=\"comment\">// Panel{}  true</span>\n</code></pre>\n<p>当函数作为构造器使用时，函数内的 <code><span class=\"keyword\">this</span></code> 执行被新建的对象。当函数被调用时，函数内的 <code><span class=\"keyword\">this</span></code> 则为被调用的对象，在这里是 <code>Window</code>。</p>\n<pre><code class=\"lang-js\">  <span class=\"keyword\">var</span> _ = <span class=\"keyword\">function</span>(obj) {\n    <span class=\"keyword\">if</span> (obj instanceof _) <span class=\"keyword\">return</span> obj;\n    <span class=\"keyword\">if</span> (!(<span class=\"keyword\">this</span> instanceof _)) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _(obj);\n    <span class=\"keyword\">this</span>._wrapped = obj;\n  };\n</code></pre>\n<p>同样的，如果我们使用下面方法调用：</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> under = _();\n</code></pre>\n<p>第二个条件成立，所以新建一个 <code>_</code> 对象后返回，注意这里是再次调用这个函数。\n如果我们这样调用：</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> under = <span class=\"keyword\">new</span> _();\n</code></pre>\n<p>就好像上面第二次调用一样，这时候就构造了 <code>under</code> 这个对象，如果传入了参数 <code>obj</code>，则把 <code>obj</code> 存入 <code>under</code> 这个对象的 <code>_wrapped</code> 属性中。\n<code>Underscore</code> 提供了一个 OO 的调用方法，即:</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> chainResult = <span class=\"keyword\">function</span>(instance, obj) {\n    <span class=\"keyword\">return</span> instance._chain ? _(obj).chain() : obj;\n};\n\n_.mixin = <span class=\"keyword\">function</span>(obj) {\n    <span class=\"comment\">// 遍历obj中的函数</span>\n    _.each(_.functions(obj), <span class=\"keyword\">function</span>(name) {\n        <span class=\"comment\">// 避免原型链查找，提升性能</span>\n        <span class=\"keyword\">var</span> func = _[name] = obj[name];\n        _.prototype[name] = <span class=\"keyword\">function</span>() {\n            <span class=\"comment\">// 把wrapped作为数组第一个参数(context)，其余传参push到这个数组中</span>\n            <span class=\"keyword\">var</span> args = [<span class=\"keyword\">this</span>._wrapped];\n            push.apply(args, arguments);\n            <span class=\"comment\">// 如果this是一个_实例，则使用func调用的结果来新建_实例后返回以供继续链式调用</span>\n            <span class=\"comment\">// 如果this不是一个_实例，则直接返回func调用的结果</span>\n            <span class=\"keyword\">return</span> chainResult(<span class=\"keyword\">this</span>, func.apply(_, args));\n        };\n    });\n    <span class=\"keyword\">return</span> _;\n};\n\n<span class=\"comment\">// 把Underscore对象mixin化，这样就可以直接在_上调用方法</span>\n_.mixin(_);\n</code></pre>\n<p>当然我们还可以把自己写的方法通过 <code>mixin</code> 加入到 <code>Underscore</code> 对象中。</p>\n<p>在这段代码后面还把原生的一些操作方法也添加到这个 <code>_</code> 上面，这样我们就可以直接在 <code>_</code> 上调用这些方法。例如：</p>\n<pre><code class=\"lang-js\"><span class=\"comment\">// Add all mutator Array functions to the wrapper.</span>\n_.each([&amp;<span class=\"comment\">#39;pop&amp;#39;, &amp;#39;push&amp;#39;, &amp;#39;reverse&amp;#39;, &amp;#39;shift&amp;#39;, &amp;#39;sort&amp;#39;, &amp;#39;splice&amp;#39;, &amp;#39;unshift&amp;#39;], function(name) {</span>\n    <span class=\"keyword\">var</span> method = ArrayProto[name];\n    _.prototype[name] = <span class=\"keyword\">function</span>() {\n        <span class=\"keyword\">var</span> obj = <span class=\"keyword\">this</span>._wrapped;\n        method.apply(obj, arguments);\n        <span class=\"keyword\">if</span> ((name === &amp;<span class=\"comment\">#39;shift&amp;#39; || name === &amp;#39;splice&amp;#39;) &amp;&amp; obj.length === 0) delete obj[0];</span>\n        <span class=\"keyword\">return</span> chainResult(<span class=\"keyword\">this</span>, obj);\n    };\n});\n</code></pre>\n<p>上面这些方法并不是 Underscore 新建的，不存在于 Underscore 对象的原型链上，所以我们要把他们加进去。和上面 <code>mixin</code> 方法类似，下面这段代码是为了兼容 IE 而采取的操作：</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">if</span> ((name === &amp;<span class=\"comment\">#39;shift&amp;#39; || name === &amp;#39;splice&amp;#39;) &amp;&amp; obj.length === 0) delete obj[0];</span>\n</code></pre>\n<blockquote>\n<p>jdalton commented on 6 Dec 2011\nIE bugs with splice() and shift(), failing to remove the 0 indexed value, when using an array-like-object with _(...).\nIE compatibility mode and IE &lt; 9 have buggy Array shift() and splice() functions that fail to remove the last element, object[0], of array-like-objects even though the length property is set to 0.</p>\n</blockquote>\n<p>通过上面这些方法把 Underscore 转化为可面向对象编程，调用更加优雅，我们可以有以下两种使用方法：</p>\n<pre><code class=\"lang-js\">_.map([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"keyword\">function</span>(n){ <span class=\"keyword\">return</span> n * <span class=\"number\">2</span>; });\n_([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]).map(<span class=\"keyword\">function</span>(n){ <span class=\"keyword\">return</span> n * <span class=\"number\">2</span>; });\n</code></pre>\n<p>至于选择哪一种就看你的喜好了～</p>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"Underscore源码学习(六).md","link":"/post/Underscore源码学习(六).html"},{"title":"Underscore 源码学习(五)","date":"2016-08-04T15:18:48.000Z","categories":"Underscore","tags":["Underscore","JavaScript"],"content":"<p>Underscore 的函数大部分还是挺好理解的，感觉过一遍就行了，不过今天看到两个函数感觉还是挺有意思的，并且也挺常用。这两个函数就是 throttle 和 debounce。</p>\n<h2 id=\"throttle\">throttle</h2>\n<pre><code class=\"lang-js\">_.throttle = <span class=\"keyword\">function</span>(func, wait, options) {\n  <span class=\"keyword\">var</span> timeout, context, args, result;\n  <span class=\"keyword\">var</span> previous = <span class=\"number\">0</span>;\n  <span class=\"keyword\">if</span> (!options) options = {};\n\n  <span class=\"keyword\">var</span> later = <span class=\"keyword\">function</span>() {\n    <span class=\"comment\">// 更改previous即上一次执行时间为当前时间</span>\n    previous = options.leading === <span class=\"keyword\">false</span> ? <span class=\"number\">0</span> : _.now();\n    timeout = <span class=\"keyword\">null</span>;\n    result = func.apply(context, args);\n    <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"keyword\">null</span>;\n  };\n\n  <span class=\"keyword\">var</span> throttled = <span class=\"keyword\">function</span>() {\n    <span class=\"keyword\">var</span> now = _.now();\n    <span class=\"comment\">// 如果leading为false时禁用第一次首先执行，previous等于now（效果同已经执行过一次，所以第一次被禁用）</span>\n    <span class=\"comment\">// 这个if语句只在第一次执行该函数的时候有效</span>\n    <span class=\"keyword\">if</span> (!previous &amp;&amp; options.leading === <span class=\"keyword\">false</span>) previous = now;\n    <span class=\"keyword\">var</span> remaining = wait - (now - previous);\n    context = <span class=\"keyword\">this</span>;\n    args = arguments;\n    <span class=\"comment\">// 超时处理和未到时的处理</span>\n    <span class=\"keyword\">if</span> (remaining &lt;= <span class=\"number\">0</span> || remaining &gt; wait) {\n      <span class=\"comment\">// timeout不为null时清除掉并设置为null</span>\n      <span class=\"keyword\">if</span> (timeout) {\n        clearTimeout(timeout);\n        timeout = <span class=\"keyword\">null</span>;\n      }\n      previous = now;\n      <span class=\"comment\">// 立即调用</span>\n      result = func.apply(context, args);\n      <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"keyword\">null</span>;\n    } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!timeout &amp;&amp; options.trailing !== <span class=\"keyword\">false</span>) {    <span class=\"comment\">// 如果没有禁用最后一次执行</span>\n      timeout = setTimeout(later, remaining);               <span class=\"comment\">// remaining毫秒后执行later</span>\n    }\n    <span class=\"comment\">// 返回调用的结果</span>\n    <span class=\"keyword\">return</span> result;\n  };\n\n  throttled.cancel = <span class=\"keyword\">function</span>() {\n    clearTimeout(timeout);\n    previous = <span class=\"number\">0</span>;\n    timeout = context = args = <span class=\"keyword\">null</span>;\n  };\n\n  <span class=\"keyword\">return</span> throttled;\n};\n</code></pre>\n<p>其实一步步去理解也不难，就不细说这个方法了。这个方法有可选项设置，分别为 {leading: false} 和 {trailing: false}。</p>\n<p>所以一般有四类情况：</p>\n<ul>\n<li>默认情况\n第一次调用时立即响应，之后每个周期内最多执行一次，周期内触发会产生定时执行使在上一次执行时间 <code>preview</code> 周期时间后再次执行。</li>\n<li>设置 <code>leading</code> 为 <code><span class=\"keyword\">false</span></code>\n同默认情况区别在于第一次调用不会立即执行而是等待周期时间后再次执行，如果在周期时间内触发，一样等待上一次执行时间 <code>preview</code> 周期时间后再执行。</li>\n<li>设置 <code>trailing</code> 为 <code><span class=\"keyword\">false</span></code>\n最后周期内最多执行一次，但在周期时间内调用不会触发 <code>timeout</code>，只能在上一次 <code>timeout</code> 失效后调用才能生效并且此时调用将立即执行。</li>\n<li>设置 <code>leading</code> 和 <code>trailing</code> 为 <code><span class=\"keyword\">false</span></code>\n如果同时还设置 <code>leading</code> 为 <code><span class=\"keyword\">false</span></code> 的话，那么第一次调用不会立即执行而是等待周期时间后才执行，在这段时间内调用都不会有效果。</li>\n</ul>\n<p>比如</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> func = _.throttle(updatePosition, <span class=\"number\">100</span>);\n$(window).scroll(func);\n</code></pre>\n<p>由于 scroll 过程时, <code>func</code> 函数的调用是很密集的，我们不能每次调用都去执行，可以通过设置 throttle 来达到节流阀的作用。<code>leading</code> 和 <code>trailing</code> 只是实现上细微的不同而已。</p>\n<p>throll 主要应用在鼠标移动，mousemove 事件，DOM 元素动态定位，window 对象的 resize 和 scroll 等事件。这些事件触发频率高，但又要尽可能进行响应。</p>\n<h2 id=\"debounce\">debounce</h2>\n<pre><code class=\"lang-js\">_.debounce = <span class=\"keyword\">function</span>(func, wait, immediate) {\n  <span class=\"keyword\">var</span> timeout, result;\n\n  <span class=\"keyword\">var</span> later = <span class=\"keyword\">function</span>(context, args) {\n    timeout = <span class=\"keyword\">null</span>;\n    <span class=\"keyword\">if</span> (args) result = func.apply(context, args);\n  };\n\n  <span class=\"keyword\">var</span> debounced = restArgs(<span class=\"keyword\">function</span>(args) {\n    <span class=\"comment\">// 再次调用且上次还未执行，则清除上次的timeout</span>\n    <span class=\"comment\">// 只是timeout事件不再执行，但timeout依旧存在</span>\n    <span class=\"keyword\">if</span> (timeout) clearTimeout(timeout);\n    <span class=\"comment\">// 如果immediate为true</span>\n    <span class=\"keyword\">if</span> (immediate) {\n      <span class=\"comment\">// 如果timeout为null，则立即调用函数</span>\n      <span class=\"comment\">// 如果timeout不为null，则callNow为false，函数不执行</span>\n      <span class=\"keyword\">var</span> callNow = !timeout;\n      timeout = setTimeout(later, wait);\n      <span class=\"keyword\">if</span> (callNow) result = func.apply(<span class=\"keyword\">this</span>, args);\n    } <span class=\"keyword\">else</span> {\n      <span class=\"comment\">// 延迟later执行，如果这个还没到时间再来一次，则新的会覆盖上一次的</span>\n      timeout = _.delay(later, wait, <span class=\"keyword\">this</span>, args);\n    }\n\n    <span class=\"keyword\">return</span> result;\n  });\n\n  debounced.cancel = <span class=\"keyword\">function</span>() {\n    clearTimeout(timeout);\n    timeout = <span class=\"keyword\">null</span>;\n  };\n\n  <span class=\"keyword\">return</span> debounced;\n};\n</code></pre>\n<p>这个函数就要比上面那个好理解一点，说明下这个函数：</p>\n<ul>\n<li><p>如果 <code>immediate</code> 为 <code><span class=\"keyword\">true</span></code>，周期 100ms</p>\n<ul>\n<li>0   =&gt; 立即执行，设置 <code>timeout</code></li>\n<li>50  =&gt; 重新设置 <code>timeout</code>，不执行</li>\n<li>100 =&gt; 重新设置 <code>timeout</code>，不执行</li>\n<li>200 =&gt; <code>timeout</code> 到时，执行函数</li>\n</ul>\n</li>\n<li><p>如果 <code>immediate</code> 为 <code><span class=\"keyword\">false</span></code>, 周期 100ms</p>\n<ul>\n<li>0   =&gt; 设置 <code>timeout</code>，不执行</li>\n<li>100 =&gt; <code>timeout</code> 到时，执行函数</li>\n<li>120 =&gt; 设置 <code>timeout</code>，不执行</li>\n<li>180 =&gt; 重新设置 <code>timeout</code>，不执行</li>\n<li>280 =&gt; <code>timeout</code> 到时，执行函数</li>\n</ul>\n</li>\n</ul>\n<p>其实 <code>timeout</code> 就变成一个控制两次事件触发间隔用的，并且和上面的 throttle 不同，<code>timeout</code> 会被重新设置。</p>\n<p>debounce 主要应用在文本输入 keydown 事件，keyup 事件，例如做 autocomplete。</p>\n<p>结合两个的应用细细体味下他们差别。如果想自己体验下差别，<a href=\"http://jsfiddle.net/missinglink/19e2r2we/\">传送门</a>。</p>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"Underscore源码学习(五).md","link":"/post/Underscore源码学习(五).html"},{"title":"谈谈 React 和 Redux","date":"2016-08-01T15:53:32.000Z","categories":"React","tags":["React","Redux","JavaScript"],"content":"<p>刚回到家的时候学习了 React 和 Redux，现在才想来总结一下，不知道会不会忘的差不多了...本来是想写一个问卷发布系统的，使用 React 和 Redux 已经完成了基础的几个功能，但是那个代码量...用 Angular 写简直轻轻松松的好吧...然后就去重构项目还有现在学的 Underscore 去了。是时候重新回顾下了。\n此处主要讲的是 Redux 。</p>\n<h3 id=\"-redux\">关于 Redux</h3>\n<blockquote>\n<p>redux 是facebook 提出的 flux 架构的一种优秀实现；而且不局限于为 react 提供数据状态处理。它是零依赖的，可以配合其他任何框架或者类库一起使用。要想配合 react，还得引入 react-redux。</p>\n</blockquote>\n<h3 id=\"-flux\">关于 Flux</h3>\n<p>那什么是 Flux 呢？见下图\n{% asset_img flux-overview.png flux-overview.png %}\nFlux 可以分为四个部分：</p>\n<ul>\n<li>View: 视图层</li>\n<li>Action: 视图层触发的动作</li>\n<li>Dispatcher: 派发器，用来接受 Actions, 执行回调函数</li>\n<li>Store：数据层，用来存放应用的状态，其变更会触发 View 层更新</li>\n</ul>\n<p>Flux 的最大特点就是单向流动，他的过程大概如下：</p>\n<ol>\n<li>用户访问 View ，触发了动作 Action</li>\n<li>Dispatcher 收到 Action ，根据 Action 类别进行相应的处理，处理结束后要求 Store 更新</li>\n<li>Store 进行更新，通知 View 层刷新</li>\n<li>View 层收到通知更新页面</li>\n</ol>\n<p>额，其实我没有用 Flux，不敢讲太多了，简单的说就是一种单项数据流动的解决方案吧。我是直接学 Redux，对 Flux 也就大概了解这么多了。</p>\n<h3 id=\"redux-flux\">Redux 和 Flux</h3>\n<p>Redux 是 Flux 的一种实现，但他们又有所不同，在 Flux 中，Store 可以有多个，但 Redux 有且只能有一个 Store，Flux 中存在 Dispatcher，在 Redux 则没有这个，而是用 reducer 代替了。不多说了，直接往下说 Redux 吧，我快扯不下去 Flux 了=.=</p>\n<h3 id=\"-redux\">理解Redux</h3>\n<p>Redux 由四部分组成：</p>\n<ul>\n<li>Action</li>\n<li>Reducer</li>\n<li>Store</li>\n<li>Views</li>\n</ul>\n<p>我们结合具体的应用场景来看</p>\n<h4 id=\"action\">Action</h4>\n<p>先从 Action 说起，一个 Action 是一个普通的对象。</p>\n<pre><code class=\"lang-js\">export <span class=\"keyword\">const</span> SET_PAPER_TITLE = &amp;<span class=\"comment\">#39;SET_PAPER_TITLE&amp;#39;;</span>\nexport <span class=\"keyword\">const</span> ADD_QUESTION = &amp;<span class=\"comment\">#39;ADD_QUESTION&amp;#39;;</span>\nexport <span class=\"keyword\">const</span> REMOVE_QUESTION = &amp;<span class=\"comment\">#39;REMOVE_QUESTION&amp;#39;;</span>\nexport <span class=\"keyword\">function</span> setPaperTitle(newTitle) {\n    <span class=\"keyword\">return</span> {\n        type: SET_PAPER_TITLE,\n        value: newTitle\n    }\n}\nexport <span class=\"keyword\">function</span> addQuestion(type) {\n    <span class=\"keyword\">return</span> {\n        type: ADD_QUESTION,\n        questionType: type\n    }\n}\nexport <span class=\"keyword\">function</span> removeQuestion(questionId) {\n    <span class=\"keyword\">return</span> {\n        type: REMOVE_QUESTION,\n        questionId: questionId\n    }\n}\n</code></pre>\n<p>type 属性是必须的，表示动作类别，其他的参数可以自定。\n我们先不用管 Action 有什么用，后面会提到。</p>\n<h4 id=\"reducer\">Reducer</h4>\n<p>在 Action 这一层中，可以筛选掉脏数据，多余的参数不会传入，真正处理数据是在 Reducer 中。</p>\n<pre><code class=\"lang-js\">import { SET_PAPER_TITLE, ADD_QUESTION, REMOVE_QUESTION, ADD_OPTION, REMOVE_OPTION, SET_QUESTION_TITLE, SET_OPTION_TITLE } from &amp;<span class=\"comment\">#39;../action/action&amp;#39;</span>\nimport { combineReducers } from &amp;<span class=\"comment\">#39;redux&amp;#39;</span>\n<span class=\"keyword\">function</span> paperReducer(state=[], action) {\n    <span class=\"keyword\">switch</span>(action.type) {\n        <span class=\"keyword\">case</span> SET_PAPER_TITLE:\n            <span class=\"keyword\">return</span> Object.assign({}, state, {\n                title: action.value\n            });\n        <span class=\"keyword\">default</span>:\n            <span class=\"keyword\">return</span> state;\n    }\n}\n<span class=\"keyword\">function</span> questionsReducer(state=[], action) {\n    <span class=\"keyword\">switch</span>(action.type) {\n        <span class=\"keyword\">case</span> ADD_QUESTION:\n            <span class=\"keyword\">return</span> [\n                ...state,\n                {\n                    title: &amp;<span class=\"comment\">#39;&amp;#39;,</span>\n                    type: action.questionType,\n                    content: [&amp;<span class=\"comment\">#39;&amp;#39;,&amp;#39;&amp;#39;,&amp;#39;&amp;#39;,&amp;#39;&amp;#39;]</span>\n                }\n            ];\n        <span class=\"keyword\">case</span> REMOVE_QUESTION:\n            <span class=\"keyword\">return</span> [\n                ...state.slice(<span class=\"number\">0</span>, action.questionId),\n                ...state.slice(action.questionId+<span class=\"number\">1</span>)\n            ];\n        <span class=\"keyword\">case</span> ADD_OPTION:\n        <span class=\"keyword\">case</span> REMOVE_OPTION:\n        <span class=\"keyword\">case</span> SET_QUESTION_TITLE:\n        <span class=\"keyword\">case</span> SET_OPTION_TITLE:\n            <span class=\"keyword\">return</span> [\n                ...state.slice(<span class=\"number\">0</span>, action.questionId),\n                questionReducer(state[action.questionId], action),\n                ...state.slice(action.questionId+<span class=\"number\">1</span>)\n            ];\n        <span class=\"keyword\">default</span>:\n            <span class=\"keyword\">return</span> state;\n    }\n}\n<span class=\"keyword\">var</span> paperApp = combineReducers({\n    paper: paperReducer,\n    questions: questionsReducer\n});\nexport <span class=\"keyword\">default</span> paperApp;\n</code></pre>\n<p>这里列了很多 Action，但在上面的 Action 部分我只提了两个，其他的其实都一样的，就是参数可能有些区别而已。\n这里就要好好说一笔了，reducer 之所以叫 reducer，一个原因就是他很类似 JavaScript 中数组的 reduce 方法，接收两个参数，一个是当前状态，一个是处理方法。\n但在 Redux 中，不要直接修改当前状态即 <code>state</code>，而应该返回一个新的 <code>state</code>，而这样做的其中一个好处就是可以实现时间旅行的功能，即可以回溯到任意版本的数据，并且对于判断 <code>state</code> 是否发生修改也很重要，如果是在原引用上修改我们得用 <code>deepEqual</code> 深度遍历来对比值，而如果返回了一个新的对象则可以直接使用 <code>===</code> 来判断两个数据是否一致，不一致则触发更改。reducer 方法应该都能看懂，接下来是 combineReducers 这个。\n我上面其实涉及到三个 reducer 了，分别是</p>\n<ul>\n<li>paperReducer</li>\n<li>questionsReducer</li>\n<li>questionReducer</li>\n</ul>\n<p>但为了减少空间，我没有把 <code>questionReducer</code> 写出来。其实注意看从29行到32行的四个 Action，我都传入 <code>state</code> 中的部分数据给了 <code>questionReducer</code> 去做处理。因为这些都是涉及一个问题的修改的，所以就单独列出来。这样就不致于一个 reducer 写太多东西。\n实质上还是两个 reducer 而已，这里的 combineReducers 就是把这两个 reducer 合并在一起。这两个 reducer 一个是处理问卷信息如问卷标题，一个是处理问卷的问题比如新建删除问题，问题修改这些。</p>\n<h4 id=\"store\">Store</h4>\n<p>使用 combineReducers 就要求我们 Store 的设计合理，因为 Store 和 reducer 是要对应的，<code>questionsReducer</code> 只要处理问题，而 <code>paperReducer</code> 只要处理问卷本身，所以也就不需要往 <code>paperReducer</code> 传入完整的 <code>state</code> 信息。我们看下 Store。</p>\n<pre><code class=\"lang-js\">import React from &amp;<span class=\"comment\">#39;react&amp;#39;</span>\nimport { createStore } from &amp;<span class=\"comment\">#39;redux&amp;#39;</span>\nimport { render } from &amp;<span class=\"comment\">#39;react-dom&amp;#39;</span>\nimport { Provider } from &amp;<span class=\"comment\">#39;react-redux&amp;#39;</span>\nimport paperApp from &amp;<span class=\"comment\">#39;./reducer/reducer&amp;#39;</span>\nimport App from &amp;<span class=\"comment\">#39;./containers/App&amp;#39;</span>\n\n<span class=\"keyword\">const</span> initialState = {\n    paper: {\n        title: &amp;<span class=\"comment\">#39;asd&amp;#39;,</span>\n        time: &quot;<span class=\"number\">2016</span>-<span class=\"number\">7</span>-<span class=\"number\">19</span>&quot;,\n        author: &quot;Ruiming&quot;,\n    },\n    questions: [{\n        title: &amp;<span class=\"comment\">#39;&amp;#39;,</span>\n        type: &amp;<span class=\"comment\">#39;radio&amp;#39;,</span>\n        content: [&amp;<span class=\"comment\">#39;&amp;#39;, &amp;#39;&amp;#39;, &amp;#39;&amp;#39;, &amp;#39;&amp;#39;]</span>\n    }, {\n        title: &amp;<span class=\"comment\">#39;&amp;#39;,</span>\n        type: &amp;<span class=\"comment\">#39;checkbox&amp;#39;,</span>\n        content: [&amp;<span class=\"comment\">#39;&amp;#39;,&amp;#39;&amp;#39;,&amp;#39;&amp;#39;,&amp;#39;&amp;#39;]</span>\n    }]\n};\nlet store = createStore(paperApp, initialState);\nlet rootElement = document.getElementById(&amp;<span class=\"comment\">#39;index&amp;#39;);</span>\nrender (\n    &lt;Provider store={store}&gt;\n        &lt;App /&gt;\n    &lt;/Provider&gt;,\n    rootElement\n);\n</code></pre>\n<p>我们初始一个数据 initialState，调用 createStore 方法需要传入两个参数，分别就是我们上面 combineReducers 后的<code>paperApp</code>和我们的数据。在初始数据中，有两个对象分别是<code>paper</code>和<code>questions</code>，这就刚好和 combineReducers 中的<code>paper</code>和<code>questions</code>对应，从而实现传递部分<code>state</code>。\n下面的 render 部分是就是渲染部分了， Provider 是 react-redux 提供的一个容器，将 Store 作为属性传递给该容器。</p>\n<h4 id=\"views\">Views</h4>\n<p>我们看下 App 的内容</p>\n<pre><code class=\"lang-js\">import React, { Component, PropTypes } from &amp;<span class=\"comment\">#39;react&amp;#39;</span>\nimport { connect } from &amp;<span class=\"comment\">#39;react-redux&amp;#39;</span>\nimport { addQuestion, addOption, setPaperTitle, setQuestionTitle, setOptionTitle, removeQuestion, removeOption } from &amp;<span class=\"comment\">#39;../action/action&amp;#39;</span>\nimport Header from &amp;<span class=\"comment\">#39;../components/Header&amp;#39;</span>\nimport NewQuestionBar from &amp;<span class=\"comment\">#39;../components/NewQuestionBar&amp;#39;</span>\nimport OptionsBar from &amp;<span class=\"comment\">#39;../components/OptionsBar&amp;#39;</span>\n\n<span class=\"keyword\">class</span> App <span class=\"keyword\">extends</span> Component {\n    render() {\n        <span class=\"keyword\">const</span> { dispatch, title, questions } = <span class=\"keyword\">this</span>.props;\n        <span class=\"keyword\">return</span> &lt;div ref=&quot;paper&quot;&gt;\n            &lt;Header title={title}\n                    setPaperTitle={(title) =&gt; dispatch(setPaperTitle(title))}\n                /&gt;\n            &lt;NewQuestionBar addQuestion={(type) =&gt; dispatch(addQuestion(type))} /&gt;\n            &lt;section className=&quot;paper&quot;&gt;\n                &lt;ul className=&quot;paper-<span class=\"keyword\">list</span>&quot;&gt;\n                    {questions.map(<span class=\"keyword\">function</span>(question, i) {\n                        <span class=\"keyword\">return</span> &lt;OptionsBar content={question.content}\n                                           addQuestion={() =&gt; dispatch(addQuestion())}\n                                           addOption={(questionId) =&gt; dispatch(addOption(questionId))}\n                        /&gt;\n                    }.bind(<span class=\"keyword\">this</span>))\n                    }\n                &lt;/ul&gt;\n            &lt;/section&gt;\n        &lt;/div&gt;\n    }\n}\n\n<span class=\"keyword\">function</span> select(state) {\n    <span class=\"keyword\">return</span> {\n        paper: state.paper,\n        questions: state.questions\n    }\n}\n\nexport <span class=\"keyword\">default</span> connect(select)(App);\n</code></pre>\n<p>上面我去掉了很多部分，只保留了 <code>addQuestion</code> 和 <code>addOption</code> 这两个，我们看下这两个就好了。其实这部分的写法就是 React 写法而已，只是多了个 dispatch 方法。注意下最后的 connect 方法，他的作用是：</p>\n<ul>\n<li>把所需要的 <code>state</code> 属性挂载到组件的 <code>props</code> 上。</li>\n<li>为组件的 <code>props</code> 添加 <code>dispatch</code> 方法。</li>\n</ul>\n<h3 id=\"redux-\">Redux 运行过程</h3>\n<p>介绍完了 Redux 的四个部分，接下来就要说下这个运行的流程了。这才是理解 Redux 的关键。</p>\n<ol>\n<li>用户在视图触发 dispatch 事件</li>\n<li>Redux 响应用户操作生成 action </li>\n<li>action 传到 store 层，可以使用中间件进行一些处理</li>\n<li>action 传 <code>state</code> 和 <code>action</code> 给 reducer 处理</li>\n<li>reducer 返回一个新的 <code>state</code></li>\n<li>store 读取 reducer 返回的内容，设置新的状态</li>\n</ol>\n<p>大致就是以上过程，action 是唯一可以改变状态的途径，不仅包括用户的触发，也可以是来自服务器的推送，action 进行预处理后会传到 store，由 store 发送动作给 reducer，带上当前状态和当前动作，reducer 根据动作的 type 来进行不同的处理。注意 action 和 reducer 都是纯函数。</p>\n<p>Redux 大致就是这么一回事，我们可以看到所有数据都来自一个对象 Store，这样就方便了调试测试，可以把 Store 就想象成一个数据库。state 只读，只能通过 action 改变，并且必须保证 reducer 是纯函数，所谓纯函数就是相同参数传入无数次他们都返回相同的东西，其实就是内部没有使用外部变量，外部变量总是伴随着不确定性。</p>\n<h3 id=\"react-angular\">React 和 Angular</h3>\n<p>React 现在很博人眼球，虚拟DOM提升了页面渲染性能，并且衍生的 React Native 也非常有诱惑力，单向数据流动虽然带来了清晰的逻辑和更高的性能，但降低了开发效率。另外，使用 React 开发的应用天然组件化，也方便了后期的维护。</p>\n<p>Angular 是一个功能完善全面的框架，还自带了 $http, ngRoute, jQlite, $q, service 等等。提供了一整套的解决方案，估计这点很合大公司的胃口。并且 Angular 社区成熟活跃，生态完整，目前仍是最流行的前端框架，没有之一，非常适合用来写单页应用。数据双向绑定给开发带来了很大的便利，但双向绑定带来了性能损耗并且脏值检查性能也不好。</p>\n<p>对比起来，我还是更喜欢 Angular，他的开发效率高，而且写起来很清晰，虽然他也有一些问题，但是在没有达到一个量级前这些问题是很难被体现出来的。而 React 可能在开发多端或者注重体积或者是在大型应用中可能才会去考虑吧。</p>\n<p>另外 Angular2 也实现了虚拟 DOM，同样支持服务端渲染，使用 web worker 提升性能，TypeScript 提升了 JavaScript 项目的健壮性，而 Web Components 无疑是是未来趋势。我对 Angular2 同样满怀期待，我认为 Angular2 未来也会同 Angular1 一样火起来。</p>\n<p>计划是再学习 react-router，写一个完整的 React 应用，后端使用 Koa 来开发。不过还是等手头上的东西处理完先吧。</p>\n<p>除了 Angular1 和 Angular2 以及 React ，还有 Vue 和 Vue2 以及阿里的 Weex，前端的水深着呢！</p>\n<hr>\n<p><a href=\"https://github.com/Lucifier129/Lucifier129.github.io/issues/9\">深入到源码：解读 redux 的设计思路与用法</a></p>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"谈谈React和Redux.md","link":"/post/谈谈React和Redux.html"},{"title":"Underscore 源码学习(四)","date":"2016-08-01T15:37:14.000Z","categories":"Underscore","tags":["Underscore","JavaScript"],"content":"<p>终于看完了 Underscore 的集合部分了，看 Underscore 源码真的是长见识了，感觉真的受益匪浅。\n但是集合里面方法也挺多的，我都不知道该拿哪些出来讲下，最近接触了 Redux，就说下 createRedux 这个方法吧，为后面讲 Redux 做个铺垫。\n先看源码</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> createReduce = <span class=\"keyword\">function</span>(dir) {\n  <span class=\"keyword\">var</span> reducer = <span class=\"keyword\">function</span>(obj, iteratee, memo, initial) {\n    <span class=\"keyword\">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),\n        length = (keys || obj).length,\n        index = dir &gt; <span class=\"number\">0</span> ? <span class=\"number\">0</span> : length - <span class=\"number\">1</span>;\n    <span class=\"keyword\">if</span>(!initial) {\n      memo = obj[keys ? keys[index] : index];\n      index += dir;\n    }\n    <span class=\"keyword\">for</span>(; index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt; length; index += dir) {\n      <span class=\"keyword\">var</span> currentKey = keys ? keys[index] : index;\n      memo = iteratee(memo, obj[currentKey], currentKey, obj);\n    }\n    <span class=\"keyword\">return</span> memo;\n  };\n\n  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(obj, iteratee, memo, context) {\n    <span class=\"keyword\">var</span> initial = arguments.length &gt;= <span class=\"number\">3</span>;\n    <span class=\"keyword\">return</span> reducer(obj, opitimizeCb(iteratee, context, <span class=\"number\">4</span>), memo, initial);\n  };\n};\n</code></pre>\n<p>这是 reduce 函数的工厂函数，用于生成一个 reducer ，dir 是决定方向用的。\n我们从最后一个 return 开始看起，即</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(obj, iteratee, memo, context) {\n  <span class=\"keyword\">var</span> initial = arguments.length &gt;= <span class=\"number\">3</span>;\n  <span class=\"keyword\">return</span> reducer(obj, opitimizeCb(iteratee, context, <span class=\"number\">4</span>), memo, initial);\n};\n</code></pre>\n<p>我们使用 reduce 的时候，如果没有指定 memo 值，这时候参数个数只有两个即 obj 和 iteratee，所以 initial 为 false 表示没有初始化。对于没初始的情况，就是增加了一个 if 语句里面的内容而已，作用是把第一个元素作为 memo 值。\n接着就是有没有初始化都共用的部分了，通过一个 for 循环把 keys 遍历，并把相应的信息交给 iteratee 去处理，参数 memo 是上一次处理结果。遍历完后把最后的处理结果 memo 返回就完了。\n这个函数派生了两个方法，即</p>\n<pre><code class=\"lang-js\">_.reduce = _.foldl = _.inject = createReduce(1);\n_.reduceRight = _.foldr = createReduce(-1);\n</code></pre>\n<p>只是方向不同而已。\n举个例子方便理解些，例如：</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> sum = _.reduce([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], <span class=\"keyword\">function</span>(accumulator, value, index, collection) {\n  <span class=\"keyword\">return</span> accmulator + value;\n}, <span class=\"number\">0</span>);\n</code></pre>\n<p>结果为 15 这个应该很明显，js 原生也有 reduce 方法，如下：</p>\n<pre><code class=\"lang-js\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].reduce(<span class=\"keyword\">function</span>(left, right) {\n  <span class=\"keyword\">return</span> left + right;\n});\n</code></pre>\n<p>我们看下 Underscore 的例子，主要想说明下他的运行过程，如下：</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">if</span>(!initial)\n    memo = <span class=\"number\">1</span>; index = <span class=\"number\">1</span>;\n<span class=\"keyword\">endif</span>\n<span class=\"keyword\">for</span>\n    memo = iteratee(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]) = <span class=\"number\">3</span>;\n    memo = iteratee(<span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]) = <span class=\"number\">6</span>;\n    memo = iteratee(<span class=\"number\">6</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]) = <span class=\"number\">10</span>;\n    memo = iteratee(<span class=\"number\">10</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]) = <span class=\"number\">15</span>;\n<span class=\"keyword\">endfor</span>\n<span class=\"keyword\">return</span> memo = <span class=\"number\">15</span>;\n</code></pre>\n<p>额，我也不知道写的是什么东西，只是描述下过程而已，你懂的。\n剩下的集合部分感觉也没啥好说的了，花点时间看下就可以看懂了=.=。</p>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"Underscore源码学习(四).md","link":"/post/Underscore源码学习(四).html"},{"title":"Underscore 源码学习(三)","date":"2016-07-31T14:37:31.000Z","categories":"Underscore","tags":["Underscore","JavaScript"],"content":"<p>这次主要说剩余参数。</p>\n<p>在 ES5 中，如果想要函数接收任意数量的参数，必须使用特殊变量 <code>arguments</code>，举个例子，我们要实现一个加法函数，要求第一个数乘2，然后与其他数相加。</p>\n<pre><code class=\"lang-javascript\"><span class=\"keyword\">function</span> add() {\n    <span class=\"keyword\">var</span> sum = arguments[<span class=\"number\">0</span>] * <span class=\"number\">2</span>;\n    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; arguments.length; i++) {\n        sum += arguments[i];\n    }\n    <span class=\"keyword\">return</span> sum;\n}\n</code></pre>\n<p>在 ES6 中，我们可以使用 <code>...</code> 操作符，例如：</p>\n<pre><code class=\"lang-javascript\"><span class=\"keyword\">function</span> add(first, ...args) {\n    <span class=\"keyword\">var</span> sum = first*<span class=\"number\">2</span>;\n    <span class=\"keyword\">for</span>(let arg of args) {\n        sum += arg;\n    }\n    <span class=\"keyword\">return</span> sum;\n}\n</code></pre>\n<p>使用 ES5 我们无法给函数定义参数，而只能通过 <code>arguments</code> 来获取参数，这样写明显带来了可读性的降低。而 ES6 我们就可以在函数声明里面写明参数，对于不定长的参数，则可以使用 <code>...</code> 操作符。\n<code>...</code> 还有另一个常用的应用场景，比如下面例子：</p>\n<pre><code class=\"lang-javascript\"><span class=\"keyword\">function</span> test() {\n    console.log(arguments);\n    console.log(arguments instanceof <span class=\"keyword\">Array</span>);\n    console.log(arguments instanceof Object);\n}\ntest(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);\n<span class=\"comment\">// Result:</span>\n[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]\n<span class=\"keyword\">false</span>\n<span class=\"keyword\">true</span>\n</code></pre>\n<p>如果细看输出的[1, 2, 3]会发现他是这样的：\n{% asset_img result1.png result1.png %}\n我们再试试下面的</p>\n<pre><code class=\"lang-javascript\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\nconsole.log(arr);\nconsole.log(arr instanceof <span class=\"keyword\">Array</span>);\nconsole.log(arr instanceof Object);\n<span class=\"comment\">// Result:</span>\n[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]\n<span class=\"keyword\">true</span>\n<span class=\"keyword\">true</span>\n</code></pre>\n<p>再看下[1, 2, 3]这行输出里面是什么：\n{% asset_img result2.png result2.png %}\n从 <code>instanceof</code> 我们就知道了 <code>arguments</code> 并不是真正的数组。伪数组实质是一个对象。\n要把一个伪数组转为数组，可以这样用</p>\n<pre><code class=\"lang-javascript\"><span class=\"keyword\">var</span> arr = <span class=\"keyword\">Array</span>.prototype.slice.call(arguments);\n</code></pre>\n<p>上面这种做法在很多地方都可以看到。除了上面这样做之外，我们还可以使用 ES6 的 <code><span class=\"keyword\">Array</span>.from</code> 来处理，如下：</p>\n<pre><code class=\"lang-javascript\"><span class=\"keyword\">var</span> arr = <span class=\"keyword\">Array</span>.from(arguments);\n</code></pre>\n<p>但在 ES6 中，我们使用 <code>...</code> 运算符并不存在这个问题，比如上面第二个例子，<code>args</code> 是一个数组。\n鉴于此，我们应该尽量使用 ES6 剩余参数写法和 <code><span class=\"keyword\">Array</span>.from</code> 的写法，因为这样更容易理解，而且写起来更简洁。\n另外，我们还可以使用 <code>...</code> 操作符来复制数组，如下：</p>\n<pre><code class=\"lang-javascript\"><span class=\"keyword\">var</span> itemsCopy = [...items];\n</code></pre>\n<p>额，说多了，其实我是想说说 Underscore 中的 restArgs 这个东西...\n看下：</p>\n<pre><code class=\"lang-javascript\"><span class=\"keyword\">var</span> restArgs = <span class=\"keyword\">function</span>(func, startIndex) {\n    startIndex = startIndex == <span class=\"keyword\">null</span> ? func.length -<span class=\"number\">1</span> : +startIndex;\n    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>() {\n        <span class=\"keyword\">var</span> length = Math.max(arguments.length - startIndex, <span class=\"number\">0</span>);\n        <span class=\"keyword\">var</span> rest = <span class=\"keyword\">Array</span>(length);\n        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> index = <span class=\"number\">0</span>; index &lt; length; index++) {\n            rest[index] = arguments[index + startIndex];\n        }\n        <span class=\"keyword\">switch</span> (startIndex) {\n            <span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"keyword\">return</span> func.call(<span class=\"keyword\">this</span>, rest);\n            <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> func.call(<span class=\"keyword\">this</span>, arguments[<span class=\"number\">0</span>], rest);\n            <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"keyword\">return</span> func.call(<span class=\"keyword\">this</span>, arguments[<span class=\"number\">0</span>], arguments[<span class=\"number\">1</span>], rest);\n        }\n        <span class=\"keyword\">var</span> args = <span class=\"keyword\">Array</span>(startIndex + <span class=\"number\">1</span>);\n        <span class=\"keyword\">for</span> (index = <span class=\"number\">0</span>; index &lt; startIndex; index++) {\n            args[index] = arguments[index];\n        }\n        args[startIndex] = rest;\n        <span class=\"keyword\">return</span> func.apply(<span class=\"keyword\">this</span>, args);\n    };\n};\n</code></pre>\n<p>这个的作用就类似与 ES6 中的 <code>...</code> 操作符。这段代码作用是把 <code>func</code> 中 <code>startIndex</code> 开始的（如果没有指定则为被函数声明参数的最后一位开始）后面的参数全部变为一个数组传入 <code>func</code> 中。\n这里有几个可圈可点的地方：</p>\n<ul>\n<li>fun.length 和 arguments.length\n函数也具有 <code>length</code> 方法，得到的值是函数定义的参数的个数，但注意如果中间有一个含默认值的参数，则这个数和后面的参数都不会计算进去。例如：</li>\n</ul>\n<pre><code class=\"lang-javascript\"><span class=\"keyword\">function</span> test1(arg1, arg2, arg3 = <span class=\"number\">1</span>, arg4) {};\n<span class=\"keyword\">function</span> test2(arg1, arg2, arg3) {};\ntest1.length;   <span class=\"comment\">// 2</span>\ntest2.length    <span class=\"comment\">// 3</span>\n</code></pre>\n<p>  而 <code>arguments.length</code> 则一直表示传入函数的参数个数。</p>\n<ul>\n<li>使用 <code>+</code> 转换为数字\n你可能注意到了下面这句话有个 <code>+</code> 运算符。</li>\n</ul>\n<pre><code class=\"lang-js\">startIndex = startIndex == <span class=\"keyword\">null</span> ? func.length - <span class=\"number\">1</span> : +startIndex;\n</code></pre>\n<p>  其用途就是尝试把 <code>startIndex</code> 转为数字，我们举例看下就明白了。</p>\n<pre><code class=\"lang-javascript\"><span class=\"keyword\">var</span> a = &amp;<span class=\"comment\">#39;123&amp;#39;, b = &amp;#39;123s&amp;#39;, c = &amp;#39;0x321&amp;#39;, d = &amp;#39;-0&amp;#39;, e = &amp;#39;-Infinity&amp;#39;</span>\n+a;           <span class=\"comment\">// 123</span>\n+b;           <span class=\"comment\">// NaN</span>\n+c;           <span class=\"comment\">// 801</span>\n+d;           <span class=\"comment\">// -0</span>\n+e;           <span class=\"comment\">// -Infinity</span>\n</code></pre>\n<p>  应该很清楚了，就不说明了。\n  然后关于这里的 <code><span class=\"keyword\">switch</span></code> 其实就是一个优化而已，前面都提到过了，不提了。</p>\n<p>我们看下 Underscore 运用到 restArgs 方法的地方：</p>\n<pre><code class=\"lang-javascript\">_.invoke = restArgs(<span class=\"keyword\">function</span>(obj, method, args) {\n<span class=\"keyword\">var</span> isFunc = _.isFunction(method);\n    <span class=\"keyword\">return</span> _.map(obj, <span class=\"keyword\">function</span>(value) {\n        <span class=\"keyword\">var</span> func = isFunc ? method : value[method];\n        <span class=\"keyword\">return</span> func == <span class=\"keyword\">null</span> ? func : func.apply(value, args);\n    });\n});\n</code></pre>\n<p>这个方法的作用是在 <code>obj</code> 的每个元素上面执行 <code>method</code> 方法，例如：</p>\n<pre><code class=\"lang-javascript\">_.invoke([[<span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">7</span>], [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>]], &amp;<span class=\"comment\">#39;sort&amp;#39;);</span>\n_.invoke([[&amp;<span class=\"comment\">#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;], [&amp;#39;w&amp;#39;, &amp;#39;g&amp;#39;, &amp;#39;s&amp;#39;]], &amp;#39;join&amp;#39;, &amp;#39;#&amp;#39;);</span>\n<span class=\"comment\">// Result:</span>\n<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>\na<span class=\"comment\">#b#c,w#g#s</span>\n</code></pre>\n<p>由于 <code>method</code> 需要的参数个数是未知的，所以我们这里使用了 <code>args</code> 再用 <code>restArgs</code> 达到类似 <code>...</code> 操作符的效果。\n本来还想说说 Underscore 的几个方法的...但是好像已经写了挺多的了，还是下一次再介绍吧，后面的很多方法其实都不难理解，不过最好结合他的实际应用例子这样就更容易去理解些。</p>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"Underscore源码学习(三).md","link":"/post/Underscore源码学习(三).html"},{"title":"Underscore 源码学习(二)","date":"2016-07-29T21:29:23.000Z","categories":"Underscore","tags":["Underscore","JavaScript"],"content":"<p>Underscore 源码的学习落下了好几天，因为前几天一直正在重构项目和搞 React，不过这几天应该会花较多时间在 Underscore 上面了。\n这次主要说下 Underscore 两个比较重要的函数吧，一个是<code>optimizeCb</code>，另一个是<code>cb</code>，这两个花了我挺长时间看的，而且是整个 Underscore 非常重要的函数，后面很多地方都使用到了它。</p>\n<h2 id=\"optimizecb-\">optimizeCb 函数</h2>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> optimizeCb = <span class=\"keyword\">function</span>(func, context, argCount) {\n    <span class=\"keyword\">if</span> (context === void <span class=\"number\">0</span>) <span class=\"keyword\">return</span> func;\n    <span class=\"keyword\">switch</span> (argCount == <span class=\"keyword\">null</span> ? <span class=\"number\">3</span> : argCount) {\n      <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(value) {\n        <span class=\"keyword\">return</span> func.call(context, value);\n      };\n      <span class=\"keyword\">case</span> <span class=\"number\">3</span>: <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(value, index, collection) {\n        <span class=\"keyword\">return</span> func.call(context, value, index, collection);\n      };\n      <span class=\"keyword\">case</span> <span class=\"number\">4</span>: <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(accumulator, value, index, collection) {\n        <span class=\"keyword\">return</span> func.call(context, accumulator, value, index, collection);\n      };\n    }\n    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>() {\n      <span class=\"keyword\">return</span> func.apply(context, arguments);\n    };\n};\n</code></pre>\n<p>这个地方 <code><span class=\"keyword\">switch</span></code> 只是一个性能的优化，其实简化来看就是这样的</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> optimizeCb = <span class=\"keyword\">function</span>(func, context, argCount) {\n    <span class=\"keyword\">if</span> (context === void <span class=\"number\">0</span>) <span class=\"keyword\">return</span> func;\n    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>() {\n      <span class=\"keyword\">return</span> func.apply(context, arguments);\n    };\n};\n</code></pre>\n<p>之所以有那段 <code><span class=\"keyword\">switch</span></code> 前面一篇已经有提到了，只是一个优化而已。使用 call 快于 apply。不过好像最新的 Chrome 已经可以自己优化这个过程，但为了提升性能，加上也无妨。\n解释下段代码的意思，字如起名 optimizeCb 优化回调。这个函数传入三个参数依次是函数，上下文，参数个数。如果没有指定上下文则返回函数本身，如果有，则对该上下文绑定到传入的函数，根据传入的参数个数，在做一个性能优化。这个函数就是这个意思。我们看下他的使用。</p>\n<pre><code class=\"lang-js\">  _.each = _.<span class=\"keyword\">forEach</span> = <span class=\"keyword\">function</span>(obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    <span class=\"keyword\">var</span> i, length;\n    <span class=\"keyword\">if</span> (isArrayLike(obj)) {\n      <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>, length = obj.length; i &lt; length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } <span class=\"keyword\">else</span> {\n      <span class=\"keyword\">var</span> keys = _.keys(obj);\n      <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>, length = keys.length; i &lt; length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    <span class=\"keyword\">return</span> obj;\n  };\n</code></pre>\n<p>这个函数是用来实现数组或者对象的遍历的，他是怎么做到呢？\n首先是</p>\n<pre><code class=\"lang-js\">iteratee = optimizeCb(iteratee, context);\n</code></pre>\n<p>这个是优化 <code>iteratee</code> 这个函数，如果指定了上下文(<code>context</code>)则做绑定。一开始没理解 <code>iteratee</code> 这东西，其实他就是一个函数而已，比如</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> stu = {\n  &amp;<span class=\"comment\">#39;age&amp;#39;: 20,</span>\n  &amp;<span class=\"comment\">#39;school&amp;#39;: &amp;#39;SCNU&amp;#39;,</span>\n  &amp;<span class=\"comment\">#39;sex&amp;#39;: &amp;#39;male&amp;#39;</span>\n};\n_.each(stu, <span class=\"keyword\">function</span>(value, key, obj) {\n    console.log(key + &amp;<span class=\"comment\">#39; : &amp;#39; + value); </span>\n});\n<span class=\"comment\">// console</span>\nage : <span class=\"number\">20</span>\nschool : SCNU\nsex : male\n</code></pre>\n<p>我们传入了一个函数，这个函数可以有三个回调参数分别是 value, key, obj 分别表示键值，键名，迭代对象。\n重新看回 <code>each</code> 这个函数，<code>isArrayLike</code> 函数判断 <code>obj</code> 是不是数组，如果是的话，一个循环分别把 <code>obj[i]</code>, <code>i</code>, <code>obj</code> 分别传入这个 <code>iteratee</code> 这个传入来的函数，比如上面的 <code><span class=\"keyword\">function</span>(value, key, obj){}</code> 里面，一一对应到 <code>value</code>, <code>key</code>, <code>obj</code>。从而实现迭代。在下面的是对象的处理，没什么好说的。\n然后我们就讲完了 optimizeCb 这个函数了，其实也挺好理解的。</p>\n<h2 id=\"cb-\">cb 函数</h2>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> cb = <span class=\"keyword\">function</span>(value, context, argCount) {\n    <span class=\"comment\">// 如果改变了iteratee的行为，则返回自定义的iteratee</span>\n    <span class=\"keyword\">if</span> (_.iteratee !== builtinIteratee) <span class=\"keyword\">return</span> _.iteratee(value, context);\n    <span class=\"comment\">// 没有传入value，返回当前迭代元素自身，比如var results = _.map([1,2,3]) =&gt; results: [1,2,3]</span>\n    <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> _.identity;\n    <span class=\"comment\">// 是函数返回优化回调函数，比如var results = _.map([1,2,3], function(value, index, obj) {...})</span>\n    <span class=\"keyword\">if</span> (_.isFunction(value)) <span class=\"keyword\">return</span> optimizeCb(value, context, argCount);\n    <span class=\"comment\">// 是对象返回一个能判断对象是否相等的函数，比如</span>\n    <span class=\"comment\">// var results = _.map([{name:&amp;#39;qq&amp;#39;},{name:&amp;#39;w&amp;#39;,age:13}], {name:&amp;#39;w&amp;#39;}) =&gt; results: [false, true]</span>\n    <span class=\"keyword\">if</span> (_.isObject(value)) <span class=\"keyword\">return</span> _.matcher(value);\n    <span class=\"comment\">// 返回获取对象属性的函数，比如</span>\n    <span class=\"comment\">// var results = _.map([{name: &amp;#39;qq&amp;#39;}, {name: &amp;#39;ww&amp;#39;}], &amp;#39;name&amp;#39;) =&gt; results: [&amp;#39;qq&amp;#39;, &amp;#39;ww&amp;#39;]</span>\n<span class=\"keyword\">return</span> _.property(value);\n};\n</code></pre>\n<p>首先是 <code>buildinIteratee</code> 这东西，这要结合下面这个来看</p>\n<pre><code class=\"lang-js\">_.iteratee = builtinIteratee = <span class=\"keyword\">function</span>(value, context) {\n    <span class=\"keyword\">return</span> cb(value, context, Infinity);\n};\n</code></pre>\n<p>这个是给用户自定义迭代规则用的。怎么自定义呢，比如这样</p>\n<pre><code class=\"lang-js\">_.iteratee = <span class=\"keyword\">function</span>(value, context) {\n  <span class=\"comment\">// value 为对象时返回自身</span>\n  <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span> || _.isObject(value)) <span class=\"keyword\">return</span> _.identity;\n  <span class=\"keyword\">if</span> (_.isFunction(value)) <span class=\"keyword\">return</span> optimizeCb(value, context, argCount);\n  <span class=\"keyword\">return</span> _.property(value);\n}\n</code></pre>\n<p>还有 <code>identity</code> 其实就这样，返回一个返回自身的函数...</p>\n<pre><code class=\"lang-js\"><span class=\"comment\">// Keep the identity function around for default iteratees.</span>\n_.identity = <span class=\"keyword\">function</span>(value) {\n<span class=\"keyword\">return</span> value;\n};\n</code></pre>\n<p>我们自定义的这个迭代规则，如果 <code>value</code> 不为空而且是对象，则返回一个可以返回自身的函数。注意我们改变的只是 <code>iteratee</code> 函数，<code>builtinIteratee</code> 存的是默认规则，在 <code>cb</code> 函数中如果发现 <code>iteratee</code> 的行为更改了，则使用更改的行为来处理，否则往下默认处理，上面已经备注的很清楚了，自己看吧。\n我们举个例子说下 <code>cb</code> 函数的用法，例如</p>\n<pre><code class=\"lang-js\">_.map = _.collect = <span class=\"keyword\">function</span>(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    <span class=\"keyword\">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),\n        length = (keys || obj).length,\n        results = <span class=\"keyword\">Array</span>(length);\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> index = <span class=\"number\">0</span>; index &lt; length; index++) {\n      <span class=\"keyword\">var</span> currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    <span class=\"keyword\">return</span> results;\n};\n</code></pre>\n<p>注意我们是怎么使用 map 的，比如</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> results = _.map([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"keyword\">function</span>(value, index, obj) {\n  <span class=\"keyword\">return</span> &amp;<span class=\"comment\">#39;[&amp;#39;+obj+&amp;#39;]&amp;#39; + &amp;#39;\\&amp;#39;s &amp;#39;+index+&amp;#39; position is &amp;#39;+value;</span>\n});\n</code></pre>\n<p>我们使用 map 传入两个参数，一个是迭代对象，这里是 <code>[1, 2, 3]</code>，第二个参数是迭代函数，这里是 <code><span class=\"keyword\">function</span> (value, index, obj){...}</code>。这个函数在 map 内部也就是 <code>iteratee</code>，然后我们再来看</p>\n<pre><code class=\"lang-js\">iteratee = cb(iteratee, context)\n</code></pre>\n<p><code>iteratee</code> 是一个函数，使用上面这个句子返回了 <code>optimizeCb(value, context, argCount)</code>，这里的 <code>value</code> 就对应了我们的 <code><span class=\"keyword\">function</span>(value, index, obj){...}</code> 函数。接着回到 map，他对对象进行遍历依次把通过调用 <code>iteratee</code> 也就是我们传入的函数得到的结果复制给 <code>result</code>，最后返回了 <code>result</code>。\n所以上面例子的结果是</p>\n<pre><code class=\"lang-js\">results:  [\n    &quot;[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]&amp;<span class=\"comment\">#39;s 0 position is 1&quot;, </span>\n    &quot;[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]&amp;<span class=\"comment\">#39;s 1 position is 2&quot;, </span>\n    &quot;[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]&amp;<span class=\"comment\">#39;s 2 position is 3&quot;</span>\n];\n</code></pre>\n<p>一定要理解 cb 和 optimizeCb 这两个的用法，他们在后面多次用到。好了，完了～</p>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"Underscore源码学习(二).md","link":"/post/Underscore源码学习(二).html"},{"title":"一次项目重构","date":"2016-07-26T19:57:36.000Z","categories":"Angular","tags":["Angular","JavaScript"],"content":"<p>上学期由于期末停工的项目又要继续开展了，然而停了一个多月的时间，我已经看不下去他的代码了，简直惨不忍睹，花了我将近40个小时的时间去做了重构。虽然重构说明有进步了，但是一改就要改几十个页面啊...累觉不爱..说一说这次将近40小时的重构吧。\n{% asset_img git-diff.jpg git-diff %}</p>\n<h2 id=\"angular-\">Angular 重构</h2>\n<p>项目是基于 Angular 的 SPA，项目参考<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/i18n/zh-CN.md\">Angular规范</a>进行重构，主要是以下几点：</p>\n<ul>\n<li>把控制器的业务逻辑(主要是 HTTP 请求)分离到 Factory</li>\n<li>Controller 和 Directive 以及 Factory 全部用立即函数包装</li>\n<li>Controller 和 Directive 以及 Factory 内部书写格式</li>\n<li>使用 controllerAs 代替 $scope </li>\n<li>全部 JavaScript 文件使用 use strict 严格模式</li>\n<li>利用单体做部分数据的缓存</li>\n<li>提取大部分可复用模块到 directive</li>\n<li>全部 ng-repeat 加上 track by</li>\n<li>过大的试图使用 ng-include 进行分离</li>\n<li>去掉全部辅助变量，用 angular-promise-buttons 来达到按钮状态变化</li>\n<li>去掉全部页面切换动画</li>\n<li>手动进行依赖注入</li>\n<li>使用 ES6 语法，用 babel 转为 ES5</li>\n<li>使用 eslint 来做代码格式检查</li>\n</ul>\n<p>之前我几乎没有使用 Factory 这一层，全部业务逻辑都在 Controller 里面做，随着项目越来越大(有26个页面)，页面之间函数重复的情况很多，而且控制器太厚，可读性差，给维护带来了巨大的困难。在这次重构之中，我把全部的 HTTP 请求全部放在 Factory 实现，从而做到了以下几点：</p>\n<ul>\n<li>函数复用，多个控制器用一个 Factory，避免同个函数多次书写</li>\n<li>HTTP 请求返回 promise，结合 angular-promise-buttons 做到了按钮状态的自动变化以及过渡效果，去掉了先前实现同样目的的全部辅助变量</li>\n<li>对部分相对不变的数据，在第一次缓存后直接在该 Factory 进行缓存，第二次获取的时候直接返回内存中的数据，加快了部分页面的二次加载速度，对跨页面你的同个请求同样有效</li>\n<li>容易做单元测试和更改逻辑，因为全部 HTTP 请求都放在 Factory 实现，对后期修改以及代码测试都带来了很大的方便</li>\n</ul>\n<p>举个例子，这是我项目中的部分代码，现在是能拿出手了，以前的代码我都不能再吐槽了</p>\n<pre><code class=\"lang-js\"><span class=\"comment\">/** IndexCtrl.js */</span>\n(<span class=\"keyword\">function</span>() {                   <span class=\"comment\">// 立即执行函数，避免作用域污染</span>\n    &amp;<span class=\"comment\">#39;use strict&amp;#39;;               // 严格模式，使代码更规范</span>\n                                <span class=\"comment\">// 空一行</span>\n    angular                     <span class=\"comment\">// Angular控制器定义，控制器函数使用命名行数</span>\n        .module(&amp;<span class=\"comment\">#39;index&amp;#39;)</span>\n        .controller(&amp;<span class=\"comment\">#39;IndexCtrl&amp;#39;, IndexCtrl);</span>\n\n    IndexCtrl.<span class=\"variable\">$inject</span> = [&amp;<span class=\"comment\">#39;bookservice&amp;#39;, &amp;#39;booklistservice&amp;#39;, &amp;#39;slideservice&amp;#39;];     // 手动依赖注入</span>\n                                                                                <span class=\"comment\">// 再空一行</span>\n    <span class=\"keyword\">function</span> IndexCtrl(bookservice, booklistservice, slideservice) {            <span class=\"comment\">// 控制器函数</span>\n        <span class=\"keyword\">var</span> vm = <span class=\"keyword\">this</span>;                                                          <span class=\"comment\">// 不使用$scope</span>\n        vm.myInterval = <span class=\"number\">5000</span>;\n\n        vm.getHotBooklists = getHotBooklists;                                   <span class=\"comment\">// 置顶绑定成员，函数声明隐藏实现细节</span>\n\n        getPopularBooks();                                                      <span class=\"comment\">// 即时只使用一次，也推荐封装成函数</span>\n        getSlides();\n\n        <span class=\"keyword\">function</span> getPopularBooks() {\n            <span class=\"keyword\">return</span> bookservice.getPopularBooks().then(response =&gt; {\n                vm.books = response;\n            });\n        }\n\n        <span class=\"keyword\">function</span> getHotBooklists() {\n            <span class=\"keyword\">return</span> booklistservice.getHotBooklists().then(response =&gt; {\n                vm.booklists = response;\n            });\n        }\n\n        <span class=\"keyword\">function</span> getSlides() {\n            <span class=\"keyword\">return</span> slideservice.getSlides().then(response =&gt; {\n                vm.slides = response;\n            });\n        }\n    }\n})();\n</code></pre>\n<p>然后是 Factory 文件</p>\n<pre><code class=\"lang-js\"><span class=\"comment\">/** SlideService.js */</span>\n(<span class=\"keyword\">function</span>() {\n    &amp;<span class=\"comment\">#39;use strict&amp;#39;;</span>\n\n    angular\n        .module(&amp;<span class=\"comment\">#39;index&amp;#39;)</span>\n        .factory(&amp;<span class=\"comment\">#39;slideservice&amp;#39;, slideservice);</span>\n\n    slideservice.<span class=\"variable\">$inject</span> = [&amp;<span class=\"comment\">#39;$http&amp;#39;, &amp;#39;$q&amp;#39;];</span>\n\n    <span class=\"keyword\">function</span> slideservice(<span class=\"variable\">$http</span>, <span class=\"variable\">$q</span>) {\n        let slides = <span class=\"keyword\">null</span>;\n\n        <span class=\"keyword\">return</span> {\n            getSlides: getSlides\n        };\n\n        <span class=\"keyword\">function</span> getSlides() {\n            <span class=\"keyword\">if</span>(slides === <span class=\"keyword\">null</span>) {\n                <span class=\"keyword\">return</span> <span class=\"variable\">$http</span>.get(host + &amp;<span class=\"comment\">#39;/slides&amp;#39;)</span>\n                    .then(response =&gt; {\n                        slides = response.data;         <span class=\"comment\">// 第一次获取后存入内存</span>\n                        <span class=\"keyword\">return</span> slides;\n                    });\n            } <span class=\"keyword\">else</span> {\n                let deferred = <span class=\"variable\">$q</span>.defer();\n                deferred.resolve(slides);\n                <span class=\"keyword\">return</span> deferred.promise;                <span class=\"comment\">// 将数据封装入promise返回，保证透明性</span>\n            }\n        }\n    }\n})();\n</code></pre>\n<p>directive 就不给示例了，上面主要参考了这个<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/i18n/zh-CN.md\">Angular规范</a>。这样写真的比我之前写的好了几百倍，controller 和 factory 和 directive 都按这个规范来，代码会很好维护。</p>\n<p>这次重构让我知道我以前写的根本不叫 Angular，写的是一坨翔，MLGB 害我改了四天。</p>\n<h2 id=\"html-\">HTML 重构</h2>\n<p>其实说白了也是 Angular 重构，在上面的 Angular 重构已经提到了一些了，但是上面主要是说 controller 和 factory，这里说下 directive 和视图。</p>\n<h3 id=\"-\">部分页面复用</h3>\n<p>在 Angular 中，HTML 部分复用有两种方案，一种是使用 ng-include，还有一种是使用 directive，其实区别很简单，ng-include 只是很简单的 HTML 复用，而 directive 你可以传递参数，directive 可以有自己的控制器，可以操纵 DOM，其实就是 HTML 和 JavaScript 文件的区别。不过这只是 directive 在页面复用这一块的作用，其实 directive 强大的很。</p>\n<h3 id=\"-ng-repeat-track-by\">使用 ng-repeat 都带上 track by</h3>\n<p>对于 ng-repeat 使用 track by 可以提升性能，对于任何 ng-repeat 都加上 track by 是一个好习惯。比如</p>\n<pre><code class=\"lang-html\">&lt;ul&gt;\n    &lt;li ng-repeat=&quot;book in vm.books track by book.isbn&quot;&gt;{{book.title}}&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<p>也可以直接使用 track by $index。</p>\n<h3 id=\"-controlleras\">使用 controllerAs</h3>\n<p>直接在路由使用 controllerAs </p>\n<pre><code class=\"lang-js\">.state(&amp;<span class=\"comment\">#39;index&amp;#39;, {</span>\n    url: &amp;<span class=\"comment\">#39;/&amp;#39;,</span>\n    views: {\n        &amp;<span class=\"comment\">#39;main&amp;#39;: {</span>\n            templateUrl: &amp;<span class=\"comment\">#39;index/index_tpl.html&amp;#39;,</span>\n            controller: &amp;<span class=\"comment\">#39;IndexCtrl&amp;#39;,</span>\n            controllerAs: &amp;<span class=\"comment\">#39;vm&amp;#39;</span>\n        }\n    }\n})\n</code></pre>\n<p>然后在视图中就像上面的例子，在访问控制器的变量和方法的时候都要带上 vm，虽然这样会稍微麻烦了一点，但是可以避免很多坑，而且这种写法更接近 JavaScript 原生的写法。</p>\n<h2 id=\"css-\">CSS 重构</h2>\n<p>恩，CSS 重构才是真正的大坑，先说下我之前是怎么写 CSS 代码的</p>\n<ul>\n<li>使用了 Sass 预处理器</li>\n<li>多层嵌套</li>\n<li>命名混乱</li>\n<li>过多复用</li>\n<li>全部挤在一个文件</li>\n</ul>\n<p>恩，挤在一个文件里面是最要命的，而且很任性的进行嵌套，导致多了或者少了一层都可能出问题，而且是2000多行的代码...所以我其实并没有做什么重构，我把它从一个文件分成了很多个文件，每个视图一个专属 scss 文件，对于复用的部分页面，用 directive 替代，并给该 directive 专属的 scss 文件。\n怎么做到专属呢，就是每个视图和每个 scss 都包装在一个类名里面，这样就保证了 scss 代码互不干扰。\n所以，其实我做的只是便于后期书写而已，总不能继续在这个文件书写下去，大坑啊。。</p>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"一次项目重构.md","link":"/post/一次项目重构.html"},{"title":"JavaScript 闭包，继承与原型链","date":"2016-07-22T15:03:23.000Z","categories":"JavaScript","tags":["JavaScript"],"content":"<p>JavaScript 闭包和原型链学习心得，如果有不对的地方望指出。</p>\n<h2 id=\"-\">闭包</h2>\n<p>什么是闭包，有很多说法，我的理解是一个函数可以记住和使用外部变量，保存这个变量的引用在自己的一个环境之中。\n例如：</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">function</span> makeAdder(x) {\n  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(y) {\n    <span class=\"keyword\">return</span> x + y;\n  };\n}\n\n<span class=\"keyword\">var</span> add5 = makeAdder(<span class=\"number\">5</span>);\n<span class=\"keyword\">var</span> add10 = makeAdder(<span class=\"number\">10</span>);\n\nconsole.log(add5(<span class=\"number\">2</span>));  <span class=\"comment\">// 7</span>\nconsole.log(add10(<span class=\"number\">2</span>)); <span class=\"comment\">// 12</span>\n</code></pre>\n<p>这个例子中， makeAdder 是一个函数工厂，add5 和 add10 就是闭包，他们记住了外部变量 x。通常一个函数执行完毕后其运行期上下文会被释放，但由于闭包的属性包含了与运行期上下文作用域链相同的对象引用，导致这个激活对象无法销毁，这就会导致内存消耗，另外，闭包内部的作用域链并不处在闭包作用域链的前端，并且闭包经常使用外部变量的话，导致对象属性的遍历经常到其原型上面去（一个解决方法是把他赋值到闭包自身的作用域上面），从而增加性能消耗。\n既然闭包会导致内存增加和性能消耗，那为什么那么多人还使用它呢？上面的例子可能不太能说明问题，我们看下其他例子。</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> Counter = (<span class=\"keyword\">function</span>() {\n  <span class=\"keyword\">var</span> privateCounter = <span class=\"number\">0</span>;\n  <span class=\"keyword\">function</span> changeBy(val) {\n    privateCounter += val;\n  }\n  <span class=\"keyword\">return</span> {\n    increment: <span class=\"keyword\">function</span>() {\n      changeBy(<span class=\"number\">1</span>);\n    },\n    decrement: <span class=\"keyword\">function</span>() {\n      changeBy(-<span class=\"number\">1</span>);\n    },\n    value: <span class=\"keyword\">function</span>() {\n      <span class=\"keyword\">return</span> privateCounter;\n    }\n  }   \n})();\n\nconsole.log(Counter.value()); <span class=\"comment\">/* logs 0 */</span>\nCounter.increment();\nCounter.increment();\nconsole.log(Counter.value()); <span class=\"comment\">/* logs 2 */</span>\nCounter.decrement();\nconsole.log(Counter.value()); <span class=\"comment\">/* logs 1 */</span>\n</code></pre>\n<p>这个例子中外部只能通过 value 方法获取 privateCounter 的值，只能通过 increment 和 decrement 方法来改变 privateCounter 的值，无法直接获取到 priavateCounter 和调用 changeBy 函数。这种模式叫 module模式，因为大部分模块都是这样写的，包括 Underscore 也是这样。上篇中就说道了 Underscore 使用了立即执行函数，其用途其一是为了不污染外部变量，因为 JavaScript 是函数作用域，其次它利用了闭包的特性又可以保持函数内部闭包的可调用和被闭包所引用变量在闭包环境中的存在，同时函数内部可以定义一些私有变量和私有方法。我们无需担心这些变量和函数在外部函数执行完毕结束后的失效。\n当你看到函数里面又 return 函数时，同时该函数又使用了外部变量，则该函数就是一个闭包。\n关于闭包还有一个很容易犯错的地方，比如你想实现第一秒输出1,第二秒输出2,以此类推。</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) {\n    setTimeout(<span class=\"keyword\">function</span> timer() {\n        console.log(i);\n    }, i*<span class=\"number\">1000</span>);\n}\n</code></pre>\n<p>但是实际运行结果是第一秒输出6,第二秒输出6...\n闭包是记住了外部变量的引用，每次循环都建立了一个 timer 函数，但 console 并还没有被执行，当循环结束后确实是建立了5个计时器或者说5个闭包，但当开始执行 console 的时候，由于这些闭包所引用的 i 此时结果为6，所以会输出5次 6。\n更能说明问题些，我们稍作修改下：</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) {\n    setTimeout(<span class=\"keyword\">function</span> timer() {\n        console.log(i);\n        i++;\n    }, i*<span class=\"number\">1000</span>);\n}\n</code></pre>\n<p>结果是第一秒输出1，第二秒输出2...\n我们也可以这么做</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) {\n    let j = i;\n    setTimeout(<span class=\"keyword\">function</span> timer() {\n        console.log(j);\n    }, j*<span class=\"number\">1000</span>);\n}\n</code></pre>\n<p>或者这样做</p>\n<pre><code class=\"lang-javascript\"><span class=\"keyword\">for</span> (let i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span> ; i++) {\n    setTimeout(<span class=\"keyword\">function</span> timer() { \n        console.log(i); \n    }, i*<span class=\"number\">1000</span>);\n}\n</code></pre>\n<p>结果和上面一样，第一秒输出1，第二秒输出2...</p>\n<p>这是为什么呢？第二个例子说明了闭包内使用的是外部变量的引用，他们都使用了同一个引用，所以最终输出取决与此时这个引用的值。第三个例子，每次循环都会新建一个变量 j，分别被每个闭包所引用，这些引用互不干扰，我们可以在 console.log(j) 后面加上 j++，结果是不会有变化的。</p>\n<h2 id=\"-\">继承与原型链</h2>\n<blockquote>\n<p>在 javaScript 中，每个对象都有一个指向它的原型（prototype）对象的内部链接。这个原型对象又有自己的原型，直到某个对象的原型为 null 为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链结构就称为原型链（prototype chain）。</p>\n</blockquote>\n<p>第一次接触 JavaScript 的原型链是在使用 Angular 的时候，如果有看到前面我的一篇写 Angular 的就会看到。在使用 Angular 的 ngIf 和 textarea 时，会创建新的子作用域，子作用域的原型是父级作用域一般就是 scope，以 textarea 为例子，假设一个用户修改评论的 textarea 框，我们首先把原先的评论写了回去，假设我们这样使用</p>\n<pre><code class=\"lang-html\">&lt;textarea ng-model=&quot;content&quot;, name=&quot;content&quot; <span class=\"keyword\">class</span>=&quot;form-control&quot; row=&quot;<span class=\"number\">3</span>&quot;&gt;&lt;/textarea&gt;\n</code></pre>\n<p>我们把用户的评论内容放到 $scope.content 里面去。\n结果是我们可以看到 textarea 确实一开始就被填入了用户原先的评论，可是如果此时我们更改 textarea 内部的内容，然后提交修改。你会发现 $scope.content 没有发生变化。\n这是因为 Angular 默认在 textarea 创建了一个新的子作用域，这个作用域本身一开始并不存在 content 这个值，即没有 hasOwnProperty(&#39;content&#39;)，但他并不会因此就不做显示了，他会去找其原型，一般是 scope (如果在 ng-if 使用了 textarea，则其原型的原型才是 scope )，如果原型存在 content 则继承原型。所以你会看到初始状态是没问题的，当你修改评论内容时候，此时 textarea 自身的作用与就会新建了一个 content，内容就为你的评论内容，而其原型的 scope 将不再被使用，也不会被修改，所以你会发现 $scope.content 并没有发生变化。\n如果 textarea 的原型也不存在 content，它会再往上找，直到原型链最顶端为止，处在原型链最顶端的对象的原型是 null。\n以 Angular 的这个例子，我们就介绍完了 JavaScript 的原型链和继承，我们再举个例子说明下。</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> stu = {name: &quot;stu&quot;, age: <span class=\"number\">18</span>, school: &quot;SCNU&quot;};\n<span class=\"keyword\">var</span> father = {name: &quot;<span class=\"keyword\">parent</span>&quot;, age: <span class=\"number\">40</span>, job: &quot;engineer&quot;, company: &quot;Google&quot;};\nstu.__proto__ = father;\nconsole.log(stu.job)    <span class=\"comment\">/* logs &quot;engineer&quot; */</span>\nstu.job = &quot;student&quot;\nconsole.log(stu.job)    <span class=\"comment\">/* logs &quot;student&quot; */</span>\nconsole.log(father.job) <span class=\"comment\">/* logs &quot;engineer&quot; */</span>\n<span class=\"keyword\">for</span>( prop in stu ) {\n    console.log(stu.prop);  <span class=\"comment\">/* logs stu, 18, SCNU, student, Google */</span>\n}\n</code></pre>\n<p>使用for...in...会遍历对象的所有属性，一个解决方法是使用 hasOwnProperty 判断是否是该层的属性。</p>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"JavaScript闭包，继承与原型链.md","link":"/post/JavaScript闭包，继承与原型链.html"},{"title":"Underscore 源码学习(一)","date":"2016-07-20T15:52:11.000Z","categories":"Underscore","tags":["Underscore","JavaScript"],"content":"<p>暑假打算研究一下 Underscore 源码，我会对一些我觉得比较有意思的点拿出来讨论下，不过我不会过多介绍，也不会去分析 Underscore 的各个方法，但我会附上一些相关的不错的参考资料。由于我也是初学阶段，所以如果有说的不正确的地方望指出。</p>\n<h2 id=\"-1-\">要点1：立即执行函数</h2>\n<p>Underscore 的内容都用这么一个东西包装起来了。</p>\n<pre><code class=\"lang-js\">(<span class=\"keyword\">function</span>(){..}());\n</code></pre>\n<p>其实也可以这样写</p>\n<pre><code class=\"lang-js\">(<span class=\"keyword\">function</span>(){})();\n</code></pre>\n<p>Underscore 把全部内容封装在立即执行函数里面，就形成了一个独立的作用域，与外部隔离，并且这样做还形成了闭包，可以模拟私有方法。\n推荐阅读：</p>\n<ul>\n<li><a href=\"http://benalman.com/news/2010/11/immediately-invoked-function-expression/\">immediately-invoked-function-expression(英)</a></li>\n<li><a href=\"http://www.cnblogs.com/tomxu/archive/2011/12/31/2289423.html\">immediately-invoked-function-expression(中)</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000003902899\">JavaScript中的立即执行函数</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures\">Closures</a></li>\n</ul>\n<h2 id=\"-2-node-\">要点2：兼容浏览器和 Node 环境</h2>\n<p>浏览器和服务端的一个主要区别是全局对象命名的不同，在浏览器全局变量是 window，在服务端即 Node 环境则是 global。</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> root = typeof <span class=\"keyword\">self</span> == &amp;<span class=\"comment\">#39;object&amp;#39; &amp;&amp; self.self === self &amp;&amp; self ||</span>\n           typeof <span class=\"keyword\">global</span> == &amp;<span class=\"comment\">#39;object&amp;#39; &amp;&amp; global.global === global &amp;&amp; global ||</span>\n           <span class=\"keyword\">this</span>;\n</code></pre>\n<p>这个地方之前的写法是这样的</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> root = <span class=\"keyword\">this</span>;\n</code></pre>\n<p>我认为之所以改成前面那种写法，可能是为了确保 root 指向 global 或者 window(self) 。大部分框架和库都采用这种做法，这种做法更加安全。</p>\n<pre><code class=\"lang-js\"><span class=\"comment\">// 这一步确保self是一个object，这样self.self才不会出错</span>\ntypeof <span class=\"keyword\">self</span> == &amp;<span class=\"comment\">#39;object&amp;#39;</span>\n<span class=\"comment\">// 这一步确保self.self严格等于自身，貌似只有window具备这个特性</span>\n<span class=\"comment\">// 即window === window.window.window</span>\n<span class=\"keyword\">self</span>.<span class=\"keyword\">self</span> === <span class=\"keyword\">self</span>\n<span class=\"comment\">// 为什么还要进行这一步？</span>\n<span class=\"keyword\">self</span>\n</code></pre>\n<p>推荐阅读：</p>\n<ul>\n<li><a href=\"https://zzz.buzz/2016/06/30/the-global-object-in-various-javascript-environments/\">The Global Object in Various JavaScript Environments</a></li>\n</ul>\n<h2 id=\"-3-\">要点3：提供命名冲突解决方法</h2>\n<p>Underscore 在给 root 赋值前，先保存了原先 root 的 <code>_</code> 对象。之所以这样做，是因为可能我们用的其他库也使用了 <code>_</code> 这个作为命名空间。</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> previousUnderscore = root._;\n</code></pre>\n<p>我们结合 Underscore 最下面的这个方法来看。</p>\n<pre><code class=\"lang-js\">_.noConflict = <span class=\"keyword\">function</span>() {\n    root._ = previousUnderscore;\n    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;\n};\n</code></pre>\n<p>如果 <code>_</code> 出现了冲突，可以使用下面方法</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> _<span class=\"keyword\">new</span> = _.noConflict();\n</code></pre>\n<p>这样一来应该很明显了，<code>noConflict</code> 将 <code>previousUnderscore</code> 即原先的 <code>root._</code> 重新放回去，然后重新定义 Underscore 命名给 <code>_<span class=\"keyword\">new</span></code>，这样就解决了 <code>_</code> 冲突问题。</p>\n<h2 id=\"-4-\">要点4：考虑压缩问题</h2>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> ArrayProto = <span class=\"keyword\">Array</span>.prototype, ObjProto = Object.prototype;\n<span class=\"keyword\">var</span> SymbolProto = typeof Symbol !== &amp;<span class=\"comment\">#39;undefined&amp;#39; ? Symbol.prototype : null;</span>\n<span class=\"keyword\">var</span> push = ArrayProto.push,\n    slice = ArrayProto.slice,\n    toString = ObjProto.toString,\n    hasOwnProperty = ObjProto.hasOwnProperty;\n</code></pre>\n<p>这里首先说一下<code>Symbol</code>，ES5 规定了六种语言类型即 Null, Undefined, Number, Boolean, String, Object，而新出台的 ES6 则新增了 Symbol。关于 Symbol 查看推荐阅读。\n这里把 Array 和 Object 和 Symbol 的原型都用变量来引用的原因是变量可以进行压缩，如果有使用过代码压缩工具的话，一个常见的压缩技巧就是用短变量名代替长变量名，而对于一些出现频率高的方法我们可以用变量来进行引用来便于压缩。\n而 push, slice, toString, hasOwnProperty 这些引用不仅便于压缩，还可以减少在原型链中的查找次数，提高速度。即直接在原型上操作，避免原型链查找。关于原型链是个大问题了，这里不打算过多讲解（其实是我也不怎么懂），下一篇再进行介绍。\n还有一个地方顺便提一下的是，Underscore 的源码不使用 undefined 而是使用 <code>void  0</code>。这个也是代码压缩的时候会做的事情。虽然从 ES5 开始 undefined 是全局对象的只读属性不能重写，但是在局部作用域中仍然可以被重写，而 <code>void</code> 运算符能对给定的表达式进行求值，然后返回 undefined，可以保证返回的是 undefined，<code>void</code>不能重写。再者，之所以跟的是0，只是因为0短并且习惯问题而已。\n推荐阅读：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void\">operators-void</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\">Symbol</a></li>\n</ul>\n<h2 id=\"-5-apply-call-bind\">要点5：区别apply, call和bind</h2>\n<p>在 Underscore 源码中我们会经常看到 apply 和 call 的应用。例如：</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">switch</span> (startIndex) {\n    <span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"keyword\">return</span> func.call(<span class=\"keyword\">this</span>, rest);\n    <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> func.call(<span class=\"keyword\">this</span>, arguments[<span class=\"number\">0</span>], rest);\n    <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"keyword\">return</span> func.call(<span class=\"keyword\">this</span>, arguments[<span class=\"number\">0</span>], arguments[<span class=\"number\">1</span>], rest);\n}\n<span class=\"keyword\">var</span> args = <span class=\"keyword\">Array</span>(startIndex + <span class=\"number\">1</span>);\n<span class=\"keyword\">for</span> (index = <span class=\"number\">0</span>; index &lt; startIndex; index++) {\n    args[index] = arguments[index];\n}\nargs[startIndex] = rest;\n<span class=\"keyword\">return</span> func.apply(<span class=\"keyword\">this</span>, args);\n</code></pre>\n<p>apply 和 call 都是为了改变某个函数运行时的 context 即上下文而存在的，即改变函数提内部 this 的指向，他们的功能是相同的，只是用法稍有不同。</p>\n<pre><code class=\"lang-js\"><span class=\"keyword\">var</span> func1 = <span class=\"keyword\">function</span>(arg1, arg2) {};\n<span class=\"comment\">// 可以通过下面两个方法来调用</span>\nfunc1.call(<span class=\"keyword\">this</span>, arg1, arg2);\nfunc1.apply(<span class=\"keyword\">this</span>, [arg1, arg2]);\n</code></pre>\n<p>即 call 传递的是参数列表，而 apply 传递的是数组，当我们知道参数的数量时使用 call 方法，不知道参数数量时可以把参数放到一个数组然后使用 apply 方法调用。bind 也可以更改函数执行的上下文但是不同的是，bind 只进行绑定不会立即调用。\n再看看上面 Underscore 源码中的一部分，对于<code>startIndex</code>小于3的情况，他分别使用了 call 方法调用，而当<code>startIndex</code>大于3的时候，则将参数转为数组形式使用 apply 方式调用。为什么不直接用 apply 方法呢？\n简而言之，apply 比 call 慢。\n对于 apply 方法，Function 会检查传入的参数的类型是否符合要求，还要进行解构操作等等。所以应该尽量使用 call 方法。\nUnderscore 源码关于这段代码还有个地方值得注意</p>\n<pre><code class=\"lang-js\">startIndex = startIndex == <span class=\"keyword\">null</span> ? func.length - <span class=\"number\">1</span> : +startIndex;\n</code></pre>\n<p>为什么使用 <code>+startIndex</code>？\n<code>+</code>运算符尝试将后面的数转为数字，例如将字符串(&quot;123&quot;)转为数(123)，对数字不会产生影响，如果传入(&quot;123NASD&quot;)，会得到 NaN 。\n推荐阅读：</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/23769556/why-is-call-so-much-faster-than-apply/23770316#23770316\">why-is-call-so-much-faster-than-apply</a></li>\n</ul>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"Underscore源码学习(一).md","link":"/post/Underscore源码学习(一).html"},{"title":"ARP 攻击和无线网卡混杂模式","date":"2016-07-14T12:32:41.000Z","categories":"网络安全","tags":["Hack"],"content":"<p>一次小小的 Hack 尝试...\n前段时间换上了 Arch，就开始想这捣鼓一些黑科技。脑海中立即浮现出两个词， monitor 和 ARP 。</p>\n<h2 id=\"arp-\">ARP 攻击</h2>\n<p>学过计算机网络了，大概了解ARP攻击这么一回事，但是当我真正去试的时候，才发现局域网原来真的这么脆弱，因为进行ARP攻击实在太容易了。实际上就是几条命令的事情。</p>\n<h3 id=\"-\">主机发现和端口扫描</h3>\n<p>进行攻击第一步当然就是找目标了。可以使用 nmap 这个工具来进行，这东西简直渗透利器。</p>\n<pre><code>nmap -sP 192.168.1.0/24\n</code></pre><p> 这样就可以扫描192.168.1.0这个网段里面的所有主机了，以 ping 方式扫描，当然他有很多参数很多用法，网上很多这方面的资料我就不叙述了。\n{% asset_img nmap.png Nmap扫描 %}</p>\n<h3 id=\"-\">发起攻击</h3>\n<p>如果是进行ARP攻击，那也是加多三条命令就搞定的事情。</p>\n<pre><code class=\"lang-bash\"><span class=\"keyword\">echo</span> <span class=\"number\">1</span> &gt;&gt; /proc/sys/net/ipv4/ip_forward\narpspoof -i wlp3s0 -t <span class=\"number\">192.168</span>.<span class=\"number\">1.110</span> <span class=\"number\">192.168</span>.<span class=\"number\">1.1</span>\narpspoof -i wlp3s0 -t <span class=\"number\">192.168</span>.<span class=\"number\">1.1</span>   <span class=\"number\">192.168</span>.<span class=\"number\">1.110</span>\n</code></pre>\n<p>第一条是开启转发，不然会受害者流量到我们这里出不去就断网了。\n第二条是告诉受害者说我是网管。\n第三条是告诉网管我是受害者。\n这样就完成了 ARP 欺骗，图片以后再补。这之后对方的网络就完全在你的监控之下了。这告诉我们使用 https 和不连接免费 wifi 的重要性!</p>\n<h3 id=\"-\">抓包</h3>\n<p>抓包推荐使用 wireshark 。具体就不介绍了=.=。你还可以使用 Driftnet 这东西来将对方访问的图片在你这边显示出来～</p>\n<h2 id=\"-\">监听空气包</h2>\n<p>大部分无线网卡都可以设置 monitor 模式，即无线网卡默认接受下全部经过他的以太网帧而不丢弃，这种方式可以抓到附近范围里面的所以以太网帧。在 Arch 下也是三条命令搞定的事情。</p>\n<pre><code class=\"lang-bash\">ifconfig wlp3s0 down\niwconfig wlp3s0 mode monitor\nifconfig wlp3s0 up\n</code></pre>\n<p>接着同样开启 wireshark 抓包，你会发现很多802.11帧，不过这个并没有什么卵用，理论上应该对于没有加密的帧应该可以直接得到应用层报文才对，但是很奇怪我一直抓不到，即使是对于有加密的 Wifi，我填入 WAPKEY 解密也不行。这个有待继续研究。。。</p>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"ARP攻击和无线网卡混杂模式.md","link":"/post/ARP攻击和无线网卡混杂模式.html"},{"title":"从输入 URL 到页面展示","date":"2016-06-24T15:43:38.000Z","categories":"HTTP","tags":["DNS","HTTPS","HTTP","DNS","TCP/IP","Webkit"],"content":"<p>本文从网络层以上讨论从浏览器输入 HTTPS 协议的 URL 到页面展现的全过程。由于不同浏览器之间也存在差异，这里以 Chrome 浏览器为例。</p>\n<h2 id=\"1-dns-\">1. DNS查询</h2>\n<p>DNS 缓存有好几个环节，浏览器缓存，系统缓存，路由器缓存，ISP 缓存。</p>\n<ul>\n<li><p>浏览器首先会查看自身是否已经有进行 DNS 缓存。Chrome 可以通过 <code>chrome:<span class=\"comment\">//net-internals/#dns</span></code> 查看缓存的 DNS，浏览器的 DNS 缓存可以加快 DNS 解析速度，但缓存时间不会太长。</p>\n<p>{% asset_img  chrome-dns-cache.png Chrome 的 DNS 缓存 %}</p>\n</li>\n<li><p>如果浏览器没有相应的缓存，则查找系统缓存，浏览器会向系统发送一个查询请求，如果系统存在缓存或者设置了 host ，则返回相应的 ip 地址给浏览器。</p>\n</li>\n<li><p>如果系统没有缓存，那么它会发出一个 DNS 查询请求给路由器。</p>\n<p>如果路由器有 DNS 缓存，他会提取出 IP 地址返回。否则，他会向本地域名服务器发出查询，从请求主机到本地域名服务器的请求一般是递归查询，而其他的查询一般是迭代查询。</p>\n<p>{% asset_img client-to-server-query.gif DNS 请求主机到本地域名服务器的查询 %}</p>\n<p>{% asset_img server-to-server-query.gif DNS 域名服务器之间的查询 %}</p>\n<p>请求报文如下</p>\n<p>{% asset_img  dns-request-1.png DNS 请求报文 %}</p>\n<p>我们先简单分析下请求报文。</p>\n<ol>\n<li>DNS 使用 UDP 协议，端口号53。</li>\n<li>在 DNS 报文的 Flags 中的 RD=1。表示它建议域名服务器以递归方式查询。</li>\n<li>Question section format 需要给出 <code>QNAME</code>, <code>QTYPE</code>, <code>QCLASS</code>。即查询的域名，查询的类型以及查询的类。</li>\n</ol>\n<p>有关<code>DNS</code>报文的更多信息可以参考<a href=\"https://www.ietf.org/rfc/rfc1035\">RFC1035</a></p>\n<p>响应报文如下</p>\n<p>{% asset_img  dns-response-1.png DNS 响应报文 %}</p>\n<p>我们也简单分析下，如果想详细了解，可以查看上面的 <code>RFC1035</code> 标准。</p>\n<ol>\n<li>与请求报文相比，对比 Flags 可以发现，QR=1 表示这是一个响应报文。RA=1 表示递归查询可用。</li>\n<li>ARecord 记录了DNS请求获得的一个或多个IP地址。一般还会得到 CNAME 记录和存活时间等信息。</li>\n<li>这里对 Rcode 也稍加说明下，Rcode=0 表示成功，他还有好几种状态码，比如1表示 <code>Format error</code>，2表示 <code>Server failure</code>，3表示 <code>Name error</code>，4表示 <code>Not lmplemented</code>，5表示 <code>Refused</code>，具体信息可以参考 <code>RFC1035</code>。</li>\n</ol>\n</li>\n</ul>\n<!--more-->\n<h2 id=\"2-\">2. 三次握手建立连接</h2>\n<p>经过上述过程，此时浏览器得到了要访问的域名的 IP 地址。由于 DNS 查询需要一定时间，所以有些网站会使用 DNS Prefetching 进行 DNS 预解析，结合浏览器的 DNS 缓存，以加快网站速度。这里不做详细叙述。</p>\n<p>首先贴出 TCP 三次握手的建立图。</p>\n<p>{% asset_img tcp-shake-hands.jpg 三次握手 %}</p>\n<p>我们抓包依次进行分析。</p>\n<ol>\n<li><p>第一个握手包</p>\n<p>{% asset_img tcp-shake-hands-1.png 第一个握手包 %}</p>\n<p>从这个包我们可以得到以下信息:</p>\n<ul>\n<li>Seq = 2988862522 这个是本报文段所发送的数据的第一个字节的序号</li>\n<li><p>DataOffset = 32（字节） 指明 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远</p>\n</li>\n<li><p>SYN = 1 SYN=1 而 ACK=0 时表示这是一个连接请求报文。</p>\n</li>\n<li>Window = 8192（字节） 客户端滑动窗口8192字节，滑动窗口协议是设计来提高报文段的传输效率，这里不详细叙述，可以自己查资料。</li>\n<li>Checksum = 0x5818 校验和，校验和字段校验的范围包括首部和数据这两个部分，在计算校验和时，要在 TCP 报文段的前面加上12字节的伪首部。接收方接收到此报文段后，加上这个伪首部来计算校验和。校验和是用来保证数据的无差错。</li>\n<li>MaxSegmentSize = 1460（字节） 即 MSS，表示 TCP 报文段中数据字段的最大长度。注意它加上 TCP 首部才等于整个的 TCP 报文。有关 MSS 的信息自己查资料。</li>\n</ul>\n<p>比较重要的就是上述信息，客户端需要在第一次发包时要告知自身的一些信息。</p>\n</li>\n<li><p>第二个握手包</p>\n<p>{% asset_img tcp-shake-hands-2.png 第二个握手包 %}</p>\n<p>在接收到客户端发来的握手包后，服务端进行应答，我们对这个包进行分析：</p>\n<ul>\n<li>Seq = 1648068786</li>\n<li>Ack = 2988862523 表示服务端期望收到对方的下一个报文段的第一个数据字节的序号。</li>\n<li>ACK = 1 当 ACK=1 时确认号字段有效。</li>\n<li>SYN = 1 ACK=1 且 SYN=1 表示这是一个同意建立连接的响应报文。</li>\n<li>Window = 63343（字节） 服务端的滑动窗口为63343字节。</li>\n<li>MaxSegmentSize = 1448（字节） 服务端的 TCP 报文中数据字段的最大长度为1448字节。</li>\n</ul>\n<p>在前两次握手时，双方交换一些信息如 Window 和 MSS，确定 seq 和 ack 起始号。</p>\n</li>\n<li><p>第三个握手包</p>\n<p>{% asset_img tcp-shake-hands-3.png 第三个握手包 %}</p>\n<p>服务端接受请求后，客户端还需要在发送一个握手包。这个握手包明显信息更少了，同样我们查看一些关键值：</p>\n<ul>\n<li>Seq = 2988862523 由于上一个握手包没有携带正文信息，不占用字节空间，所以 Seq 与上一个握手包的 Ack 值相同。</li>\n<li>Ack = 1648068787 同上，双方建立通信之后是会进行数据交换，同样的，这个地方表示客户端期望收到对方的下一个报文段的第一个数据字节的序号。</li>\n<li>ACK = 1 表示对上一个握手包的确认</li>\n<li>Window = 260（字节） TCP 的发送窗口时会不断变化的，TCP 的流量控制和拥塞控制会根据情况动态地调整发送窗口上限值，从而控制发送数据的平均速率。</li>\n</ul>\n</li>\n</ol>\n<p>自此三次握手完成，连接建立，可以开始传输数据。</p>\n<h2 id=\"3-https-\">3. 建立HTTPS连接</h2>\n<p>以上完成握手，只能建立 HTTP 连接。但如果网站使用了 HTTPS 协议，那么还需要进行 SSL/TLS 握手。</p>\n<p>在这之前，我们先介绍下 SSL/TLS。</p>\n<p>SSL/TLS 是一种互联网安全加密技术。HTTP 报文是进行明文传输的，这意味着用户的 cookie 或者其提交的信息比如账号和密码都是在互联网上裸奔，如果这个报文被其他人抓取到，会带来很大的不安全性。使用 HTTPS 协议是非常有必要的，并且目前最新的 HTTP2 规范也仅支持 HTTPS。而 SSL/TLS 协议位于 TCP/IP 协议与各个应用层协议之间，为数据通信提供安全支持。他们可以分为记录协议和握手协议。</p>\n<p>那么 SSL 和 TLS 又有什么区别呢？</p>\n<p>简单的说，TLS 的建立在 SSL 3.0 协议规范之上的，是 SSL v3 的强化版，在整个协议格式上和 SSL 类似。TLS 增强了加密算法，并带来了更严格的警报，在安全性方面有很多改进。</p>\n<p>关于 HTTP 与 HTTPS 和 SSL 与 TLS 的具体差别自行搜索。</p>\n<p>{% asset_img ssl-tls-protocol.png SSL/TLS Protocol %}</p>\n<p>关于 SSL/TLS 协议这里不做详解，此处主要讲述 TLS 握手的建立过程和 HTTPS 安全的原因。</p>\n<p>我们来看看 TLS 握手的大致过程，这里不再详细叙述每个握手包</p>\n<p>{% asset_img tls-handshake.jpg TLS-handshake %}</p>\n<ul>\n<li><p>Client Hello</p>\n<p>  {% asset_img tls-handshake-1.png TLS-handshake-1 %}</p>\n<p>  可以看到 TCP 报文的 Push 为1，表示接收方尽快对该报文要尽快交付而不是积累到足够多的数据。</p>\n<p>  这是一个 TLS 握手包，我们可以看到 HandShakeType 为 ClientHello ，对应 TLS 握手图的第一步。</p>\n<p>   同时，该过程浏览器还发送了自己支持的一套加密规则。</p>\n</li>\n<li><p>Server Hello</p>\n<pre><code>   服务端接受到上述报文后，会发送 TCP 报文进行确认。报文如下\n\n   {% asset_img tls-handshake-2.png TLS-handshake-2 %}\n\n   服务端发出 ACK 包的同时，发送 TLS 报文，此时 HandShakeType 为 ServerHello，对应 TLS 握手图的第二步。\n\n   {% asset_img tls-handshake-3.png TLS-handshake-3 %}\n\n   接着上述的报文，服务端从客户端发来的加密规则中选出一组加密算法和 HASH 算法，并把自己的身份信息以证书形式发给客户端。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。如图，发送公钥使用了两个报文，最后客户端发送 ACK 确认报文进行确认，注意这个报文和上面的 ACK 报文一样不占用空间，只是进行确认而已。\n\n   {% asset_img tls-handshake-4.png TLS-handshake-4 %}\n</code></pre></li>\n<li><p>Client Key Exchange</p>\n<pre><code>   浏览器获得证书后，会首先验证证书的合法性，如果证书受信任，则浏览器栏里面会显示一个小绿锁。同时浏览器会生成一串随机数的密码，并用证书中提供的公钥进行加密，然后使用约定好的 HASH 算法计算握手信息，并使用未加密的随机数对消息进行加密。然后将消息重新发给服务端。这一步是加密握手包的开始。\n</code></pre></li>\n<li><p>Cipher Change Spec</p>\n<pre><code>   服务端使用自己的私钥对信息进行解密取出密码（密码被用公钥加密，只有用私钥才能加开，非对称加密），然后用该密码来解密握手消息，然后验证 HASH 是否与浏览器发来的一致。\n\n   接着使用这个密码来加密一段握手信息，发给客户端即浏览器。\n</code></pre></li>\n<li><p>Finish</p>\n<pre><code>   客户端用密码对加密握手包进行解密（注意此时已经变为对称加密），同时计算 HASH 值，若 HASH 值一致，则握手过程结束。之后双方通信都使用之前浏览器生成的密码来进行加密。\n</code></pre></li>\n</ul>\n<p>至此， HTTPS 连接已成功建立。由于浏览器会对证书进行校验，由证书授权机构保证其有效性，可以保证证书不被篡改。同时浏览器方面生成的随机数密码，一开始只有浏览器知道，而这个密码用公钥加密之后，只有私钥能解开，公钥也无法解开，这是非对称加密。服务器接收到该数据包后解开得到该密码，双方就可以使用该密码通过对称加密传输数据了。</p>\n<p>现给出 TCP 三次握手和 TLS 握手的列表信息。</p>\n<p>{% asset_img handshake.png HandsShake %}</p>\n<p>这之后双方都是用 TLS 来传输数据，但不带数据的 ACK 确认包不进行加密，仍然使用 TCP 协议来传输。</p>\n<p>需要明确的是，TLS 协议还是建立在 TCP 协议之上的，此处为便于说明将两者区分对待。即 TCP 协议是不进行加密的，TLS 是进行加密的 TCP 协议。</p>\n<p>这个过程其实是先进行 HTTP 连接建立的三次握手，然后服务器进行 3xx 重定向，然后再进行 HTTPS 的三次握手。这样既增加了连接建立的开销，而且也可能在 HTTP 连接建立的过程被劫持。所以有出现了 HSTS。</p>\n<blockquote>\n<p>HTTP 严格传输安全(HTTP Strict Transport Security)是一套由互联网工程任务组发布的互联网安全策略机制。网站可以选择使用 HSTS 策略，来让浏览器强制使用 HTTPS 与网站进行通信，以减少会话劫持风险。</p>\n</blockquote>\n<p>我们有时候会看到出现证警告的提醒，使用了 HSTS 之后用户将不再允许忽略警告。但是用户首次访问某个网站是不受 HSTS 保护的，因为首次访问时浏览器还未收到 HSTS ，目前比较流行的方案是浏览器预置 HTST 域名列表，Google Chrome, Firefox, IE, Edge 都实现了这一方案，我们可以在服务器配置相关信息后去进行登记。HSTS 可以抵御 SSL 剥离攻击，它利用用户通过 HTTP 建立连接再重定向到 HTTPS 连接，阻止浏览器与服务器建立 HTTPS 连接，攻击者可以在用户访问 HTTP 页面时替换所有 HTTPS 链接为 HTTP，达到阻止 HTTPS 的目的。</p>\n<h2 id=\"4-\">4. 客户端请求网站信息</h2>\n<ol>\n<li><p>如果访问的是网站的主页，那么此时会发送一个请求给服务器，如下：</p>\n<p>{% asset_img request-1.png request-package %}</p>\n<p>HTTP 里面附带了 URI, ProtocolVersion, Host, Connection 以及 Cookie 等很多信息。</p>\n<p>这里只讨论正常访问的情况。</p>\n</li>\n<li><p>服务端接收到该请求后，验证无误后，首先发送 ACK 报文进行确认。接着对该请求进行处理，如果是静态页面则直接返回。但大多数时候服务端都需要动态生成一个新的页面再返回该页面。这里讨论下 php 的处理。</p>\n<p>假设我们这时候访问的是<code>index.php</code>这个页面，服务器例如 Nginx 知道这个不是静态文件，它回去寻找 PHP 解析器去做处理，这依靠的就是 CGI 来实现。</p>\n<p>下面介绍几个概念，即 CGI, PHP-CGI, FastCGI, PHP-FPM。</p>\n<ul>\n<li><p>CGI</p>\n<p>CGI 全称是“公共网关接口”（Common Gateway Interface），HTTP 服务器与服务器上其他程序进行通讯的一种协议。</p>\n</li>\n<li><p>PHP-CGI</p>\n<p>简单的说 PHP-CGI 就是HTTP服务器与 PHP 进行通讯的工具，当浏览器发出一个类似 <code>/index.php</code> 的请求时，HTTP 服务器请求 PHP-CGI 去处理这个请求，PHP-CGI 处理完成后再把处理结果发回给 HTTP 服务器，然后由 HTTP 服务器发给浏览器。</p>\n<p>PHP-CGI 在处理请求之前，需要解析<code>php.ini</code>文件，初始化执行环境，然后才开始处理请求。</p>\n</li>\n<li><p>FastCGI</p>\n<p>FastCGI 全称是“快速通用网关接口”（Fast Common Gateway Interface / FastCGI）是一种让交互程序与 Web 服务器通信的协议。它是 CGI 的增强版本。</p>\n<p>CGI 程序运行在独立的进程中，并对每一个请求建立一个进程，每个建立都要经过解析配置文件和初始化执行环境。这种方法易于实现，但效率很差，难以面对大量请求。</p>\n<p>FastCGI 使用持续的进程来处理一连串的请求。这些进程由 FastCGI 服务器管理，而不是 Web 服务器。它是一个常驻型的 CGI(master)，只要激活后就不需要重新去解析 <code>php.ini</code> 和初始化，提高了效率。他在自身初始化后会启动多个 CGI 解析器(worker)，当有请求过来时，他会交给其中一个 worker 去处理。同时，它还可以动态调整 worker 的数量。</p>\n</li>\n<li><p>PHP-FPM</p>\n<p>PHP-FPM 是一个 PHP FastCGI 管理器，从 PHP 5.3.3 开始已经集成了 PHP-FPM，在编译安装时可以通过 <code>-enable-fpm</code> 参数开启。</p>\n<p>{% asset_img php-fpm.jpg php-fpm %}</p>\n</li>\n</ul>\n<p>所以浏览器如果请求 <code>/index.html</code> 那么 Web 服务器会直接把这个静态页面返回，如果是请求 <code>/index.php</code>，则交由 PHP-FPM 进行处理，PHP-FPM 处理后再把结果返回给 Web 服务器，由 Web 服务器发给浏览器。</p>\n<p>我们来看看响应报文</p>\n<p>{% asset_img response-1.png response-1 %}</p>\n<p>可以看到除了对浏览器请求的 ACK 确认包之外，服务端发回了10个包。第一个报文里面有StatusCode, Etag, ContentEncoding 等信息。这里面涉及到不少网站优化的技巧，我们将在下一篇中再讨论。这里大概了解下就可以了。</p>\n<p>接下来的9个报文都是跟着第1个报文一起过来的。最后一个报文设置了 PUSH 标志，因为报文已经传输完毕，所以它请求浏览器客户端尽快交付。</p>\n<p>接着客户端会发送 ACK 确认报文，之所以这里客户端对最后一个报文进行了确认，是因为 TCP Delayed Ack 的原因，它是为了避免多次发送 ACK 确认报文而设置的延时，一般为 40ms，也就是说如果接收到一个报文 40ms 后没有接收到第二个报文，他就会对这个报文进行确认。</p>\n<p>服务器发送完全部数据后，最后再发送一个报文，即图中的 #191 报文，表示我已经发完。客户端相应的发出 ACK 确认报文。主页请求结束。</p>\n</li>\n</ol>\n<h2 id=\"5-\">5. 浏览器渲染</h2>\n<p>浏览器接收到 <code>index.html</code> 后，开始浏览器渲染，这里讨论 webkit 内核，其他内核不讨论。主要分为四步进行。如下图:</p>\n<p>{% asset_img html-parse.png html-parse %}</p>\n<p>浏览器渲染不是本文的重点，所以只做简单说明。</p>\n<ul>\n<li><p>Parsing HTML to construct the DOM tree</p>\n<p>数据会交给 HTMLDocumentParser，然后 HTMLDocumentParser 将文本字符的解析交给 HTMLDocumentTokenizer 来负责，HTMLDocumentTokenizer 解析出一个一个的标签，然后 HTMLDocumentParser 将标签交给 HTMLTreeBuilder 来构建 DOM 树。</p>\n<p>有些节点需要加载其他资源，比如加载外链 CSS 和图片等。会调用资源加载器进行异步加载，不会阻碍当前 DOM 树的构造。但是如果是非 defer 非 async 的 script 标签，则需要停止当前 DOM 树的构造，直到脚本被加载并被 JavaScript 执行后才继续 DOM 树的构造。</p>\n<p>因此我们有时候会要求 &lt;script&gt; 标签放到最后面，目的是为了不影响前面 DOM 树的构建。</p>\n<p>对于 css 文件，会解析 css 生成 CSS Rule Tree。</p>\n<p>对于 JavaScript` 文件，主要是通过 DOM API 和 CSSOM API 来操作 DOM TREE 和 CSS Rule Tree，从而改变渲染的效果。</p>\n</li>\n<li><p>Render tree construction</p>\n<p>接着浏览器会开始构建渲染树(Rendering Tree)。Renderint Tree 只包括渲染页面需要的节点。</p>\n<p>CSS Rule Tree 会匹配的把 CSS Rule 附加到相应的 Rendering Tree 的元素上面。</p>\n<p>{% asset_img render-tree-construction.png render-tree-construction %}</p>\n</li>\n<li><p>Layout of the render tree</p>\n<p>到目前为止，我们已经计算了哪些节点是可见的，以及它们的计算样式，但还没有计算它们在设备视窗中的准确位置与尺寸。这就是布局阶段做的事情。</p>\n<p>渲染树的构建、布局与绘制所需的时间取决于文档大小、应用的样式，当然，还有运行文档的设备：文档越大，浏览器要完成的工作就越多；样式越复杂，绘制需要的时间就越长（例如，绘制单色成本较低，而计算、呈现阴影的成本就非常高了）。</p>\n</li>\n<li><p>Painting the render tree</p>\n<p>一旦布局完成，浏览器便会发出 Paint Setup 与 Paint 事件，将渲染树转化为屏幕上的实际像素。</p>\n</li>\n</ul>\n<p>大概可以用下图来表示整个过程。</p>\n<p>{% asset_img webkitflow.png webkitflow %}</p>\n<hr>\n<p>参考资料</p>\n<ul>\n<li><a href=\"https://technet.microsoft.com/en-us/library/cc775637.aspx\">How DNS query works</a></li>\n<li><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction\">Render Tree Construction</a></li>\n<li><a href=\"http://taligarsiel.com/Projects/howbrowserswork1.htm#Render_tree_construction\">How browsers work</a></li>\n</ul>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"从输入URL到页面展示.md","link":"/post/从输入URL到页面展示.html"},{"title":"Angular 学习总结","date":"2016-06-18T20:20:38.000Z","categories":"Angular","tags":["Angular","JavaScript","Front end"],"content":"<p>这学期基本都是在学习和使用 Angular ，这篇文章主要是想介绍几个 Angular 需要注意或者了解的地方。</p>\n<h2 id=\"angular-\">Angular作用域</h2>\n<p>​    也许你知道 ng-if 和 ng-show 的区别是一个只有条件满足的时候才会创建 DOM ，一个是只有在条件满足的时候才会显示 DOM 也就是一开始也会跟着创建。但是你可能不知道， ng-if 会产生新的作用域， ng-repeat 和 ng-switch 和 ng-include 也是如此。这时候内部如果使用外部的变量，第一次的时候会正常显示，因为 Angular 的继承是原型链继承，如果子类没有这个属性就会去尝试继承父类的属性， Angular 会拿父类的属性来创建新的属于这个子类的属性，而这个属性将不再和外层的父类的属性挂钩，如果不注意很可能就会在这里踩坑。</p>\n<blockquote>\n<p>读子类的属性时，子类有这个属性（hasOwnProperty）的时候则读子类自己的，子类没有的时候读父类的，不管子类有没有这个属性，在子类上都不会有新属性被创建。    </p>\n<p>写子类的属性时，如果子类有这个属性（hasOwnProperty）则写子类的，子类没有的话就会在子类上新建一个同名的新属性，而父类继承过来的属性被隐藏。</p>\n</blockquote>\n<p>​    关于原型链继承这个可以参考此处<a href=\"http://stackoverflow.com/questions/14049480/what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs/14049482#14049482\">JavaScript Prototypal Inheritance</a>，或者<a href=\"https://www.zybuluo.com/lxjwlt/note/107324\">[译文] 深入浅出 AngularJS 作用域</a></p>\n<p>​    使用上述的 ng-if ,  ng-repeat ,  ng-switch ,  ng-include 都会自己创建一级作用域，这点一定要注意。如果想要和父类的属性挂钩，可以使用 $parent 。</p>\n<p>​    但是，还没玩，也许这些你都知道。但是除了这些指令之外， textarea 也会自己创建一级作用域。所以你可能会发现你在 textarea 写的内容获取不到，但是却发现 textarea 总能取到第一次分配的初值。比如</p>\n<pre><code class=\"lang-html\">&lt;textarea ng-model=&quot;content&quot;, name=&quot;content&quot; <span class=\"keyword\">class</span>=&quot;form-control&quot; row=&quot;<span class=\"number\">3</span>&quot;&gt;&lt;/textarea&gt;\n</code></pre>\n<p>​    我们在控制器里面定义</p>\n<pre><code class=\"lang-javascript\"><span class=\"variable\">$scope</span>.content = &quot;测试&quot;\n</code></pre>\n<p>​    然后我们就会看到 textarea 的初值为&quot;测试&quot;，但是当我们更改其中的内容之后， $scope.content 却一直保持不变。</p>\n<p>​    同样，我们可以使用 $parent 的方式来解决这个问题。</p>\n<pre><code class=\"lang-html\">&lt;textarea ng-model=&quot;<span class=\"variable\">$parent</span>.content&quot;, name=&quot;content&quot; <span class=\"keyword\">class</span>=&quot;form-control&quot; row=&quot;<span class=\"number\">3</span>&quot;&gt;&lt;/textarea&gt;\n</code></pre>\n<p>​    那如果不想使用 $parent 的话，可以给 content 分配一个类名，比如</p>\n<pre><code class=\"lang-html\">&lt;textarea ng-model=&quot;comment.content&quot;, name=&quot;content&quot; <span class=\"keyword\">class</span>=&quot;form-control&quot; row=&quot;<span class=\"number\">3</span>&quot;&gt;&lt;/textarea&gt;\n</code></pre>\n<p>​    这样我们就可以通过 $scope.comment.content 来取值。</p>\n<h2 id=\"angular-track-by\">Angular track by</h2>\n<p>​    在使用 Angular 的 ng-repeat 迭代数组时，有时候会出现 Duplicates in a repeater are not allowed 的提示。</p>\n<p>​     track by 是用来建立 $watchCollection 和 DOM 之间的联系。建议自己加上 track by 后面带的值可以自己写，但要确保每个 ngRepeat 的值唯一，比如可以写 track by $index 。</p>\n<p>​    之所以要这么做，是因为，如果不使用 track by ，那么每个 ng-repeat 都会添加一个 $$hashkey 来对的 DOM 进行跟踪，这样会导致不能存在相同的 DOM ，使用 track by 的意义是避免不必要的渲染。</p>\n<p>​    官网API有进行详细的说明，不过我看了之后还是感觉不太明白，等我了解清楚了再来补充下。<a href=\"https://docs.angularjs.org/api/ng/directive/ngRepeat\">AngularJS: API: ngRepeat</a></p>\n<blockquote>\n<p>If you are working with objects that have an identifier property, you should track by the identifier instead of the whole object. Should you reload your data later,  ngRepeat  will not have to rebuild the DOM elements for items it has already rendered, even if the JavaScript objects in the collection have been substituted for new ones. For large collections, this significantly improves rendering performance. If you don&#39;t have a unique identifier,  track by $index  can also provide a performance boost.</p>\n</blockquote>\n<h2 id=\"angular-\">Angular拦截器</h2>\n<p>​     Angular 拦截器是 Angular 的一个强大功能，不过暂时没有怎么去研究，简单说下我的一些使用。</p>\n<ul>\n<li><p>判断请求是否成功</p>\n<pre><code class=\"lang-javascript\"><span class=\"variable\">$httpProvider</span>.defaults.transformResponse.push((response) =&gt; {\n  <span class=\"keyword\">if</span>(typeof(response.data) != undefined &amp;&amp; response.status == &amp;<span class=\"comment\">#39;success&amp;#39;) {</span>\n      response = response.data;\n    <span class=\"keyword\">return</span> response;\n  }\n  <span class=\"keyword\">if</span>(response.status == &amp;<span class=\"comment\">#39;error&amp;#39;) {</span>\n    console.log(&quot;Err: &quot; + response.message);\n    <span class=\"keyword\">return</span>;\n  }\n  <span class=\"keyword\">return</span> response;\n});\n</code></pre>\n<p>应该都能看懂，就不过多解释了。需要说明你的是，我们只需要一次配置，即可在整个项目中适用，特别方便。\n​</p>\n</li>\n<li><p>timestampMarker</p>\n<pre><code class=\"lang-javascript\">app.factory(&amp;<span class=\"comment\">#39;timestampMarker&amp;#39;, [() =&gt; {</span>\n  let timestampMarker = {\n    request: (config) = &gt; {\n      config.requestTimestamp = <span class=\"keyword\">new</span> Date().getTime();\n      <span class=\"keyword\">return</span> config;\n    },\n    response: (response) = &gt; {\n      response.config.responseTimestamp = <span class=\"keyword\">new</span> Date().getTime();\n      <span class=\"keyword\">return</span> response;\n    }\n  };\n}]);\n</code></pre>\n<p>这是给每个请求加上时间戳来防止浏览器缓存。</p>\n</li>\n<li><p>tokenInjector</p>\n<pre><code class=\"lang-javascript\">app.factory(&amp;<span class=\"comment\">#39;tokenInjector&amp;#39;, [&amp;#39;$injector&amp;#39;, &amp;#39;$q&amp;#39;, ($injector, $q) =&gt; {</span>\n    let tokenInjector = {\n          request: (config) =&gt; {\n        let url = host + &amp;<span class=\"comment\">#39;/auth_verify&amp;#39;;</span>\n        let deferred = <span class=\"variable\">$q</span>.defer();\n        let http = <span class=\"variable\">$injector</span>.get(&amp;<span class=\"comment\">#39;$http&amp;#39;);</span>\n        <span class=\"keyword\">if</span>(config.url === url) {\n          <span class=\"keyword\">return</span> config;\n        }\n        <span class=\"keyword\">if</span>(sessionStorage.verify === &amp;<span class=\"comment\">#39;true&amp;#39;) {</span>\n          let timestamp = <span class=\"keyword\">new</span> Date().getTime() / <span class=\"number\">1000</span>;\n           <span class=\"keyword\">if</span>(timestamp - sessionStorage.createdtime &gt;= <span class=\"number\">7000</span>) {\n              sessionStorage.verify = <span class=\"keyword\">false</span>;  \n          }\n           config.headers[&amp;<span class=\"comment\">#39;token&amp;#39;] = sessionStorage.token;</span>\n           config.headers[&amp;<span class=\"comment\">#39;userid&amp;#39;] = sessionStorage.user_id;</span>\n           deferred.resolve(config);\n        }\n    }\n  }\n}])\n</code></pre>\n<p>​上面是我从我的项目中截取的代码，作用是每次请求时，如果已经验证过，判断 token 创建时间和当前时间以判断 token 是否过期，如未过期，将 token 和 userid 加到请求的 headers 中。如果没有验证或者已经超时，则要去获取新的 token ，这里没有把代码写上。</p>\n</li>\n</ul>\n<p>​通过这三个例子，我想已经很明显的展示了 Angular 拦截器的强大之处。一次使用，终身受益，爽。</p>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"Angular学习总结.md","link":"/post/Angular学习总结.html"},{"title":"谈谈前端自动构建工具 Gulp","date":"2016-06-18T20:18:17.000Z","categories":"JavaScript","tags":["Angular","JavaScript","Front end","Gulp"],"content":"<p>​类似 Gulp 这样的工具可以说是前端利器，基本前端开发都离不开他，类似的解决方案还有 Grunt 和 Webpack 等，不过我用 Gulp 比较多一些，所以我只能谈谈 Gulp 了。</p>\n<p>​Gulp 上面优秀的插件特别多，我使用的有这些： </p>\n<pre><code class=\"lang-javascript\">import gulp from &amp;<span class=\"comment\">#39;gulp&amp;#39;</span>\nimport babel from &amp;<span class=\"comment\">#39;gulp-babel&amp;#39;</span>\nimport uglify from &amp;<span class=\"comment\">#39;gulp-uglify&amp;#39;</span>\nimport ngAnnotate from &amp;<span class=\"comment\">#39;gulp-ng-annotate&amp;#39;</span>\nimport concat from &amp;<span class=\"comment\">#39;gulp-concat&amp;#39;</span>\nimport cleanCSS from &amp;<span class=\"comment\">#39;gulp-clean-css&amp;#39;</span>\nimport imagemin from &amp;<span class=\"comment\">#39;gulp-imagemin&amp;#39;</span>\nimport minifyHtml from &amp;<span class=\"comment\">#39;gulp-minify-html&amp;#39;</span>\nimport ngTemplate from &amp;<span class=\"comment\">#39;gulp-ng-template&amp;#39;</span>\nimport plumber from &amp;<span class=\"comment\">#39;gulp-plumber&amp;#39;</span>\nimport sass from &amp;<span class=\"comment\">#39;gulp-sass&amp;#39;</span>\nimport usemin from &amp;<span class=\"comment\">#39;gulp-usemin&amp;#39;</span>\nimport runSequence from &amp;<span class=\"comment\">#39;gulp-run-sequence&amp;#39;</span>\nimport eslint from &amp;<span class=\"comment\">#39;gulp-eslint&amp;#39;</span>\n</code></pre>\n<ul>\n<li><p>gulp-uglify</p>\n<p>对 JavaScript 进行压缩的插件，可以有效减少 JavaScript 的文件大小。</p>\n</li>\n<li><p>gulp-ng-annotate</p>\n<p>对 Angular 的代码进行转换，因为使用上面的 <code>gulp-uglify</code> 对 Angular 的代码进行压缩时会破坏 Angular 文件的依赖注入功能，导致无法正常工作，这个基本上是 Angular 开发必备的了。</p>\n</li>\n<li><p>gulp-concat</p>\n<p>文件合并，前端合并文件以减少请求是非常重要的优化技巧。</p>\n</li>\n<li><p>gulp-clean-css</p>\n<p>字如其名，对css 进行合并压缩。</p>\n</li>\n<li><p>gulp-imagemin</p>\n<p>对图片进行压缩。</p>\n</li>\n<li><p>gulp-minify-html</p>\n<p>对html文件进行压缩。</p>\n</li>\n<li><p>gulp-ng-template</p>\n<p>这个也是 Angular 里面比较响当当的一个插件了，他的作用是将 Angular 模板存到 templateCache ，可以提升模板加载速度。</p>\n</li>\n<li><p>gulp-plumber</p>\n<p>这个貌似也是 Gulp 必不可少的插件之一了，可以避免 Gulp 出错导致整个进程崩掉。</p>\n</li>\n<li><p>gulp-sass</p>\n<p>编译 sass 代码为 css，非常方便。</p>\n</li>\n<li><p>gulp-run-sequence</p>\n<p>可以让 Gulp 的任务顺序执行，有些时候我们希望 Gulp 执行了一些任务完成之后才来执行下一个任务，这时候这个插件就派上用场了。</p>\n</li>\n<li><p>gulp-usemin</p>\n<p>这个是用来从工作环境到生产环境进行部署的工具。</p>\n</li>\n<li><p>gulp-eslint</p>\n<p>eslint 代码检查。</p>\n</li>\n</ul>\n<p>​    上面的这些插件都是我在一个项目中使用到的，通过这些工具实现了前端的自动化开发，我在项目中有开发环境和生产环境之分。</p>\n<p>​    在 Gulp 中，我有一段在开发环境下执行的任务</p>\n<pre><code class=\"lang-javascript\">gulp.task(&amp;<span class=\"comment\">#39;default&amp;#39;, [&amp;#39;css&amp;#39;, &amp;#39;js&amp;#39;, &amp;#39;angular&amp;#39;, &amp;#39;img&amp;#39;, &amp;#39;templates:dist&amp;#39;, &amp;#39;sass&amp;#39;, &amp;#39;fonts&amp;#39;])</span>\n</code></pre>\n<p>​    这段代码帮我做了</p>\n<ul>\n<li><code>css</code>：进行 css 文件(这些文件是第三方 css 文件如 bootstrap)的合并。</li>\n<li><code>javascript</code>：进行 JavaScript 文件的合并，这是将所有我写的 Angular 文件进行合并，但不进行压缩以方便我调试。</li>\n<li><code>angular</code>：将项目所有的 JavaScript 依赖如 Angular, ui-router, jQuery 等文件进行压缩合并。</li>\n<li><code>img</code>：将图片进行压缩和迁移，这些图片压缩后放入生产环境对应的文件夹中。</li>\n<li><code>templates:dist</code>：对 Angular 的视图进行合并，使用了上述的 <code>gulp-ng-template</code> 插件，合并后为一个新的 JavaScript 文件。</li>\n<li><code>sass</code>：将我写的 scss 代码进行编译。</li>\n<li><p><code>fonts</code>：移动相应的字体文件到生产环境中。</p>\n<p>​开发环境下我们需要自动构建，也需要便于调试，所以我用上面这样的方式来处理，并且开启了 watch 监视变化，在有更改发生时自动构建。当我处理完全部工作后需要 push 到服务器上面时，会执行 <code>gulp product</code> 即下面的 task。</p>\n</li>\n</ul>\n<pre><code class=\"lang-javascript\">gulp.task(&amp;<span class=\"comment\">#39;product&amp;#39;, function(cb){</span>\n  runSequence(&amp;<span class=\"comment\">#39;together&amp;#39;, &amp;#39;move&amp;#39;, cb)</span>\n});\n\ngulp.task(&amp;<span class=\"comment\">#39;together&amp;#39;, function(cb){</span>\n    gulp.src(&amp;<span class=\"comment\">#39;index.html&amp;#39;)</span>\n        .pipe(plumber())\n        .pipe(usemin({\n            cssProduct: [&amp;<span class=\"comment\">#39;concat&amp;#39;],</span>\n            jsProduct: [ngAnnotate(),&amp;<span class=\"comment\">#39;concat&amp;#39;,uglify()]</span>\n        }))\n        .pipe(gulp.dest(&amp;<span class=\"comment\">#39;backend/app/&amp;#39;))</span>\n        .on(&amp;<span class=\"comment\">#39;end&amp;#39;,cb);</span>\n});\n\ngulp.task(&amp;<span class=\"comment\">#39;move&amp;#39;, function(){</span>\n    <span class=\"keyword\">return</span> gulp.src(&amp;<span class=\"comment\">#39;backend/app/index.html&amp;#39;)</span>\n                .pipe(gulp.dest(&amp;<span class=\"comment\">#39;backend/app/templates/&amp;#39;));</span>\n});\n</code></pre>\n<p>​    这里使用了上述说的 <code>ng-run-sequence</code> 插件，这里会在执行完 <code>together</code> 的任务后才开始执行 <code>move</code> 的任务。这里主要使用的插件是 <code>gulp-usemin</code>，我用它来做了这些事情，为了方便说明，我贴下代码。需要先说明的是，我在项目中一共有3个 <code>index.html</code> 文件。</p>\n<pre><code class=\"lang-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;zh-CN&quot; ng-app=&quot;index&quot;&gt;\n&lt;head&gt;\n    &lt;!-- build:cssProduct /<span class=\"keyword\">static</span>/css/app.min.css --&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;src/css/app.min.css&quot;&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;src/css/bookist.css&quot;&gt;\n    &lt;!-- endbuild --&gt;\n&lt;body&gt;\n    ...\n    &lt;!-- build:jsProduct /<span class=\"keyword\">static</span>/js/app.min.js --&gt;\n    &lt;script src=&quot;src/js/dependence.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;src/js/app.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;src/js/templates.js&quot;&gt;&lt;/script&gt;\n    &lt;!-- endbuild --&gt;\n    &lt;!-- build:remove --&gt;\n    &lt;!--\n        这段注释会被移除\n    --&gt;\n    &lt;!-- endbuild--&gt;\n&lt;/body&gt;\n&lt;/head&gt;\n</code></pre>\n<p>​    省去了没有用的代码，这里需要你对 <code>ng-usemin</code> 有一定的了解。这个 <code>index.html</code> 是我在开发环境下使用的，使用了我开发环境的 task 生成文件，我在上面有补充说明了。</p>\n<p>​    所以，在部署生产环境时执行这段 task 的意义是，将开发环境下的代码再做进一步的合并和压缩。<code>ng-usemin</code> 这个插件会帮我们处理这个 <code>index.html</code> 文件，最后会在我们指定的目录下部署好这些东西。但是因为后端处理 <code>index.html</code> 的路径原因，我还要对 <code>index.html</code> 做一次移动，所以有了第三个 <code>index.html</code>。</p>\n<p>​    最终生成的 index 和相应的资源位置如下</p>\n<pre><code class=\"lang-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;zh-CN&quot; ng-app=&quot;index&quot;&gt;\n&lt;head&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;/<span class=\"keyword\">static</span>/css/app.min.css&quot;/&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;script src=&quot;/<span class=\"keyword\">static</span>/js/app.min.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n","config":{"title":"瑞铭的博客","description":"测试","github":"https://github.com/ruiming","google":"https://plus.google.com/115149019958723046324","pagination":{"index_page":5},"secret":"120rhub579175afigbj03t0135b09u60"},"name":"谈谈前端自动构建工具gulp.md","link":"/post/谈谈前端自动构建工具gulp.html"}]}